   1               		.file	"hal_pwm.c"
   2               	__SP_H__ = 0x3e
   3               	__SP_L__ = 0x3d
   4               	__SREG__ = 0x3f
   5               	__tmp_reg__ = 0
   6               	__zero_reg__ = 1
   7               		.text
   8               	.Ltext0:
   9               		.cfi_sections	.debug_frame
  10               		.section	.text.pwmInit,"ax",@progbits
  11               	.global	pwmInit
  13               	pwmInit:
  14               	.LFB243:
  15               		.file 1 "../../os/hal/src/hal_pwm.c"
   1:../../os/hal/src/hal_pwm.c **** /*
   2:../../os/hal/src/hal_pwm.c ****     ChibiOS - Copyright (C) 2006..2018 Giovanni Di Sirio
   3:../../os/hal/src/hal_pwm.c **** 
   4:../../os/hal/src/hal_pwm.c ****     Licensed under the Apache License, Version 2.0 (the "License");
   5:../../os/hal/src/hal_pwm.c ****     you may not use this file except in compliance with the License.
   6:../../os/hal/src/hal_pwm.c ****     You may obtain a copy of the License at
   7:../../os/hal/src/hal_pwm.c **** 
   8:../../os/hal/src/hal_pwm.c ****         http://www.apache.org/licenses/LICENSE-2.0
   9:../../os/hal/src/hal_pwm.c **** 
  10:../../os/hal/src/hal_pwm.c ****     Unless required by applicable law or agreed to in writing, software
  11:../../os/hal/src/hal_pwm.c ****     distributed under the License is distributed on an "AS IS" BASIS,
  12:../../os/hal/src/hal_pwm.c ****     WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
  13:../../os/hal/src/hal_pwm.c ****     See the License for the specific language governing permissions and
  14:../../os/hal/src/hal_pwm.c ****     limitations under the License.
  15:../../os/hal/src/hal_pwm.c **** */
  16:../../os/hal/src/hal_pwm.c **** 
  17:../../os/hal/src/hal_pwm.c **** /**
  18:../../os/hal/src/hal_pwm.c ****  * @file    hal_pwm.c
  19:../../os/hal/src/hal_pwm.c ****  * @brief   PWM Driver code.
  20:../../os/hal/src/hal_pwm.c ****  *
  21:../../os/hal/src/hal_pwm.c ****  * @addtogroup PWM
  22:../../os/hal/src/hal_pwm.c ****  * @{
  23:../../os/hal/src/hal_pwm.c ****  */
  24:../../os/hal/src/hal_pwm.c **** 
  25:../../os/hal/src/hal_pwm.c **** #include "hal.h"
  26:../../os/hal/src/hal_pwm.c **** 
  27:../../os/hal/src/hal_pwm.c **** #if (HAL_USE_PWM == TRUE) || defined(__DOXYGEN__)
  28:../../os/hal/src/hal_pwm.c **** 
  29:../../os/hal/src/hal_pwm.c **** /*===========================================================================*/
  30:../../os/hal/src/hal_pwm.c **** /* Driver local definitions.                                                 */
  31:../../os/hal/src/hal_pwm.c **** /*===========================================================================*/
  32:../../os/hal/src/hal_pwm.c **** 
  33:../../os/hal/src/hal_pwm.c **** /*===========================================================================*/
  34:../../os/hal/src/hal_pwm.c **** /* Driver exported variables.                                                */
  35:../../os/hal/src/hal_pwm.c **** /*===========================================================================*/
  36:../../os/hal/src/hal_pwm.c **** 
  37:../../os/hal/src/hal_pwm.c **** /*===========================================================================*/
  38:../../os/hal/src/hal_pwm.c **** /* Driver local variables and types.                                         */
  39:../../os/hal/src/hal_pwm.c **** /*===========================================================================*/
  40:../../os/hal/src/hal_pwm.c **** 
  41:../../os/hal/src/hal_pwm.c **** /*===========================================================================*/
  42:../../os/hal/src/hal_pwm.c **** /* Driver local functions.                                                   */
  43:../../os/hal/src/hal_pwm.c **** /*===========================================================================*/
  44:../../os/hal/src/hal_pwm.c **** 
  45:../../os/hal/src/hal_pwm.c **** /*===========================================================================*/
  46:../../os/hal/src/hal_pwm.c **** /* Driver exported functions.                                                */
  47:../../os/hal/src/hal_pwm.c **** /*===========================================================================*/
  48:../../os/hal/src/hal_pwm.c **** 
  49:../../os/hal/src/hal_pwm.c **** /**
  50:../../os/hal/src/hal_pwm.c ****  * @brief   PWM Driver initialization.
  51:../../os/hal/src/hal_pwm.c ****  * @note    This function is implicitly invoked by @p halInit(), there is
  52:../../os/hal/src/hal_pwm.c ****  *          no need to explicitly initialize the driver.
  53:../../os/hal/src/hal_pwm.c ****  *
  54:../../os/hal/src/hal_pwm.c ****  * @init
  55:../../os/hal/src/hal_pwm.c ****  */
  56:../../os/hal/src/hal_pwm.c **** void pwmInit(void) {
  16               		.loc 1 56 0
  17               		.cfi_startproc
  18               	/* prologue: function */
  19               	/* frame size = 0 */
  20               	/* stack size = 0 */
  21               	.L__stack_usage = 0
  57:../../os/hal/src/hal_pwm.c **** 
  58:../../os/hal/src/hal_pwm.c ****   pwm_lld_init();
  22               		.loc 1 58 0
  23 0000 0C94 0000 		jmp pwm_lld_init
  24               	.LVL0:
  25               		.cfi_endproc
  26               	.LFE243:
  28               		.section	.text.pwmObjectInit,"ax",@progbits
  29               	.global	pwmObjectInit
  31               	pwmObjectInit:
  32               	.LFB244:
  59:../../os/hal/src/hal_pwm.c **** }
  60:../../os/hal/src/hal_pwm.c **** 
  61:../../os/hal/src/hal_pwm.c **** /**
  62:../../os/hal/src/hal_pwm.c ****  * @brief   Initializes the standard part of a @p PWMDriver structure.
  63:../../os/hal/src/hal_pwm.c ****  *
  64:../../os/hal/src/hal_pwm.c ****  * @param[out] pwmp     pointer to a @p PWMDriver object
  65:../../os/hal/src/hal_pwm.c ****  *
  66:../../os/hal/src/hal_pwm.c ****  * @init
  67:../../os/hal/src/hal_pwm.c ****  */
  68:../../os/hal/src/hal_pwm.c **** void pwmObjectInit(PWMDriver *pwmp) {
  33               		.loc 1 68 0
  34               		.cfi_startproc
  35               	.LVL1:
  36               	/* prologue: function */
  37               	/* frame size = 0 */
  38               	/* stack size = 0 */
  39               	.L__stack_usage = 0
  40 0000 FC01      		movw r30,r24
  69:../../os/hal/src/hal_pwm.c **** 
  70:../../os/hal/src/hal_pwm.c ****   pwmp->state    = PWM_STOP;
  41               		.loc 1 70 0
  42 0002 81E0      		ldi r24,lo8(1)
  43               	.LVL2:
  44 0004 8083      		st Z,r24
  71:../../os/hal/src/hal_pwm.c ****   pwmp->config   = NULL;
  45               		.loc 1 71 0
  46 0006 1282      		std Z+2,__zero_reg__
  47 0008 1182      		std Z+1,__zero_reg__
  72:../../os/hal/src/hal_pwm.c ****   pwmp->enabled  = 0;
  48               		.loc 1 72 0
  49 000a 1582      		std Z+5,__zero_reg__
  73:../../os/hal/src/hal_pwm.c ****   pwmp->channels = 0;
  50               		.loc 1 73 0
  51 000c 1682      		std Z+6,__zero_reg__
  52               	/* epilogue start */
  74:../../os/hal/src/hal_pwm.c **** #if defined(PWM_DRIVER_EXT_INIT_HOOK)
  75:../../os/hal/src/hal_pwm.c ****   PWM_DRIVER_EXT_INIT_HOOK(pwmp);
  76:../../os/hal/src/hal_pwm.c **** #endif
  77:../../os/hal/src/hal_pwm.c **** }
  53               		.loc 1 77 0
  54 000e 0895      		ret
  55               		.cfi_endproc
  56               	.LFE244:
  58               		.section	.text.pwmStart,"ax",@progbits
  59               	.global	pwmStart
  61               	pwmStart:
  62               	.LFB245:
  78:../../os/hal/src/hal_pwm.c **** 
  79:../../os/hal/src/hal_pwm.c **** /**
  80:../../os/hal/src/hal_pwm.c ****  * @brief   Configures and activates the PWM peripheral.
  81:../../os/hal/src/hal_pwm.c ****  * @note    Starting a driver that is already in the @p PWM_READY state
  82:../../os/hal/src/hal_pwm.c ****  *          disables all the active channels.
  83:../../os/hal/src/hal_pwm.c ****  *
  84:../../os/hal/src/hal_pwm.c ****  * @param[in] pwmp      pointer to a @p PWMDriver object
  85:../../os/hal/src/hal_pwm.c ****  * @param[in] config    pointer to a @p PWMConfig object
  86:../../os/hal/src/hal_pwm.c ****  * @return              The operation status.
  87:../../os/hal/src/hal_pwm.c ****  *
  88:../../os/hal/src/hal_pwm.c ****  * @api
  89:../../os/hal/src/hal_pwm.c ****  */
  90:../../os/hal/src/hal_pwm.c **** msg_t pwmStart(PWMDriver *pwmp, const PWMConfig *config) {
  63               		.loc 1 90 0
  64               		.cfi_startproc
  65               	.LVL3:
  66 0000 CF93      		push r28
  67               	.LCFI0:
  68               		.cfi_def_cfa_offset 3
  69               		.cfi_offset 28, -2
  70 0002 DF93      		push r29
  71               	.LCFI1:
  72               		.cfi_def_cfa_offset 4
  73               		.cfi_offset 29, -3
  74               	/* prologue: function */
  75               	/* frame size = 0 */
  76               	/* stack size = 2 */
  77               	.L__stack_usage = 2
  78 0004 EC01      		movw r28,r24
  79               	.LBB113:
  80               	.LBB114:
  81               	.LBB115:
  82               	.LBB116:
  83               		.file 2 "../../os/common/ports/AVR/chcore.h"
   1:../../os/common/ports/AVR/chcore.h **** /*
   2:../../os/common/ports/AVR/chcore.h ****     ChibiOS - Copyright (C) 2006,2007,2008,2009,2010,2011,2012,2013,2014,
   3:../../os/common/ports/AVR/chcore.h ****               2015,2016,2017,2018,2019,2020,2021 Giovanni Di Sirio.
   4:../../os/common/ports/AVR/chcore.h **** 
   5:../../os/common/ports/AVR/chcore.h ****     This file is part of ChibiOS.
   6:../../os/common/ports/AVR/chcore.h **** 
   7:../../os/common/ports/AVR/chcore.h ****     ChibiOS is free software; you can redistribute it and/or modify
   8:../../os/common/ports/AVR/chcore.h ****     it under the terms of the GNU General Public License as published by
   9:../../os/common/ports/AVR/chcore.h ****     the Free Software Foundation version 3 of the License.
  10:../../os/common/ports/AVR/chcore.h **** 
  11:../../os/common/ports/AVR/chcore.h ****     ChibiOS is distributed in the hope that it will be useful,
  12:../../os/common/ports/AVR/chcore.h ****     but WITHOUT ANY WARRANTY; without even the implied warranty of
  13:../../os/common/ports/AVR/chcore.h ****     MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
  14:../../os/common/ports/AVR/chcore.h ****     GNU General Public License for more details.
  15:../../os/common/ports/AVR/chcore.h **** 
  16:../../os/common/ports/AVR/chcore.h ****     You should have received a copy of the GNU General Public License
  17:../../os/common/ports/AVR/chcore.h ****     along with this program.  If not, see <http://www.gnu.org/licenses/>.
  18:../../os/common/ports/AVR/chcore.h **** */
  19:../../os/common/ports/AVR/chcore.h **** 
  20:../../os/common/ports/AVR/chcore.h **** /**
  21:../../os/common/ports/AVR/chcore.h ****  * @file    chcore.h
  22:../../os/common/ports/AVR/chcore.h ****  * @brief   AVR port macros and structures.
  23:../../os/common/ports/AVR/chcore.h ****  *
  24:../../os/common/ports/AVR/chcore.h ****  * @addtogroup AVR_CORE
  25:../../os/common/ports/AVR/chcore.h ****  * @{
  26:../../os/common/ports/AVR/chcore.h ****  */
  27:../../os/common/ports/AVR/chcore.h **** 
  28:../../os/common/ports/AVR/chcore.h **** #ifndef CHCORE_H
  29:../../os/common/ports/AVR/chcore.h **** #define CHCORE_H
  30:../../os/common/ports/AVR/chcore.h **** 
  31:../../os/common/ports/AVR/chcore.h **** #include <avr/io.h>
  32:../../os/common/ports/AVR/chcore.h **** #include <avr/interrupt.h>
  33:../../os/common/ports/AVR/chcore.h **** 
  34:../../os/common/ports/AVR/chcore.h **** extern bool __avr_in_isr;
  35:../../os/common/ports/AVR/chcore.h **** 
  36:../../os/common/ports/AVR/chcore.h **** /*===========================================================================*/
  37:../../os/common/ports/AVR/chcore.h **** /* Module constants.                                                         */
  38:../../os/common/ports/AVR/chcore.h **** /*===========================================================================*/
  39:../../os/common/ports/AVR/chcore.h **** 
  40:../../os/common/ports/AVR/chcore.h **** /**
  41:../../os/common/ports/AVR/chcore.h ****  * @name    Port Capabilities and Constants
  42:../../os/common/ports/AVR/chcore.h ****  * @{
  43:../../os/common/ports/AVR/chcore.h ****  */
  44:../../os/common/ports/AVR/chcore.h **** /**
  45:../../os/common/ports/AVR/chcore.h ****  * @brief   This port supports a realtime counter.
  46:../../os/common/ports/AVR/chcore.h ****  */
  47:../../os/common/ports/AVR/chcore.h **** #define PORT_SUPPORTS_RT                FALSE
  48:../../os/common/ports/AVR/chcore.h **** 
  49:../../os/common/ports/AVR/chcore.h **** /**
  50:../../os/common/ports/AVR/chcore.h ****  * @brief   Natural alignment constant.
  51:../../os/common/ports/AVR/chcore.h ****  * @note    It is the minimum alignment for pointer-size variables.
  52:../../os/common/ports/AVR/chcore.h ****  */
  53:../../os/common/ports/AVR/chcore.h **** #define PORT_NATURAL_ALIGN              1U
  54:../../os/common/ports/AVR/chcore.h **** 
  55:../../os/common/ports/AVR/chcore.h **** /**
  56:../../os/common/ports/AVR/chcore.h ****  * @brief   Stack alignment constant.
  57:../../os/common/ports/AVR/chcore.h ****  * @note    It is the alignment required for the stack pointer.
  58:../../os/common/ports/AVR/chcore.h ****  */
  59:../../os/common/ports/AVR/chcore.h **** #define PORT_STACK_ALIGN                1U
  60:../../os/common/ports/AVR/chcore.h **** 
  61:../../os/common/ports/AVR/chcore.h **** /**
  62:../../os/common/ports/AVR/chcore.h ****  * @brief   Working Areas alignment constant.
  63:../../os/common/ports/AVR/chcore.h ****  * @note    It is the alignment to be enforced for thread working areas.
  64:../../os/common/ports/AVR/chcore.h ****  */
  65:../../os/common/ports/AVR/chcore.h **** #define PORT_WORKING_AREA_ALIGN         1U
  66:../../os/common/ports/AVR/chcore.h **** /** @} */
  67:../../os/common/ports/AVR/chcore.h **** 
  68:../../os/common/ports/AVR/chcore.h **** /**
  69:../../os/common/ports/AVR/chcore.h ****  * @name    Architecture and Compiler
  70:../../os/common/ports/AVR/chcore.h ****  * @{
  71:../../os/common/ports/AVR/chcore.h ****  */
  72:../../os/common/ports/AVR/chcore.h **** /**
  73:../../os/common/ports/AVR/chcore.h ****  * @brief   Macro defining an AVR architecture.
  74:../../os/common/ports/AVR/chcore.h ****  */
  75:../../os/common/ports/AVR/chcore.h **** #define PORT_ARCHITECTURE_AVR
  76:../../os/common/ports/AVR/chcore.h **** 
  77:../../os/common/ports/AVR/chcore.h **** /**
  78:../../os/common/ports/AVR/chcore.h ****  * @brief   Macro defining the specific AVR architecture.
  79:../../os/common/ports/AVR/chcore.h ****  */
  80:../../os/common/ports/AVR/chcore.h **** #define PORT_ARCHITECTURE_AVR_MEGAAVR
  81:../../os/common/ports/AVR/chcore.h **** 
  82:../../os/common/ports/AVR/chcore.h **** /**
  83:../../os/common/ports/AVR/chcore.h ****  * @brief   Name of the implemented architecture.
  84:../../os/common/ports/AVR/chcore.h ****  */
  85:../../os/common/ports/AVR/chcore.h **** #define PORT_ARCHITECTURE_NAME          "AVR"
  86:../../os/common/ports/AVR/chcore.h **** 
  87:../../os/common/ports/AVR/chcore.h **** /**
  88:../../os/common/ports/AVR/chcore.h ****  * @brief   Name of the architecture variant.
  89:../../os/common/ports/AVR/chcore.h ****  */
  90:../../os/common/ports/AVR/chcore.h **** #define PORT_CORE_VARIANT_NAME          "MegaAVR"
  91:../../os/common/ports/AVR/chcore.h **** 
  92:../../os/common/ports/AVR/chcore.h **** /**
  93:../../os/common/ports/AVR/chcore.h ****  * @brief   Compiler name and version.
  94:../../os/common/ports/AVR/chcore.h ****  */
  95:../../os/common/ports/AVR/chcore.h **** #if defined(__GNUC__) || defined(__DOXYGEN__)
  96:../../os/common/ports/AVR/chcore.h **** #define PORT_COMPILER_NAME              "GCC " __VERSION__
  97:../../os/common/ports/AVR/chcore.h **** 
  98:../../os/common/ports/AVR/chcore.h **** #else
  99:../../os/common/ports/AVR/chcore.h **** #error "unsupported compiler"
 100:../../os/common/ports/AVR/chcore.h **** #endif
 101:../../os/common/ports/AVR/chcore.h **** 
 102:../../os/common/ports/AVR/chcore.h **** /**
 103:../../os/common/ports/AVR/chcore.h ****  * @brief   Port-specific information string.
 104:../../os/common/ports/AVR/chcore.h ****  */
 105:../../os/common/ports/AVR/chcore.h **** #define PORT_INFO                       "None"
 106:../../os/common/ports/AVR/chcore.h **** /** @} */
 107:../../os/common/ports/AVR/chcore.h **** 
 108:../../os/common/ports/AVR/chcore.h **** /*===========================================================================*/
 109:../../os/common/ports/AVR/chcore.h **** /* Module pre-compile time settings.                                         */
 110:../../os/common/ports/AVR/chcore.h **** /*===========================================================================*/
 111:../../os/common/ports/AVR/chcore.h **** 
 112:../../os/common/ports/AVR/chcore.h **** /**
 113:../../os/common/ports/AVR/chcore.h ****  * @brief   Stack size for the system idle thread.
 114:../../os/common/ports/AVR/chcore.h ****  * @details This size depends on the idle thread implementation, usually
 115:../../os/common/ports/AVR/chcore.h ****  *          the idle thread should take no more space than those reserved
 116:../../os/common/ports/AVR/chcore.h ****  *          by @p PORT_INT_REQUIRED_STACK.
 117:../../os/common/ports/AVR/chcore.h ****  */
 118:../../os/common/ports/AVR/chcore.h **** #if !defined(PORT_IDLE_THREAD_STACK_SIZE) || defined(__DOXYGEN__)
 119:../../os/common/ports/AVR/chcore.h **** #define PORT_IDLE_THREAD_STACK_SIZE     8
 120:../../os/common/ports/AVR/chcore.h **** #endif
 121:../../os/common/ports/AVR/chcore.h **** 
 122:../../os/common/ports/AVR/chcore.h **** /**
 123:../../os/common/ports/AVR/chcore.h ****  * @brief   Per-thread stack overhead for interrupts servicing.
 124:../../os/common/ports/AVR/chcore.h ****  * @details This constant is used in the calculation of the correct working
 125:../../os/common/ports/AVR/chcore.h ****  *          area size.
 126:../../os/common/ports/AVR/chcore.h ****  */
 127:../../os/common/ports/AVR/chcore.h **** #if !defined(PORT_INT_REQUIRED_STACK) || defined(__DOXYGEN__)
 128:../../os/common/ports/AVR/chcore.h **** #define PORT_INT_REQUIRED_STACK         32
 129:../../os/common/ports/AVR/chcore.h **** #endif
 130:../../os/common/ports/AVR/chcore.h **** 
 131:../../os/common/ports/AVR/chcore.h **** /**
 132:../../os/common/ports/AVR/chcore.h ****  * @brief   Enables a "wait for interrupt" instruction in the idle loop.
 133:../../os/common/ports/AVR/chcore.h ****  */
 134:../../os/common/ports/AVR/chcore.h **** #if !defined(PORT_AVR_WFI_SLEEP_IDLE) || defined(__DOXYGEN__)
 135:../../os/common/ports/AVR/chcore.h **** #define PORT_AVR_WFI_SLEEP_IDLE      FALSE
 136:../../os/common/ports/AVR/chcore.h **** #endif
 137:../../os/common/ports/AVR/chcore.h **** 
 138:../../os/common/ports/AVR/chcore.h **** /*===========================================================================*/
 139:../../os/common/ports/AVR/chcore.h **** /* Derived constants and error checks.                                       */
 140:../../os/common/ports/AVR/chcore.h **** /*===========================================================================*/
 141:../../os/common/ports/AVR/chcore.h **** 
 142:../../os/common/ports/AVR/chcore.h **** /*===========================================================================*/
 143:../../os/common/ports/AVR/chcore.h **** /* Module data structures and types.                                         */
 144:../../os/common/ports/AVR/chcore.h **** /*===========================================================================*/
 145:../../os/common/ports/AVR/chcore.h **** 
 146:../../os/common/ports/AVR/chcore.h **** /* The following code is not processed when the file is included from an
 147:../../os/common/ports/AVR/chcore.h ****    asm module.*/
 148:../../os/common/ports/AVR/chcore.h **** #if !defined(_FROM_ASM_)
 149:../../os/common/ports/AVR/chcore.h **** 
 150:../../os/common/ports/AVR/chcore.h **** /**
 151:../../os/common/ports/AVR/chcore.h ****  * @brief   Type of stack and memory alignment enforcement.
 152:../../os/common/ports/AVR/chcore.h ****  * @note    In this architecture the stack alignment is enforced to 8 bits.
 153:../../os/common/ports/AVR/chcore.h ****  */
 154:../../os/common/ports/AVR/chcore.h **** typedef uint8_t stkalign_t;
 155:../../os/common/ports/AVR/chcore.h **** 
 156:../../os/common/ports/AVR/chcore.h **** /**
 157:../../os/common/ports/AVR/chcore.h ****  * @brief   Interrupt saved context.
 158:../../os/common/ports/AVR/chcore.h ****  * @details This structure represents the stack frame saved during a
 159:../../os/common/ports/AVR/chcore.h ****  *          preemption-capable interrupt handler.
 160:../../os/common/ports/AVR/chcore.h ****  * @note    R2 and R13 are not saved because those are assumed to be immutable
 161:../../os/common/ports/AVR/chcore.h ****  *          during the system life cycle.
 162:../../os/common/ports/AVR/chcore.h ****  */
 163:../../os/common/ports/AVR/chcore.h **** struct port_extctx {
 164:../../os/common/ports/AVR/chcore.h ****   uint8_t       _next;
 165:../../os/common/ports/AVR/chcore.h ****   uint8_t       r31;
 166:../../os/common/ports/AVR/chcore.h ****   uint8_t       r30;
 167:../../os/common/ports/AVR/chcore.h ****   uint8_t       r27;
 168:../../os/common/ports/AVR/chcore.h ****   uint8_t       r26;
 169:../../os/common/ports/AVR/chcore.h ****   uint8_t       r25;
 170:../../os/common/ports/AVR/chcore.h ****   uint8_t       r24;
 171:../../os/common/ports/AVR/chcore.h ****   uint8_t       r23;
 172:../../os/common/ports/AVR/chcore.h ****   uint8_t       r22;
 173:../../os/common/ports/AVR/chcore.h ****   uint8_t       r21;
 174:../../os/common/ports/AVR/chcore.h ****   uint8_t       r20;
 175:../../os/common/ports/AVR/chcore.h ****   uint8_t       r19;
 176:../../os/common/ports/AVR/chcore.h ****   uint8_t       r18;
 177:../../os/common/ports/AVR/chcore.h ****   uint8_t       sr;
 178:../../os/common/ports/AVR/chcore.h ****   uint8_t       r1;
 179:../../os/common/ports/AVR/chcore.h ****   uint8_t       r0;
 180:../../os/common/ports/AVR/chcore.h **** #if defined(__AVR_3_BYTE_PC__)
 181:../../os/common/ports/AVR/chcore.h ****   uint8_t       pcx;
 182:../../os/common/ports/AVR/chcore.h **** #endif
 183:../../os/common/ports/AVR/chcore.h ****   uint16_t      pc;
 184:../../os/common/ports/AVR/chcore.h **** };
 185:../../os/common/ports/AVR/chcore.h **** 
 186:../../os/common/ports/AVR/chcore.h **** /**
 187:../../os/common/ports/AVR/chcore.h ****  * @brief   System saved context.
 188:../../os/common/ports/AVR/chcore.h ****  * @details This structure represents the inner stack frame during a context
 189:../../os/common/ports/AVR/chcore.h ****  *          switching.
 190:../../os/common/ports/AVR/chcore.h ****  * @note    R2 and R13 are not saved because those are assumed to be immutable
 191:../../os/common/ports/AVR/chcore.h ****  *          during the system life cycle.
 192:../../os/common/ports/AVR/chcore.h ****  * @note    LR is stored in the caller context so it is not present in this
 193:../../os/common/ports/AVR/chcore.h ****  *          structure.
 194:../../os/common/ports/AVR/chcore.h ****  */
 195:../../os/common/ports/AVR/chcore.h **** struct port_intctx {
 196:../../os/common/ports/AVR/chcore.h ****   uint8_t       _next;
 197:../../os/common/ports/AVR/chcore.h ****   uint8_t       r29;
 198:../../os/common/ports/AVR/chcore.h ****   uint8_t       r28;
 199:../../os/common/ports/AVR/chcore.h ****   uint8_t       r17;
 200:../../os/common/ports/AVR/chcore.h ****   uint8_t       r16;
 201:../../os/common/ports/AVR/chcore.h ****   uint8_t       r15;
 202:../../os/common/ports/AVR/chcore.h ****   uint8_t       r14;
 203:../../os/common/ports/AVR/chcore.h ****   uint8_t       r13;
 204:../../os/common/ports/AVR/chcore.h ****   uint8_t       r12;
 205:../../os/common/ports/AVR/chcore.h ****   uint8_t       r11;
 206:../../os/common/ports/AVR/chcore.h ****   uint8_t       r10;
 207:../../os/common/ports/AVR/chcore.h ****   uint8_t       r9;
 208:../../os/common/ports/AVR/chcore.h ****   uint8_t       r8;
 209:../../os/common/ports/AVR/chcore.h ****   uint8_t       r7;
 210:../../os/common/ports/AVR/chcore.h ****   uint8_t       r6;
 211:../../os/common/ports/AVR/chcore.h ****   uint8_t       r5;
 212:../../os/common/ports/AVR/chcore.h ****   uint8_t       r4;
 213:../../os/common/ports/AVR/chcore.h ****   uint8_t       r3;
 214:../../os/common/ports/AVR/chcore.h ****   uint8_t       r2;
 215:../../os/common/ports/AVR/chcore.h **** #if defined(__AVR_3_BYTE_PC__)
 216:../../os/common/ports/AVR/chcore.h ****   uint8_t       pcx;
 217:../../os/common/ports/AVR/chcore.h **** #endif
 218:../../os/common/ports/AVR/chcore.h ****   uint8_t       pcl;
 219:../../os/common/ports/AVR/chcore.h ****   uint8_t       pch;
 220:../../os/common/ports/AVR/chcore.h **** };
 221:../../os/common/ports/AVR/chcore.h **** 
 222:../../os/common/ports/AVR/chcore.h **** /**
 223:../../os/common/ports/AVR/chcore.h ****  * @brief   Platform dependent part of the @p thread_t structure.
 224:../../os/common/ports/AVR/chcore.h ****  * @details This structure usually contains just the saved stack pointer
 225:../../os/common/ports/AVR/chcore.h ****  *          defined as a pointer to a @p port_intctx structure.
 226:../../os/common/ports/AVR/chcore.h ****  */
 227:../../os/common/ports/AVR/chcore.h **** struct port_context {
 228:../../os/common/ports/AVR/chcore.h ****   struct port_intctx *sp;
 229:../../os/common/ports/AVR/chcore.h **** };
 230:../../os/common/ports/AVR/chcore.h **** 
 231:../../os/common/ports/AVR/chcore.h **** #endif /* !defined(_FROM_ASM_) */
 232:../../os/common/ports/AVR/chcore.h **** 
 233:../../os/common/ports/AVR/chcore.h **** /*===========================================================================*/
 234:../../os/common/ports/AVR/chcore.h **** /* Module macros.                                                            */
 235:../../os/common/ports/AVR/chcore.h **** /*===========================================================================*/
 236:../../os/common/ports/AVR/chcore.h **** 
 237:../../os/common/ports/AVR/chcore.h **** /**
 238:../../os/common/ports/AVR/chcore.h ****  * @brief   Platform dependent part of the @p chThdCreateI() API.
 239:../../os/common/ports/AVR/chcore.h ****  * @details This code usually setup the context switching frame represented
 240:../../os/common/ports/AVR/chcore.h ****  *          by an @p port_intctx structure.
 241:../../os/common/ports/AVR/chcore.h ****  */
 242:../../os/common/ports/AVR/chcore.h **** #if defined(__AVR_3_BYTE_PC__) || defined(__DOXYGEN__)
 243:../../os/common/ports/AVR/chcore.h **** #define PORT_SETUP_CONTEXT(tp, wbase, wtop, pf, arg) {                      \
 244:../../os/common/ports/AVR/chcore.h ****   tp->ctx.sp = (struct port_intctx *)((uint8_t *)(wtop) -                   \
 245:../../os/common/ports/AVR/chcore.h ****                                       sizeof(struct port_intctx));          \
 246:../../os/common/ports/AVR/chcore.h ****   tp->ctx.sp->r2  = (uint8_t)(0xff & (uint16_t)pf);                         \
 247:../../os/common/ports/AVR/chcore.h ****   tp->ctx.sp->r3  = (uint8_t)((uint16_t)(pf) >> 8);                         \
 248:../../os/common/ports/AVR/chcore.h ****   tp->ctx.sp->r4  = (uint8_t)(0xff & (uint16_t)arg);                        \
 249:../../os/common/ports/AVR/chcore.h ****   tp->ctx.sp->r5  = (uint8_t)((uint16_t)(arg) >> 8);                        \
 250:../../os/common/ports/AVR/chcore.h ****   tp->ctx.sp->pcx = (uint8_t)0;                                             \
 251:../../os/common/ports/AVR/chcore.h ****   tp->ctx.sp->pcl = (uint16_t)_port_thread_start >> 8;                      \
 252:../../os/common/ports/AVR/chcore.h ****   tp->ctx.sp->pch = (uint8_t)(0xff & (uint16_t)_port_thread_start);         \
 253:../../os/common/ports/AVR/chcore.h **** }
 254:../../os/common/ports/AVR/chcore.h **** #else /* !__AVR_3_BYTE_PC__ */
 255:../../os/common/ports/AVR/chcore.h **** #define PORT_SETUP_CONTEXT(tp, wbase, wtop, pf, arg) {                      \
 256:../../os/common/ports/AVR/chcore.h ****   tp->ctx.sp = (struct port_intctx *)((uint8_t *)(wtop) -                   \
 257:../../os/common/ports/AVR/chcore.h ****                                       sizeof(struct port_intctx));          \
 258:../../os/common/ports/AVR/chcore.h ****   tp->ctx.sp->r2  = (uint8_t)(0xff & (uint16_t)pf);                         \
 259:../../os/common/ports/AVR/chcore.h ****   tp->ctx.sp->r3  = (uint8_t)((uint16_t)(pf) >> 8);                         \
 260:../../os/common/ports/AVR/chcore.h ****   tp->ctx.sp->r4  = (uint8_t)(0xff & (uint16_t)arg);                        \
 261:../../os/common/ports/AVR/chcore.h ****   tp->ctx.sp->r5  = (uint8_t)((uint16_t)(arg) >> 8);                        \
 262:../../os/common/ports/AVR/chcore.h ****   tp->ctx.sp->pcl = (uint16_t)_port_thread_start >> 8;                      \
 263:../../os/common/ports/AVR/chcore.h ****   tp->ctx.sp->pch = (uint8_t)(0xff & (uint16_t)_port_thread_start);         \
 264:../../os/common/ports/AVR/chcore.h **** }
 265:../../os/common/ports/AVR/chcore.h **** #endif /* !__AVR_3_BYTE_PC__ */
 266:../../os/common/ports/AVR/chcore.h **** 
 267:../../os/common/ports/AVR/chcore.h **** /**
 268:../../os/common/ports/AVR/chcore.h ****  * @brief   Computes the thread working area global size.
 269:../../os/common/ports/AVR/chcore.h ****  * @note    There is no need to perform alignments in this macro.
 270:../../os/common/ports/AVR/chcore.h ****  */
 271:../../os/common/ports/AVR/chcore.h **** #define PORT_WA_SIZE(n) ((sizeof(struct port_intctx) - 1) +                \
 272:../../os/common/ports/AVR/chcore.h ****                          (sizeof(struct port_extctx) - 1) +                \
 273:../../os/common/ports/AVR/chcore.h ****                          ((size_t)(n)) + ((size_t)(PORT_INT_REQUIRED_STACK)))
 274:../../os/common/ports/AVR/chcore.h **** 
 275:../../os/common/ports/AVR/chcore.h **** /**
 276:../../os/common/ports/AVR/chcore.h ****  * @brief   Static working area allocation.
 277:../../os/common/ports/AVR/chcore.h ****  * @details This macro is used to allocate a static thread working area
 278:../../os/common/ports/AVR/chcore.h ****  *          aligned as both position and size.
 279:../../os/common/ports/AVR/chcore.h ****  *
 280:../../os/common/ports/AVR/chcore.h ****  * @param[in] s         the name to be assigned to the stack array
 281:../../os/common/ports/AVR/chcore.h ****  * @param[in] n         the stack size to be assigned to the thread
 282:../../os/common/ports/AVR/chcore.h ****  */
 283:../../os/common/ports/AVR/chcore.h **** #define PORT_WORKING_AREA(s, n)                                             \
 284:../../os/common/ports/AVR/chcore.h ****   stkalign_t s[THD_WORKING_AREA_SIZE(n) / sizeof (stkalign_t)]
 285:../../os/common/ports/AVR/chcore.h **** 
 286:../../os/common/ports/AVR/chcore.h **** /**
 287:../../os/common/ports/AVR/chcore.h ****  * @brief   Priority level verification macro.
 288:../../os/common/ports/AVR/chcore.h ****  */
 289:../../os/common/ports/AVR/chcore.h **** #define PORT_IRQ_IS_VALID_PRIORITY(n) false
 290:../../os/common/ports/AVR/chcore.h **** 
 291:../../os/common/ports/AVR/chcore.h **** /**
 292:../../os/common/ports/AVR/chcore.h ****  * @brief   Priority level verification macro.
 293:../../os/common/ports/AVR/chcore.h ****  */
 294:../../os/common/ports/AVR/chcore.h **** #define PORT_IRQ_IS_VALID_KERNEL_PRIORITY(n) false
 295:../../os/common/ports/AVR/chcore.h **** 
 296:../../os/common/ports/AVR/chcore.h **** /**
 297:../../os/common/ports/AVR/chcore.h ****  * @brief   IRQ prologue code.
 298:../../os/common/ports/AVR/chcore.h ****  * @details This macro must be inserted at the start of all IRQ handlers
 299:../../os/common/ports/AVR/chcore.h ****  *          enabled to invoke system APIs.
 300:../../os/common/ports/AVR/chcore.h ****  * @note    This code tricks the compiler to save all the specified registers
 301:../../os/common/ports/AVR/chcore.h ****  *          by "touching" them.
 302:../../os/common/ports/AVR/chcore.h ****  */
 303:../../os/common/ports/AVR/chcore.h **** #define PORT_IRQ_PROLOGUE() {                                               \
 304:../../os/common/ports/AVR/chcore.h ****   asm ("" : : : "r18", "r19", "r20", "r21", "r22", "r23", "r24",            \
 305:../../os/common/ports/AVR/chcore.h ****                 "r25", "r26", "r27", "r30", "r31");                         \
 306:../../os/common/ports/AVR/chcore.h ****   __avr_in_isr = true;                                                      \
 307:../../os/common/ports/AVR/chcore.h **** }
 308:../../os/common/ports/AVR/chcore.h **** 
 309:../../os/common/ports/AVR/chcore.h **** /**
 310:../../os/common/ports/AVR/chcore.h ****  * @brief   IRQ epilogue code.
 311:../../os/common/ports/AVR/chcore.h ****  * @details This macro must be inserted at the end of all IRQ handlers
 312:../../os/common/ports/AVR/chcore.h ****  *          enabled to invoke system APIs.
 313:../../os/common/ports/AVR/chcore.h ****  */
 314:../../os/common/ports/AVR/chcore.h **** #define PORT_IRQ_EPILOGUE() {                                               \
 315:../../os/common/ports/AVR/chcore.h ****   __avr_in_isr = false;                                                     \
 316:../../os/common/ports/AVR/chcore.h ****   __dbg_check_lock();                                                       \
 317:../../os/common/ports/AVR/chcore.h ****   if (chSchIsPreemptionRequired())                                          \
 318:../../os/common/ports/AVR/chcore.h ****     chSchDoPreemption();                                                    \
 319:../../os/common/ports/AVR/chcore.h ****   __dbg_check_unlock();                                                     \
 320:../../os/common/ports/AVR/chcore.h **** }
 321:../../os/common/ports/AVR/chcore.h **** 
 322:../../os/common/ports/AVR/chcore.h **** /**
 323:../../os/common/ports/AVR/chcore.h ****  * @brief   IRQ handler function declaration.
 324:../../os/common/ports/AVR/chcore.h ****  * @note    @p id can be a function name or a vector number depending on the
 325:../../os/common/ports/AVR/chcore.h ****  *          port implementation.
 326:../../os/common/ports/AVR/chcore.h ****  */
 327:../../os/common/ports/AVR/chcore.h **** #define PORT_IRQ_HANDLER(id) ISR(id)
 328:../../os/common/ports/AVR/chcore.h **** 
 329:../../os/common/ports/AVR/chcore.h **** /**
 330:../../os/common/ports/AVR/chcore.h ****  * @brief   Fast IRQ handler function declaration.
 331:../../os/common/ports/AVR/chcore.h ****  * @note    @p id can be a function name or a vector number depending on the
 332:../../os/common/ports/AVR/chcore.h ****  *          port implementation.
 333:../../os/common/ports/AVR/chcore.h ****  */
 334:../../os/common/ports/AVR/chcore.h **** #define PORT_FAST_IRQ_HANDLER(id) ISR(id)
 335:../../os/common/ports/AVR/chcore.h **** 
 336:../../os/common/ports/AVR/chcore.h **** /**
 337:../../os/common/ports/AVR/chcore.h ****  * @brief   Performs a context switch between two threads.
 338:../../os/common/ports/AVR/chcore.h ****  * @details This is the most critical code in any port, this function
 339:../../os/common/ports/AVR/chcore.h ****  *          is responsible for the context switch between 2 threads.
 340:../../os/common/ports/AVR/chcore.h ****  * @note    The implementation of this code affects <b>directly</b> the context
 341:../../os/common/ports/AVR/chcore.h ****  *          switch performance so optimize here as much as you can.
 342:../../os/common/ports/AVR/chcore.h ****  *
 343:../../os/common/ports/AVR/chcore.h ****  * @param[in] ntp       the thread to be switched in
 344:../../os/common/ports/AVR/chcore.h ****  * @param[in] otp       the thread to be switched out
 345:../../os/common/ports/AVR/chcore.h ****  */
 346:../../os/common/ports/AVR/chcore.h **** #define port_switch(ntp, otp) {                                             \
 347:../../os/common/ports/AVR/chcore.h ****   _port_switch(ntp, otp);                                                   \
 348:../../os/common/ports/AVR/chcore.h ****   asm volatile ("" : : : "memory");                                         \
 349:../../os/common/ports/AVR/chcore.h **** }
 350:../../os/common/ports/AVR/chcore.h **** 
 351:../../os/common/ports/AVR/chcore.h **** 
 352:../../os/common/ports/AVR/chcore.h **** /**
 353:../../os/common/ports/AVR/chcore.h ****  * @brief   Port-related initialization code.
 354:../../os/common/ports/AVR/chcore.h ****  * @note    This function is empty in this port.
 355:../../os/common/ports/AVR/chcore.h ****  */
 356:../../os/common/ports/AVR/chcore.h **** #define port_init(oip) {                                                    \
 357:../../os/common/ports/AVR/chcore.h ****   __avr_in_isr = true;                                                      \
 358:../../os/common/ports/AVR/chcore.h **** }
 359:../../os/common/ports/AVR/chcore.h **** 
 360:../../os/common/ports/AVR/chcore.h **** /*===========================================================================*/
 361:../../os/common/ports/AVR/chcore.h **** /* External declarations.                                                    */
 362:../../os/common/ports/AVR/chcore.h **** /*===========================================================================*/
 363:../../os/common/ports/AVR/chcore.h **** 
 364:../../os/common/ports/AVR/chcore.h **** /* The following code is not processed when the file is included from an
 365:../../os/common/ports/AVR/chcore.h ****    asm module.*/
 366:../../os/common/ports/AVR/chcore.h **** #if !defined(_FROM_ASM_)
 367:../../os/common/ports/AVR/chcore.h **** 
 368:../../os/common/ports/AVR/chcore.h **** #ifdef __cplusplus
 369:../../os/common/ports/AVR/chcore.h **** extern "C" {
 370:../../os/common/ports/AVR/chcore.h **** #endif
 371:../../os/common/ports/AVR/chcore.h ****   void _port_switch(thread_t *ntp, thread_t *otp);
 372:../../os/common/ports/AVR/chcore.h ****   void _port_thread_start(void);
 373:../../os/common/ports/AVR/chcore.h **** #ifdef __cplusplus
 374:../../os/common/ports/AVR/chcore.h **** }
 375:../../os/common/ports/AVR/chcore.h **** #endif
 376:../../os/common/ports/AVR/chcore.h **** 
 377:../../os/common/ports/AVR/chcore.h **** #endif /* !defined(_FROM_ASM_) */
 378:../../os/common/ports/AVR/chcore.h **** 
 379:../../os/common/ports/AVR/chcore.h **** /*===========================================================================*/
 380:../../os/common/ports/AVR/chcore.h **** /* Module inline functions.                                                  */
 381:../../os/common/ports/AVR/chcore.h **** /*===========================================================================*/
 382:../../os/common/ports/AVR/chcore.h **** 
 383:../../os/common/ports/AVR/chcore.h **** /* The following code is not processed when the file is included from an
 384:../../os/common/ports/AVR/chcore.h ****    asm module.*/
 385:../../os/common/ports/AVR/chcore.h **** #if !defined(_FROM_ASM_)
 386:../../os/common/ports/AVR/chcore.h **** 
 387:../../os/common/ports/AVR/chcore.h **** /**
 388:../../os/common/ports/AVR/chcore.h ****  * @brief   Returns a word encoding the current interrupts status.
 389:../../os/common/ports/AVR/chcore.h ****  *
 390:../../os/common/ports/AVR/chcore.h ****  * @return              The interrupts status.
 391:../../os/common/ports/AVR/chcore.h ****  */
 392:../../os/common/ports/AVR/chcore.h **** static inline syssts_t port_get_irq_status(void) {
 393:../../os/common/ports/AVR/chcore.h **** 
 394:../../os/common/ports/AVR/chcore.h ****   return SREG;
 395:../../os/common/ports/AVR/chcore.h **** }
 396:../../os/common/ports/AVR/chcore.h **** 
 397:../../os/common/ports/AVR/chcore.h **** /**
 398:../../os/common/ports/AVR/chcore.h ****  * @brief   Checks the interrupt status.
 399:../../os/common/ports/AVR/chcore.h ****  *
 400:../../os/common/ports/AVR/chcore.h ****  * @param[in] sts       the interrupt status word
 401:../../os/common/ports/AVR/chcore.h ****  *
 402:../../os/common/ports/AVR/chcore.h ****  * @return              The interrupt status.
 403:../../os/common/ports/AVR/chcore.h ****  * @retval false        the word specified a disabled interrupts status.
 404:../../os/common/ports/AVR/chcore.h ****  * @retval true         the word specified an enabled interrupts status.
 405:../../os/common/ports/AVR/chcore.h ****  */
 406:../../os/common/ports/AVR/chcore.h **** static inline bool port_irq_enabled(syssts_t sts) {
 407:../../os/common/ports/AVR/chcore.h **** 
 408:../../os/common/ports/AVR/chcore.h ****   return (bool)((sts & 0x80) != 0);
 409:../../os/common/ports/AVR/chcore.h **** }
 410:../../os/common/ports/AVR/chcore.h **** 
 411:../../os/common/ports/AVR/chcore.h **** /**
 412:../../os/common/ports/AVR/chcore.h ****  * @brief   Determines the current execution context.
 413:../../os/common/ports/AVR/chcore.h ****  *
 414:../../os/common/ports/AVR/chcore.h ****  * @return              The execution context.
 415:../../os/common/ports/AVR/chcore.h ****  * @retval false        not running in ISR mode.
 416:../../os/common/ports/AVR/chcore.h ****  * @retval true         running in ISR mode.
 417:../../os/common/ports/AVR/chcore.h ****  */
 418:../../os/common/ports/AVR/chcore.h **** static inline bool port_is_isr_context(void) {
 419:../../os/common/ports/AVR/chcore.h **** 
 420:../../os/common/ports/AVR/chcore.h ****   return __avr_in_isr;
 421:../../os/common/ports/AVR/chcore.h **** }
 422:../../os/common/ports/AVR/chcore.h **** 
 423:../../os/common/ports/AVR/chcore.h **** /**
 424:../../os/common/ports/AVR/chcore.h ****  * @brief   Kernel-lock action.
 425:../../os/common/ports/AVR/chcore.h ****  * @details Usually this function just disables interrupts but may perform more
 426:../../os/common/ports/AVR/chcore.h ****  *          actions.
 427:../../os/common/ports/AVR/chcore.h ****  */
 428:../../os/common/ports/AVR/chcore.h **** static inline void port_lock(void) {
 429:../../os/common/ports/AVR/chcore.h **** 
 430:../../os/common/ports/AVR/chcore.h ****   asm volatile ("cli" : : : "memory");
  84               		.loc 2 430 0
  85               	/* #APP */
  86               	 ;  430 "../../os/common/ports/AVR/chcore.h" 1
  87 0006 F894      		cli
  88               	 ;  0 "" 2
  89               	/* #NOAPP */
  90               	.LBE116:
  91               	.LBE115:
  92               	.LBE114:
  93               	.LBE113:
  91:../../os/hal/src/hal_pwm.c ****   msg_t msg;
  92:../../os/hal/src/hal_pwm.c **** 
  93:../../os/hal/src/hal_pwm.c ****   osalDbgCheck((pwmp != NULL) && (config != NULL));
  94:../../os/hal/src/hal_pwm.c **** 
  95:../../os/hal/src/hal_pwm.c ****   osalSysLock();
  96:../../os/hal/src/hal_pwm.c ****   osalDbgAssert((pwmp->state == PWM_STOP) || (pwmp->state == PWM_READY),
  97:../../os/hal/src/hal_pwm.c ****                 "invalid state");
  98:../../os/hal/src/hal_pwm.c **** 
  99:../../os/hal/src/hal_pwm.c ****   pwmp->config = config;
  94               		.loc 1 99 0
  95 0008 7A83      		std Y+2,r23
  96 000a 6983      		std Y+1,r22
 100:../../os/hal/src/hal_pwm.c ****   pwmp->period = config->period;
  97               		.loc 1 100 0
  98 000c FB01      		movw r30,r22
  99 000e 8481      		ldd r24,Z+4
 100 0010 9581      		ldd r25,Z+5
 101               	.LVL4:
 102 0012 9C83      		std Y+4,r25
 103 0014 8B83      		std Y+3,r24
 101:../../os/hal/src/hal_pwm.c ****   pwmp->enabled = 0U;
 104               		.loc 1 101 0
 105 0016 1D82      		std Y+5,__zero_reg__
 102:../../os/hal/src/hal_pwm.c **** 
 103:../../os/hal/src/hal_pwm.c **** #if defined(PWM_LLD_ENHANCED_API)
 104:../../os/hal/src/hal_pwm.c ****   msg = pwm_lld_start(pwmp);
 105:../../os/hal/src/hal_pwm.c **** #else
 106:../../os/hal/src/hal_pwm.c ****   pwm_lld_start(pwmp);
 106               		.loc 1 106 0
 107 0018 CE01      		movw r24,r28
 108 001a 0E94 0000 		call pwm_lld_start
 109               	.LVL5:
 107:../../os/hal/src/hal_pwm.c ****   msg = HAL_RET_SUCCESS;
 108:../../os/hal/src/hal_pwm.c **** #endif
 109:../../os/hal/src/hal_pwm.c ****   if (msg == HAL_RET_SUCCESS) {
 110:../../os/hal/src/hal_pwm.c ****     pwmp->state = PWM_READY;
 110               		.loc 1 110 0
 111 001e 82E0      		ldi r24,lo8(2)
 112 0020 8883      		st Y,r24
 113               	.LBB117:
 114               	.LBB118:
 115               	.LBB119:
 116               	.LBB120:
 117               	.LBB121:
 431:../../os/common/ports/AVR/chcore.h **** }
 432:../../os/common/ports/AVR/chcore.h **** 
 433:../../os/common/ports/AVR/chcore.h **** /**
 434:../../os/common/ports/AVR/chcore.h ****  * @brief   Kernel-unlock action.
 435:../../os/common/ports/AVR/chcore.h ****  * @details Usually this function just enables interrupts but may perform more
 436:../../os/common/ports/AVR/chcore.h ****  *          actions.
 437:../../os/common/ports/AVR/chcore.h ****  */
 438:../../os/common/ports/AVR/chcore.h **** static inline void port_unlock(void) {
 439:../../os/common/ports/AVR/chcore.h **** 
 440:../../os/common/ports/AVR/chcore.h ****   asm volatile ("sei" : : : "memory");
 118               		.loc 2 440 0
 119               	/* #APP */
 120               	 ;  440 "../../os/common/ports/AVR/chcore.h" 1
 121 0022 7894      		sei
 122               	 ;  0 "" 2
 123               	/* #NOAPP */
 124               	.LBE121:
 125               	.LBE120:
 126               	.LBE119:
 127               	.LBE118:
 128               	.LBE117:
 111:../../os/hal/src/hal_pwm.c ****   }
 112:../../os/hal/src/hal_pwm.c ****   else {
 113:../../os/hal/src/hal_pwm.c ****     pwmp->state = PWM_STOP;
 114:../../os/hal/src/hal_pwm.c ****   }
 115:../../os/hal/src/hal_pwm.c **** 
 116:../../os/hal/src/hal_pwm.c ****   osalSysUnlock();
 117:../../os/hal/src/hal_pwm.c **** 
 118:../../os/hal/src/hal_pwm.c ****   return msg;
 119:../../os/hal/src/hal_pwm.c **** }
 129               		.loc 1 119 0
 130 0024 90E0      		ldi r25,0
 131 0026 80E0      		ldi r24,0
 132               	/* epilogue start */
 133 0028 DF91      		pop r29
 134 002a CF91      		pop r28
 135               	.LVL6:
 136 002c 0895      		ret
 137               		.cfi_endproc
 138               	.LFE245:
 140               		.section	.text.pwmStop,"ax",@progbits
 141               	.global	pwmStop
 143               	pwmStop:
 144               	.LFB246:
 120:../../os/hal/src/hal_pwm.c **** 
 121:../../os/hal/src/hal_pwm.c **** /**
 122:../../os/hal/src/hal_pwm.c ****  * @brief   Deactivates the PWM peripheral.
 123:../../os/hal/src/hal_pwm.c ****  *
 124:../../os/hal/src/hal_pwm.c ****  * @param[in] pwmp      pointer to a @p PWMDriver object
 125:../../os/hal/src/hal_pwm.c ****  *
 126:../../os/hal/src/hal_pwm.c ****  * @api
 127:../../os/hal/src/hal_pwm.c ****  */
 128:../../os/hal/src/hal_pwm.c **** void pwmStop(PWMDriver *pwmp) {
 145               		.loc 1 128 0
 146               		.cfi_startproc
 147               	.LVL7:
 148 0000 CF93      		push r28
 149               	.LCFI2:
 150               		.cfi_def_cfa_offset 3
 151               		.cfi_offset 28, -2
 152 0002 DF93      		push r29
 153               	.LCFI3:
 154               		.cfi_def_cfa_offset 4
 155               		.cfi_offset 29, -3
 156               	/* prologue: function */
 157               	/* frame size = 0 */
 158               	/* stack size = 2 */
 159               	.L__stack_usage = 2
 160 0004 EC01      		movw r28,r24
 161               	.LBB122:
 162               	.LBB123:
 163               	.LBB124:
 164               	.LBB125:
 430:../../os/common/ports/AVR/chcore.h **** }
 165               		.loc 2 430 0
 166               	/* #APP */
 167               	 ;  430 "../../os/common/ports/AVR/chcore.h" 1
 168 0006 F894      		cli
 169               	 ;  0 "" 2
 170               	/* #NOAPP */
 171               	.LBE125:
 172               	.LBE124:
 173               	.LBE123:
 174               	.LBE122:
 129:../../os/hal/src/hal_pwm.c **** 
 130:../../os/hal/src/hal_pwm.c ****   osalDbgCheck(pwmp != NULL);
 131:../../os/hal/src/hal_pwm.c **** 
 132:../../os/hal/src/hal_pwm.c ****   osalSysLock();
 133:../../os/hal/src/hal_pwm.c **** 
 134:../../os/hal/src/hal_pwm.c ****   osalDbgAssert((pwmp->state == PWM_STOP) || (pwmp->state == PWM_READY),
 135:../../os/hal/src/hal_pwm.c ****                 "invalid state");
 136:../../os/hal/src/hal_pwm.c **** 
 137:../../os/hal/src/hal_pwm.c ****   pwm_lld_stop(pwmp);
 175               		.loc 1 137 0
 176 0008 0E94 0000 		call pwm_lld_stop
 177               	.LVL8:
 138:../../os/hal/src/hal_pwm.c ****   pwmp->enabled = 0;
 178               		.loc 1 138 0
 179 000c 1D82      		std Y+5,__zero_reg__
 139:../../os/hal/src/hal_pwm.c ****   pwmp->config  = NULL;
 180               		.loc 1 139 0
 181 000e 1A82      		std Y+2,__zero_reg__
 182 0010 1982      		std Y+1,__zero_reg__
 140:../../os/hal/src/hal_pwm.c ****   pwmp->state   = PWM_STOP;
 183               		.loc 1 140 0
 184 0012 81E0      		ldi r24,lo8(1)
 185 0014 8883      		st Y,r24
 186               	.LBB126:
 187               	.LBB127:
 188               	.LBB128:
 189               	.LBB129:
 190               	.LBB130:
 191               		.loc 2 440 0
 192               	/* #APP */
 193               	 ;  440 "../../os/common/ports/AVR/chcore.h" 1
 194 0016 7894      		sei
 195               	 ;  0 "" 2
 196               	/* epilogue start */
 197               	/* #NOAPP */
 198               	.LBE130:
 199               	.LBE129:
 200               	.LBE128:
 201               	.LBE127:
 202               	.LBE126:
 141:../../os/hal/src/hal_pwm.c **** 
 142:../../os/hal/src/hal_pwm.c ****   osalSysUnlock();
 143:../../os/hal/src/hal_pwm.c **** }
 203               		.loc 1 143 0
 204 0018 DF91      		pop r29
 205 001a CF91      		pop r28
 206               	.LVL9:
 207 001c 0895      		ret
 208               		.cfi_endproc
 209               	.LFE246:
 211               		.section	.text.pwmChangePeriod,"ax",@progbits
 212               	.global	pwmChangePeriod
 214               	pwmChangePeriod:
 215               	.LFB247:
 144:../../os/hal/src/hal_pwm.c **** 
 145:../../os/hal/src/hal_pwm.c **** /**
 146:../../os/hal/src/hal_pwm.c ****  * @brief   Changes the period the PWM peripheral.
 147:../../os/hal/src/hal_pwm.c ****  * @details This function changes the period of a PWM unit that has already
 148:../../os/hal/src/hal_pwm.c ****  *          been activated using @p pwmStart().
 149:../../os/hal/src/hal_pwm.c ****  * @pre     The PWM unit must have been activated using @p pwmStart().
 150:../../os/hal/src/hal_pwm.c ****  * @post    The PWM unit period is changed to the new value.
 151:../../os/hal/src/hal_pwm.c ****  * @note    If a period is specified that is shorter than the pulse width
 152:../../os/hal/src/hal_pwm.c ****  *          programmed in one of the channels then the behavior is not
 153:../../os/hal/src/hal_pwm.c ****  *          guaranteed.
 154:../../os/hal/src/hal_pwm.c ****  *
 155:../../os/hal/src/hal_pwm.c ****  * @param[in] pwmp      pointer to a @p PWMDriver object
 156:../../os/hal/src/hal_pwm.c ****  * @param[in] period    new cycle time in ticks
 157:../../os/hal/src/hal_pwm.c ****  *
 158:../../os/hal/src/hal_pwm.c ****  * @api
 159:../../os/hal/src/hal_pwm.c ****  */
 160:../../os/hal/src/hal_pwm.c **** void pwmChangePeriod(PWMDriver *pwmp, pwmcnt_t period) {
 216               		.loc 1 160 0
 217               		.cfi_startproc
 218               	.LVL10:
 219               	/* prologue: function */
 220               	/* frame size = 0 */
 221               	/* stack size = 0 */
 222               	.L__stack_usage = 0
 223               	.LBB131:
 224               	.LBB132:
 225               	.LBB133:
 226               	.LBB134:
 430:../../os/common/ports/AVR/chcore.h **** }
 227               		.loc 2 430 0
 228               	/* #APP */
 229               	 ;  430 "../../os/common/ports/AVR/chcore.h" 1
 230 0000 F894      		cli
 231               	 ;  0 "" 2
 232               	/* #NOAPP */
 233               	.LBE134:
 234               	.LBE133:
 235               	.LBE132:
 236               	.LBE131:
 161:../../os/hal/src/hal_pwm.c **** 
 162:../../os/hal/src/hal_pwm.c ****   osalDbgCheck(pwmp != NULL);
 163:../../os/hal/src/hal_pwm.c **** 
 164:../../os/hal/src/hal_pwm.c ****   osalSysLock();
 165:../../os/hal/src/hal_pwm.c ****   osalDbgAssert(pwmp->state == PWM_READY, "invalid state");
 166:../../os/hal/src/hal_pwm.c ****   pwmChangePeriodI(pwmp, period);
 237               		.loc 1 166 0
 238 0002 FC01      		movw r30,r24
 239 0004 7483      		std Z+4,r23
 240 0006 6383      		std Z+3,r22
 241 0008 0E94 0000 		call pwm_lld_change_period
 242               	.LVL11:
 243               	.LBB135:
 244               	.LBB136:
 245               	.LBB137:
 246               	.LBB138:
 247               	.LBB139:
 248               		.loc 2 440 0
 249               	/* #APP */
 250               	 ;  440 "../../os/common/ports/AVR/chcore.h" 1
 251 000c 7894      		sei
 252               	 ;  0 "" 2
 253               	/* epilogue start */
 254               	/* #NOAPP */
 255               	.LBE139:
 256               	.LBE138:
 257               	.LBE137:
 258               	.LBE136:
 259               	.LBE135:
 167:../../os/hal/src/hal_pwm.c ****   osalSysUnlock();
 168:../../os/hal/src/hal_pwm.c **** }
 260               		.loc 1 168 0
 261 000e 0895      		ret
 262               		.cfi_endproc
 263               	.LFE247:
 265               		.section	.text.pwmEnableChannel,"ax",@progbits
 266               	.global	pwmEnableChannel
 268               	pwmEnableChannel:
 269               	.LFB248:
 169:../../os/hal/src/hal_pwm.c **** 
 170:../../os/hal/src/hal_pwm.c **** /**
 171:../../os/hal/src/hal_pwm.c ****  * @brief   Enables a PWM channel.
 172:../../os/hal/src/hal_pwm.c ****  * @pre     The PWM unit must have been activated using @p pwmStart().
 173:../../os/hal/src/hal_pwm.c ****  * @post    The channel is active using the specified configuration.
 174:../../os/hal/src/hal_pwm.c ****  * @note    Depending on the hardware implementation this function has
 175:../../os/hal/src/hal_pwm.c ****  *          effect starting on the next cycle (recommended implementation)
 176:../../os/hal/src/hal_pwm.c ****  *          or immediately (fallback implementation).
 177:../../os/hal/src/hal_pwm.c ****  *
 178:../../os/hal/src/hal_pwm.c ****  * @param[in] pwmp      pointer to a @p PWMDriver object
 179:../../os/hal/src/hal_pwm.c ****  * @param[in] channel   PWM channel identifier (0...channels-1)
 180:../../os/hal/src/hal_pwm.c ****  * @param[in] width     PWM pulse width as clock pulses number
 181:../../os/hal/src/hal_pwm.c ****  *
 182:../../os/hal/src/hal_pwm.c ****  * @api
 183:../../os/hal/src/hal_pwm.c ****  */
 184:../../os/hal/src/hal_pwm.c **** void pwmEnableChannel(PWMDriver *pwmp,
 185:../../os/hal/src/hal_pwm.c ****                       pwmchannel_t channel,
 186:../../os/hal/src/hal_pwm.c ****                       pwmcnt_t width) {
 270               		.loc 1 186 0
 271               		.cfi_startproc
 272               	.LVL12:
 273               	/* prologue: function */
 274               	/* frame size = 0 */
 275               	/* stack size = 0 */
 276               	.L__stack_usage = 0
 277               	.LBB140:
 278               	.LBB141:
 279               	.LBB142:
 280               	.LBB143:
 430:../../os/common/ports/AVR/chcore.h **** }
 281               		.loc 2 430 0
 282               	/* #APP */
 283               	 ;  430 "../../os/common/ports/AVR/chcore.h" 1
 284 0000 F894      		cli
 285               	 ;  0 "" 2
 286               	/* #NOAPP */
 287               	.LBE143:
 288               	.LBE142:
 289               	.LBE141:
 290               	.LBE140:
 187:../../os/hal/src/hal_pwm.c **** 
 188:../../os/hal/src/hal_pwm.c ****   osalDbgCheck((pwmp != NULL) && (channel < pwmp->channels));
 189:../../os/hal/src/hal_pwm.c **** 
 190:../../os/hal/src/hal_pwm.c ****   osalSysLock();
 191:../../os/hal/src/hal_pwm.c **** 
 192:../../os/hal/src/hal_pwm.c ****   osalDbgAssert(pwmp->state == PWM_READY, "not ready");
 193:../../os/hal/src/hal_pwm.c **** 
 194:../../os/hal/src/hal_pwm.c ****   pwmEnableChannelI(pwmp, channel, width);
 291               		.loc 1 194 0
 292 0002 E1E0      		ldi r30,lo8(1)
 293 0004 F0E0      		ldi r31,0
 294 0006 062E      		mov r0,r22
 295 0008 00C0      		rjmp 2f
 296               		1:
 297 000a EE0F      		lsl r30
 298               		2:
 299 000c 0A94      		dec r0
 300 000e 02F4      		brpl 1b
 301 0010 DC01      		movw r26,r24
 302 0012 1596      		adiw r26,5
 303 0014 2C91      		ld r18,X
 304 0016 1597      		sbiw r26,5
 305 0018 2E2B      		or r18,r30
 306 001a 1596      		adiw r26,5
 307 001c 2C93      		st X,r18
 308 001e 0E94 0000 		call pwm_lld_enable_channel
 309               	.LVL13:
 310               	.LBB144:
 311               	.LBB145:
 312               	.LBB146:
 313               	.LBB147:
 314               	.LBB148:
 315               		.loc 2 440 0
 316               	/* #APP */
 317               	 ;  440 "../../os/common/ports/AVR/chcore.h" 1
 318 0022 7894      		sei
 319               	 ;  0 "" 2
 320               	/* epilogue start */
 321               	/* #NOAPP */
 322               	.LBE148:
 323               	.LBE147:
 324               	.LBE146:
 325               	.LBE145:
 326               	.LBE144:
 195:../../os/hal/src/hal_pwm.c **** 
 196:../../os/hal/src/hal_pwm.c ****   osalSysUnlock();
 197:../../os/hal/src/hal_pwm.c **** }
 327               		.loc 1 197 0
 328 0024 0895      		ret
 329               		.cfi_endproc
 330               	.LFE248:
 332               		.section	.text.pwmDisableChannel,"ax",@progbits
 333               	.global	pwmDisableChannel
 335               	pwmDisableChannel:
 336               	.LFB249:
 198:../../os/hal/src/hal_pwm.c **** 
 199:../../os/hal/src/hal_pwm.c **** /**
 200:../../os/hal/src/hal_pwm.c ****  * @brief   Disables a PWM channel and its notification.
 201:../../os/hal/src/hal_pwm.c ****  * @pre     The PWM unit must have been activated using @p pwmStart().
 202:../../os/hal/src/hal_pwm.c ****  * @post    The channel is disabled and its output line returned to the
 203:../../os/hal/src/hal_pwm.c ****  *          idle state.
 204:../../os/hal/src/hal_pwm.c ****  * @note    Depending on the hardware implementation this function has
 205:../../os/hal/src/hal_pwm.c ****  *          effect starting on the next cycle (recommended implementation)
 206:../../os/hal/src/hal_pwm.c ****  *          or immediately (fallback implementation).
 207:../../os/hal/src/hal_pwm.c ****  *
 208:../../os/hal/src/hal_pwm.c ****  * @param[in] pwmp      pointer to a @p PWMDriver object
 209:../../os/hal/src/hal_pwm.c ****  * @param[in] channel   PWM channel identifier (0...channels-1)
 210:../../os/hal/src/hal_pwm.c ****  *
 211:../../os/hal/src/hal_pwm.c ****  * @api
 212:../../os/hal/src/hal_pwm.c ****  */
 213:../../os/hal/src/hal_pwm.c **** void pwmDisableChannel(PWMDriver *pwmp, pwmchannel_t channel) {
 337               		.loc 1 213 0
 338               		.cfi_startproc
 339               	.LVL14:
 340               	/* prologue: function */
 341               	/* frame size = 0 */
 342               	/* stack size = 0 */
 343               	.L__stack_usage = 0
 344               	.LBB149:
 345               	.LBB150:
 346               	.LBB151:
 347               	.LBB152:
 430:../../os/common/ports/AVR/chcore.h **** }
 348               		.loc 2 430 0
 349               	/* #APP */
 350               	 ;  430 "../../os/common/ports/AVR/chcore.h" 1
 351 0000 F894      		cli
 352               	 ;  0 "" 2
 353               	/* #NOAPP */
 354               	.LBE152:
 355               	.LBE151:
 356               	.LBE150:
 357               	.LBE149:
 214:../../os/hal/src/hal_pwm.c **** 
 215:../../os/hal/src/hal_pwm.c ****   osalDbgCheck((pwmp != NULL) && (channel < pwmp->channels));
 216:../../os/hal/src/hal_pwm.c **** 
 217:../../os/hal/src/hal_pwm.c ****   osalSysLock();
 218:../../os/hal/src/hal_pwm.c **** 
 219:../../os/hal/src/hal_pwm.c ****   osalDbgAssert(pwmp->state == PWM_READY, "not ready");
 220:../../os/hal/src/hal_pwm.c **** 
 221:../../os/hal/src/hal_pwm.c ****   pwmDisableChannelI(pwmp, channel);
 358               		.loc 1 221 0
 359 0002 21E0      		ldi r18,lo8(1)
 360 0004 30E0      		ldi r19,0
 361 0006 062E      		mov r0,r22
 362 0008 00C0      		rjmp 2f
 363               		1:
 364 000a 220F      		lsl r18
 365               		2:
 366 000c 0A94      		dec r0
 367 000e 02F4      		brpl 1b
 368 0010 2095      		com r18
 369 0012 FC01      		movw r30,r24
 370 0014 3581      		ldd r19,Z+5
 371 0016 2323      		and r18,r19
 372 0018 2583      		std Z+5,r18
 373 001a 0E94 0000 		call pwm_lld_disable_channel
 374               	.LVL15:
 375               	.LBB153:
 376               	.LBB154:
 377               	.LBB155:
 378               	.LBB156:
 379               	.LBB157:
 380               		.loc 2 440 0
 381               	/* #APP */
 382               	 ;  440 "../../os/common/ports/AVR/chcore.h" 1
 383 001e 7894      		sei
 384               	 ;  0 "" 2
 385               	/* epilogue start */
 386               	/* #NOAPP */
 387               	.LBE157:
 388               	.LBE156:
 389               	.LBE155:
 390               	.LBE154:
 391               	.LBE153:
 222:../../os/hal/src/hal_pwm.c **** 
 223:../../os/hal/src/hal_pwm.c ****   osalSysUnlock();
 224:../../os/hal/src/hal_pwm.c **** }
 392               		.loc 1 224 0
 393 0020 0895      		ret
 394               		.cfi_endproc
 395               	.LFE249:
 397               		.section	.text.pwmEnablePeriodicNotification,"ax",@progbits
 398               	.global	pwmEnablePeriodicNotification
 400               	pwmEnablePeriodicNotification:
 401               	.LFB250:
 225:../../os/hal/src/hal_pwm.c **** 
 226:../../os/hal/src/hal_pwm.c **** /**
 227:../../os/hal/src/hal_pwm.c ****  * @brief   Enables the periodic activation edge notification.
 228:../../os/hal/src/hal_pwm.c ****  * @pre     The PWM unit must have been activated using @p pwmStart().
 229:../../os/hal/src/hal_pwm.c ****  * @note    If the notification is already enabled then the call has no effect.
 230:../../os/hal/src/hal_pwm.c ****  *
 231:../../os/hal/src/hal_pwm.c ****  * @param[in] pwmp      pointer to a @p PWMDriver object
 232:../../os/hal/src/hal_pwm.c ****  *
 233:../../os/hal/src/hal_pwm.c ****  * @api
 234:../../os/hal/src/hal_pwm.c ****  */
 235:../../os/hal/src/hal_pwm.c **** void pwmEnablePeriodicNotification(PWMDriver *pwmp) {
 402               		.loc 1 235 0
 403               		.cfi_startproc
 404               	.LVL16:
 405               	/* prologue: function */
 406               	/* frame size = 0 */
 407               	/* stack size = 0 */
 408               	.L__stack_usage = 0
 409               	.LBB158:
 410               	.LBB159:
 411               	.LBB160:
 412               	.LBB161:
 430:../../os/common/ports/AVR/chcore.h **** }
 413               		.loc 2 430 0
 414               	/* #APP */
 415               	 ;  430 "../../os/common/ports/AVR/chcore.h" 1
 416 0000 F894      		cli
 417               	 ;  0 "" 2
 418               	/* #NOAPP */
 419               	.LBE161:
 420               	.LBE160:
 421               	.LBE159:
 422               	.LBE158:
 236:../../os/hal/src/hal_pwm.c **** 
 237:../../os/hal/src/hal_pwm.c ****   osalDbgCheck(pwmp != NULL);
 238:../../os/hal/src/hal_pwm.c **** 
 239:../../os/hal/src/hal_pwm.c ****   osalSysLock();
 240:../../os/hal/src/hal_pwm.c **** 
 241:../../os/hal/src/hal_pwm.c ****   osalDbgAssert(pwmp->state == PWM_READY, "not ready");
 242:../../os/hal/src/hal_pwm.c ****   osalDbgAssert(pwmp->config->callback != NULL, "undefined periodic callback");
 243:../../os/hal/src/hal_pwm.c **** 
 244:../../os/hal/src/hal_pwm.c ****   pwmEnablePeriodicNotificationI(pwmp);
 423               		.loc 1 244 0
 424 0002 0E94 0000 		call pwm_lld_enable_periodic_notification
 425               	.LVL17:
 426               	.LBB162:
 427               	.LBB163:
 428               	.LBB164:
 429               	.LBB165:
 430               	.LBB166:
 431               		.loc 2 440 0
 432               	/* #APP */
 433               	 ;  440 "../../os/common/ports/AVR/chcore.h" 1
 434 0006 7894      		sei
 435               	 ;  0 "" 2
 436               	/* epilogue start */
 437               	/* #NOAPP */
 438               	.LBE166:
 439               	.LBE165:
 440               	.LBE164:
 441               	.LBE163:
 442               	.LBE162:
 245:../../os/hal/src/hal_pwm.c **** 
 246:../../os/hal/src/hal_pwm.c ****   osalSysUnlock();
 247:../../os/hal/src/hal_pwm.c **** }
 443               		.loc 1 247 0
 444 0008 0895      		ret
 445               		.cfi_endproc
 446               	.LFE250:
 448               		.section	.text.pwmDisablePeriodicNotification,"ax",@progbits
 449               	.global	pwmDisablePeriodicNotification
 451               	pwmDisablePeriodicNotification:
 452               	.LFB251:
 248:../../os/hal/src/hal_pwm.c **** 
 249:../../os/hal/src/hal_pwm.c **** /**
 250:../../os/hal/src/hal_pwm.c ****  * @brief   Disables the periodic activation edge notification.
 251:../../os/hal/src/hal_pwm.c ****  * @pre     The PWM unit must have been activated using @p pwmStart().
 252:../../os/hal/src/hal_pwm.c ****  * @note    If the notification is already disabled then the call has no effect.
 253:../../os/hal/src/hal_pwm.c ****  *
 254:../../os/hal/src/hal_pwm.c ****  * @param[in] pwmp      pointer to a @p PWMDriver object
 255:../../os/hal/src/hal_pwm.c ****  *
 256:../../os/hal/src/hal_pwm.c ****  * @api
 257:../../os/hal/src/hal_pwm.c ****  */
 258:../../os/hal/src/hal_pwm.c **** void pwmDisablePeriodicNotification(PWMDriver *pwmp) {
 453               		.loc 1 258 0
 454               		.cfi_startproc
 455               	.LVL18:
 456               	/* prologue: function */
 457               	/* frame size = 0 */
 458               	/* stack size = 0 */
 459               	.L__stack_usage = 0
 460               	.LBB167:
 461               	.LBB168:
 462               	.LBB169:
 463               	.LBB170:
 430:../../os/common/ports/AVR/chcore.h **** }
 464               		.loc 2 430 0
 465               	/* #APP */
 466               	 ;  430 "../../os/common/ports/AVR/chcore.h" 1
 467 0000 F894      		cli
 468               	 ;  0 "" 2
 469               	/* #NOAPP */
 470               	.LBE170:
 471               	.LBE169:
 472               	.LBE168:
 473               	.LBE167:
 259:../../os/hal/src/hal_pwm.c **** 
 260:../../os/hal/src/hal_pwm.c ****   osalDbgCheck(pwmp != NULL);
 261:../../os/hal/src/hal_pwm.c **** 
 262:../../os/hal/src/hal_pwm.c ****   osalSysLock();
 263:../../os/hal/src/hal_pwm.c **** 
 264:../../os/hal/src/hal_pwm.c ****   osalDbgAssert(pwmp->state == PWM_READY, "not ready");
 265:../../os/hal/src/hal_pwm.c ****   osalDbgAssert(pwmp->config->callback != NULL, "undefined periodic callback");
 266:../../os/hal/src/hal_pwm.c **** 
 267:../../os/hal/src/hal_pwm.c ****   pwmDisablePeriodicNotificationI(pwmp);
 474               		.loc 1 267 0
 475 0002 0E94 0000 		call pwm_lld_disable_periodic_notification
 476               	.LVL19:
 477               	.LBB171:
 478               	.LBB172:
 479               	.LBB173:
 480               	.LBB174:
 481               	.LBB175:
 482               		.loc 2 440 0
 483               	/* #APP */
 484               	 ;  440 "../../os/common/ports/AVR/chcore.h" 1
 485 0006 7894      		sei
 486               	 ;  0 "" 2
 487               	/* epilogue start */
 488               	/* #NOAPP */
 489               	.LBE175:
 490               	.LBE174:
 491               	.LBE173:
 492               	.LBE172:
 493               	.LBE171:
 268:../../os/hal/src/hal_pwm.c **** 
 269:../../os/hal/src/hal_pwm.c ****   osalSysUnlock();
 270:../../os/hal/src/hal_pwm.c **** }
 494               		.loc 1 270 0
 495 0008 0895      		ret
 496               		.cfi_endproc
 497               	.LFE251:
 499               		.section	.text.pwmEnableChannelNotification,"ax",@progbits
 500               	.global	pwmEnableChannelNotification
 502               	pwmEnableChannelNotification:
 503               	.LFB252:
 271:../../os/hal/src/hal_pwm.c **** 
 272:../../os/hal/src/hal_pwm.c **** /**
 273:../../os/hal/src/hal_pwm.c ****  * @brief   Enables a channel de-activation edge notification.
 274:../../os/hal/src/hal_pwm.c ****  * @pre     The PWM unit must have been activated using @p pwmStart().
 275:../../os/hal/src/hal_pwm.c ****  * @pre     The channel must have been activated using @p pwmEnableChannel().
 276:../../os/hal/src/hal_pwm.c ****  * @note    If the notification is already enabled then the call has no effect.
 277:../../os/hal/src/hal_pwm.c ****  *
 278:../../os/hal/src/hal_pwm.c ****  * @param[in] pwmp      pointer to a @p PWMDriver object
 279:../../os/hal/src/hal_pwm.c ****  * @param[in] channel   PWM channel identifier (0...channels-1)
 280:../../os/hal/src/hal_pwm.c ****  *
 281:../../os/hal/src/hal_pwm.c ****  * @api
 282:../../os/hal/src/hal_pwm.c ****  */
 283:../../os/hal/src/hal_pwm.c **** void pwmEnableChannelNotification(PWMDriver *pwmp, pwmchannel_t channel) {
 504               		.loc 1 283 0
 505               		.cfi_startproc
 506               	.LVL20:
 507               	/* prologue: function */
 508               	/* frame size = 0 */
 509               	/* stack size = 0 */
 510               	.L__stack_usage = 0
 511               	.LBB176:
 512               	.LBB177:
 513               	.LBB178:
 514               	.LBB179:
 430:../../os/common/ports/AVR/chcore.h **** }
 515               		.loc 2 430 0
 516               	/* #APP */
 517               	 ;  430 "../../os/common/ports/AVR/chcore.h" 1
 518 0000 F894      		cli
 519               	 ;  0 "" 2
 520               	/* #NOAPP */
 521               	.LBE179:
 522               	.LBE178:
 523               	.LBE177:
 524               	.LBE176:
 284:../../os/hal/src/hal_pwm.c **** 
 285:../../os/hal/src/hal_pwm.c ****   osalDbgCheck((pwmp != NULL) && (channel < pwmp->channels));
 286:../../os/hal/src/hal_pwm.c **** 
 287:../../os/hal/src/hal_pwm.c ****   osalSysLock();
 288:../../os/hal/src/hal_pwm.c **** 
 289:../../os/hal/src/hal_pwm.c ****   osalDbgAssert(pwmp->state == PWM_READY, "not ready");
 290:../../os/hal/src/hal_pwm.c ****   osalDbgAssert((pwmp->enabled & ((pwmchnmsk_t)1U << (pwmchnmsk_t)channel)) != 0U,
 291:../../os/hal/src/hal_pwm.c ****                 "channel not enabled");
 292:../../os/hal/src/hal_pwm.c ****   osalDbgAssert(pwmp->config->channels[channel].callback != NULL,
 293:../../os/hal/src/hal_pwm.c ****                 "undefined channel callback");
 294:../../os/hal/src/hal_pwm.c **** 
 295:../../os/hal/src/hal_pwm.c ****   pwmEnableChannelNotificationI(pwmp, channel);
 525               		.loc 1 295 0
 526 0002 0E94 0000 		call pwm_lld_enable_channel_notification
 527               	.LVL21:
 528               	.LBB180:
 529               	.LBB181:
 530               	.LBB182:
 531               	.LBB183:
 532               	.LBB184:
 533               		.loc 2 440 0
 534               	/* #APP */
 535               	 ;  440 "../../os/common/ports/AVR/chcore.h" 1
 536 0006 7894      		sei
 537               	 ;  0 "" 2
 538               	/* epilogue start */
 539               	/* #NOAPP */
 540               	.LBE184:
 541               	.LBE183:
 542               	.LBE182:
 543               	.LBE181:
 544               	.LBE180:
 296:../../os/hal/src/hal_pwm.c **** 
 297:../../os/hal/src/hal_pwm.c ****   osalSysUnlock();
 298:../../os/hal/src/hal_pwm.c **** }
 545               		.loc 1 298 0
 546 0008 0895      		ret
 547               		.cfi_endproc
 548               	.LFE252:
 550               		.section	.text.pwmDisableChannelNotification,"ax",@progbits
 551               	.global	pwmDisableChannelNotification
 553               	pwmDisableChannelNotification:
 554               	.LFB253:
 299:../../os/hal/src/hal_pwm.c **** 
 300:../../os/hal/src/hal_pwm.c **** /**
 301:../../os/hal/src/hal_pwm.c ****  * @brief   Disables a channel de-activation edge notification.
 302:../../os/hal/src/hal_pwm.c ****  * @pre     The PWM unit must have been activated using @p pwmStart().
 303:../../os/hal/src/hal_pwm.c ****  * @pre     The channel must have been activated using @p pwmEnableChannel().
 304:../../os/hal/src/hal_pwm.c ****  * @note    If the notification is already disabled then the call has no effect.
 305:../../os/hal/src/hal_pwm.c ****  *
 306:../../os/hal/src/hal_pwm.c ****  * @param[in] pwmp      pointer to a @p PWMDriver object
 307:../../os/hal/src/hal_pwm.c ****  * @param[in] channel   PWM channel identifier (0...channels-1)
 308:../../os/hal/src/hal_pwm.c ****  *
 309:../../os/hal/src/hal_pwm.c ****  * @api
 310:../../os/hal/src/hal_pwm.c ****  */
 311:../../os/hal/src/hal_pwm.c **** void pwmDisableChannelNotification(PWMDriver *pwmp, pwmchannel_t channel) {
 555               		.loc 1 311 0
 556               		.cfi_startproc
 557               	.LVL22:
 558               	/* prologue: function */
 559               	/* frame size = 0 */
 560               	/* stack size = 0 */
 561               	.L__stack_usage = 0
 562               	.LBB185:
 563               	.LBB186:
 564               	.LBB187:
 565               	.LBB188:
 430:../../os/common/ports/AVR/chcore.h **** }
 566               		.loc 2 430 0
 567               	/* #APP */
 568               	 ;  430 "../../os/common/ports/AVR/chcore.h" 1
 569 0000 F894      		cli
 570               	 ;  0 "" 2
 571               	/* #NOAPP */
 572               	.LBE188:
 573               	.LBE187:
 574               	.LBE186:
 575               	.LBE185:
 312:../../os/hal/src/hal_pwm.c **** 
 313:../../os/hal/src/hal_pwm.c ****   osalDbgCheck((pwmp != NULL) && (channel < pwmp->channels));
 314:../../os/hal/src/hal_pwm.c **** 
 315:../../os/hal/src/hal_pwm.c ****   osalSysLock();
 316:../../os/hal/src/hal_pwm.c **** 
 317:../../os/hal/src/hal_pwm.c ****   osalDbgAssert(pwmp->state == PWM_READY, "not ready");
 318:../../os/hal/src/hal_pwm.c ****   osalDbgAssert((pwmp->enabled & ((pwmchnmsk_t)1U << (pwmchnmsk_t)channel)) != 0U,
 319:../../os/hal/src/hal_pwm.c ****                 "channel not enabled");
 320:../../os/hal/src/hal_pwm.c ****   osalDbgAssert(pwmp->config->channels[channel].callback != NULL,
 321:../../os/hal/src/hal_pwm.c ****                 "undefined channel callback");
 322:../../os/hal/src/hal_pwm.c **** 
 323:../../os/hal/src/hal_pwm.c ****   pwmDisableChannelNotificationI(pwmp, channel);
 576               		.loc 1 323 0
 577 0002 0E94 0000 		call pwm_lld_disable_channel_notification
 578               	.LVL23:
 579               	.LBB189:
 580               	.LBB190:
 581               	.LBB191:
 582               	.LBB192:
 583               	.LBB193:
 584               		.loc 2 440 0
 585               	/* #APP */
 586               	 ;  440 "../../os/common/ports/AVR/chcore.h" 1
 587 0006 7894      		sei
 588               	 ;  0 "" 2
 589               	/* epilogue start */
 590               	/* #NOAPP */
 591               	.LBE193:
 592               	.LBE192:
 593               	.LBE191:
 594               	.LBE190:
 595               	.LBE189:
 324:../../os/hal/src/hal_pwm.c **** 
 325:../../os/hal/src/hal_pwm.c ****   osalSysUnlock();
 326:../../os/hal/src/hal_pwm.c **** }
 596               		.loc 1 326 0
 597 0008 0895      		ret
 598               		.cfi_endproc
 599               	.LFE253:
 601               		.text
 602               	.Letext0:
 603               		.file 3 "/usr/lib/gcc/avr/7.3.0/include/stddef.h"
 604               		.file 4 "/usr/lib/avr/include/stdint.h"
 605               		.file 5 "../../os/common/ports/AVR/compilers/GCC/chtypes.h"
 606               		.file 6 "../../os/rt/include/chearly.h"
 607               		.file 7 "../../os/rt/include/chobjects.h"
 608               		.file 8 "../../os/rt/include/chrfcu.h"
 609               		.file 9 "../../os/rt/include/chdebug.h"
 610               		.file 10 "../../os/rt/include/chtime.h"
 611               		.file 11 "../../os/rt/include/chlists.h"
 612               		.file 12 "../../os/rt/include/chsem.h"
 613               		.file 13 "../../os/rt/include/chmtx.h"
 614               		.file 14 "../../os/rt/include/chsys.h"
 615               		.file 15 "../../os/rt/include/chregistry.h"
 616               		.file 16 "../../os/rt/include/chevents.h"
 617               		.file 17 "../../os/oslib/include/chmemcore.h"
 618               		.file 18 "../../os/hal/include/hal_queues.h"
 619               		.file 19 "../../os/hal/ports/AVR/MEGA/LLD/GPIOv1/hal_pal_lld.h"
 620               		.file 20 "../../os/hal/include/hal_pwm.h"
 621               		.file 21 "../../os/hal/ports/AVR/MEGA/LLD/TIMv1/hal_pwm_lld.h"
 622               		.file 22 "../../os/hal/include/hal_serial.h"
 623               		.file 23 "../../os/hal/ports/AVR/MEGA/LLD/USARTv1/hal_serial_lld.h"
 624               		.file 24 "../../os/hal/osal/rt-nil/osal.h"
DEFINED SYMBOLS
                            *ABS*:0000000000000000 hal_pwm.c
     /tmp/ccohJFz5.s:2      *ABS*:000000000000003e __SP_H__
     /tmp/ccohJFz5.s:3      *ABS*:000000000000003d __SP_L__
     /tmp/ccohJFz5.s:4      *ABS*:000000000000003f __SREG__
     /tmp/ccohJFz5.s:5      *ABS*:0000000000000000 __tmp_reg__
     /tmp/ccohJFz5.s:6      *ABS*:0000000000000001 __zero_reg__
     /tmp/ccohJFz5.s:13     .text.pwmInit:0000000000000000 pwmInit
     /tmp/ccohJFz5.s:31     .text.pwmObjectInit:0000000000000000 pwmObjectInit
     /tmp/ccohJFz5.s:61     .text.pwmStart:0000000000000000 pwmStart
     /tmp/ccohJFz5.s:143    .text.pwmStop:0000000000000000 pwmStop
     /tmp/ccohJFz5.s:214    .text.pwmChangePeriod:0000000000000000 pwmChangePeriod
     /tmp/ccohJFz5.s:268    .text.pwmEnableChannel:0000000000000000 pwmEnableChannel
     /tmp/ccohJFz5.s:335    .text.pwmDisableChannel:0000000000000000 pwmDisableChannel
     /tmp/ccohJFz5.s:400    .text.pwmEnablePeriodicNotification:0000000000000000 pwmEnablePeriodicNotification
     /tmp/ccohJFz5.s:451    .text.pwmDisablePeriodicNotification:0000000000000000 pwmDisablePeriodicNotification
     /tmp/ccohJFz5.s:502    .text.pwmEnableChannelNotification:0000000000000000 pwmEnableChannelNotification
     /tmp/ccohJFz5.s:553    .text.pwmDisableChannelNotification:0000000000000000 pwmDisableChannelNotification

UNDEFINED SYMBOLS
pwm_lld_init
pwm_lld_start
pwm_lld_stop
pwm_lld_change_period
pwm_lld_enable_channel
pwm_lld_disable_channel
pwm_lld_enable_periodic_notification
pwm_lld_disable_periodic_notification
pwm_lld_enable_channel_notification
pwm_lld_disable_channel_notification
