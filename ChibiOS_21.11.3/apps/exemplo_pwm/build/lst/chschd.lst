   1               		.file	"chschd.c"
   2               	__SP_H__ = 0x3e
   3               	__SP_L__ = 0x3d
   4               	__SREG__ = 0x3f
   5               	__tmp_reg__ = 0
   6               	__zero_reg__ = 1
   7               		.text
   8               	.Ltext0:
   9               		.cfi_sections	.debug_frame
  10               		.section	.text.__sch_wakeup,"ax",@progbits
  12               	__sch_wakeup:
  13               	.LFB199:
  14               		.file 1 "../../os/rt/src/chschd.c"
   1:../../os/rt/src/chschd.c **** /*
   2:../../os/rt/src/chschd.c ****     ChibiOS - Copyright (C) 2006,2007,2008,2009,2010,2011,2012,2013,2014,
   3:../../os/rt/src/chschd.c ****               2015,2016,2017,2018,2019,2020,2021 Giovanni Di Sirio.
   4:../../os/rt/src/chschd.c **** 
   5:../../os/rt/src/chschd.c ****     This file is part of ChibiOS.
   6:../../os/rt/src/chschd.c **** 
   7:../../os/rt/src/chschd.c ****     ChibiOS is free software; you can redistribute it and/or modify
   8:../../os/rt/src/chschd.c ****     it under the terms of the GNU General Public License as published by
   9:../../os/rt/src/chschd.c ****     the Free Software Foundation version 3 of the License.
  10:../../os/rt/src/chschd.c **** 
  11:../../os/rt/src/chschd.c ****     ChibiOS is distributed in the hope that it will be useful,
  12:../../os/rt/src/chschd.c ****     but WITHOUT ANY WARRANTY; without even the implied warranty of
  13:../../os/rt/src/chschd.c ****     MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
  14:../../os/rt/src/chschd.c ****     GNU General Public License for more details.
  15:../../os/rt/src/chschd.c **** 
  16:../../os/rt/src/chschd.c ****     You should have received a copy of the GNU General Public License
  17:../../os/rt/src/chschd.c ****     along with this program.  If not, see <http://www.gnu.org/licenses/>.
  18:../../os/rt/src/chschd.c **** */
  19:../../os/rt/src/chschd.c **** 
  20:../../os/rt/src/chschd.c **** /**
  21:../../os/rt/src/chschd.c ****  * @file    rt/src/chschd.c
  22:../../os/rt/src/chschd.c ****  * @brief   Scheduler code.
  23:../../os/rt/src/chschd.c ****  *
  24:../../os/rt/src/chschd.c ****  * @addtogroup scheduler
  25:../../os/rt/src/chschd.c ****  * @details This module provides the default portable scheduler code.
  26:../../os/rt/src/chschd.c ****  * @{
  27:../../os/rt/src/chschd.c ****  */
  28:../../os/rt/src/chschd.c **** 
  29:../../os/rt/src/chschd.c **** #include "ch.h"
  30:../../os/rt/src/chschd.c **** 
  31:../../os/rt/src/chschd.c **** /*===========================================================================*/
  32:../../os/rt/src/chschd.c **** /* Module local definitions.                                                 */
  33:../../os/rt/src/chschd.c **** /*===========================================================================*/
  34:../../os/rt/src/chschd.c **** 
  35:../../os/rt/src/chschd.c **** /*===========================================================================*/
  36:../../os/rt/src/chschd.c **** /* Module exported variables.                                                */
  37:../../os/rt/src/chschd.c **** /*===========================================================================*/
  38:../../os/rt/src/chschd.c **** 
  39:../../os/rt/src/chschd.c **** /*===========================================================================*/
  40:../../os/rt/src/chschd.c **** /* Module local types.                                                       */
  41:../../os/rt/src/chschd.c **** /*===========================================================================*/
  42:../../os/rt/src/chschd.c **** 
  43:../../os/rt/src/chschd.c **** /*===========================================================================*/
  44:../../os/rt/src/chschd.c **** /* Module local variables.                                                   */
  45:../../os/rt/src/chschd.c **** /*===========================================================================*/
  46:../../os/rt/src/chschd.c **** 
  47:../../os/rt/src/chschd.c **** /*===========================================================================*/
  48:../../os/rt/src/chschd.c **** /* Module local functions.                                                   */
  49:../../os/rt/src/chschd.c **** /*===========================================================================*/
  50:../../os/rt/src/chschd.c **** 
  51:../../os/rt/src/chschd.c **** /**
  52:../../os/rt/src/chschd.c ****  * @brief   Inserts a thread in the Ready List placing it behind its peers.
  53:../../os/rt/src/chschd.c ****  * @details The thread is positioned behind all threads with higher or equal
  54:../../os/rt/src/chschd.c ****  *          priority.
  55:../../os/rt/src/chschd.c ****  * @pre     The thread must not be already inserted in any list through its
  56:../../os/rt/src/chschd.c ****  *          @p next and @p prev or list corruption would occur.
  57:../../os/rt/src/chschd.c ****  * @post    This function does not reschedule so a call to a rescheduling
  58:../../os/rt/src/chschd.c ****  *          function must be performed before unlocking the kernel. Note that
  59:../../os/rt/src/chschd.c ****  *          interrupt handlers always reschedule on exit so an explicit
  60:../../os/rt/src/chschd.c ****  *          reschedule must not be performed in ISRs.
  61:../../os/rt/src/chschd.c ****  *
  62:../../os/rt/src/chschd.c ****  * @param[in] tp        the thread to be made ready
  63:../../os/rt/src/chschd.c ****  * @return              The thread pointer.
  64:../../os/rt/src/chschd.c ****  *
  65:../../os/rt/src/chschd.c ****  * @notapi
  66:../../os/rt/src/chschd.c ****  */
  67:../../os/rt/src/chschd.c **** static thread_t *__sch_ready_behind(thread_t *tp) {
  68:../../os/rt/src/chschd.c **** 
  69:../../os/rt/src/chschd.c ****   chDbgAssert((tp->state != CH_STATE_READY) &&
  70:../../os/rt/src/chschd.c ****               (tp->state != CH_STATE_FINAL),
  71:../../os/rt/src/chschd.c ****               "invalid state");
  72:../../os/rt/src/chschd.c **** 
  73:../../os/rt/src/chschd.c ****   /* Tracing the event.*/
  74:../../os/rt/src/chschd.c ****   __trace_ready(tp, tp->u.rdymsg);
  75:../../os/rt/src/chschd.c **** 
  76:../../os/rt/src/chschd.c ****   /* The thread is marked ready.*/
  77:../../os/rt/src/chschd.c ****   tp->state = CH_STATE_READY;
  78:../../os/rt/src/chschd.c **** 
  79:../../os/rt/src/chschd.c ****   /* Insertion in the priority queue.*/
  80:../../os/rt/src/chschd.c ****   return threadref(ch_pqueue_insert_behind(&tp->owner->rlist.pqueue,
  81:../../os/rt/src/chschd.c ****                                            &tp->hdr.pqueue));
  82:../../os/rt/src/chschd.c **** }
  83:../../os/rt/src/chschd.c **** 
  84:../../os/rt/src/chschd.c **** /**
  85:../../os/rt/src/chschd.c ****  * @brief   Inserts a thread in the Ready List placing it ahead its peers.
  86:../../os/rt/src/chschd.c ****  * @details The thread is positioned ahead all threads with higher or equal
  87:../../os/rt/src/chschd.c ****  *          priority.
  88:../../os/rt/src/chschd.c ****  * @pre     The thread must not be already inserted in any list through its
  89:../../os/rt/src/chschd.c ****  *          @p next and @p prev or list corruption would occur.
  90:../../os/rt/src/chschd.c ****  * @post    This function does not reschedule so a call to a rescheduling
  91:../../os/rt/src/chschd.c ****  *          function must be performed before unlocking the kernel. Note that
  92:../../os/rt/src/chschd.c ****  *          interrupt handlers always reschedule on exit so an explicit
  93:../../os/rt/src/chschd.c ****  *          reschedule must not be performed in ISRs.
  94:../../os/rt/src/chschd.c ****  *
  95:../../os/rt/src/chschd.c ****  * @param[in] tp        the thread to be made ready
  96:../../os/rt/src/chschd.c ****  * @return              The thread pointer.
  97:../../os/rt/src/chschd.c ****  *
  98:../../os/rt/src/chschd.c ****  * @notapi
  99:../../os/rt/src/chschd.c ****  */
 100:../../os/rt/src/chschd.c **** static thread_t *__sch_ready_ahead(thread_t *tp) {
 101:../../os/rt/src/chschd.c **** 
 102:../../os/rt/src/chschd.c ****   chDbgAssert((tp->state != CH_STATE_READY) &&
 103:../../os/rt/src/chschd.c ****               (tp->state != CH_STATE_FINAL),
 104:../../os/rt/src/chschd.c ****               "invalid state");
 105:../../os/rt/src/chschd.c **** 
 106:../../os/rt/src/chschd.c ****   /* Tracing the event.*/
 107:../../os/rt/src/chschd.c ****   __trace_ready(tp, tp->u.rdymsg);
 108:../../os/rt/src/chschd.c **** 
 109:../../os/rt/src/chschd.c ****   /* The thread is marked ready.*/
 110:../../os/rt/src/chschd.c ****   tp->state = CH_STATE_READY;
 111:../../os/rt/src/chschd.c **** 
 112:../../os/rt/src/chschd.c ****   /* Insertion in the priority queue.*/
 113:../../os/rt/src/chschd.c ****   return threadref(ch_pqueue_insert_ahead(&tp->owner->rlist.pqueue,
 114:../../os/rt/src/chschd.c ****                                           &tp->hdr.pqueue));
 115:../../os/rt/src/chschd.c **** }
 116:../../os/rt/src/chschd.c **** 
 117:../../os/rt/src/chschd.c **** /**
 118:../../os/rt/src/chschd.c ****  * @brief   Switches to the first thread on the runnable queue.
 119:../../os/rt/src/chschd.c ****  * @details The current thread is positioned in the ready list behind all
 120:../../os/rt/src/chschd.c ****  *          threads having the same priority. The thread regains its time
 121:../../os/rt/src/chschd.c ****  *          quantum.
 122:../../os/rt/src/chschd.c ****  * @note    Not a user function, it is meant to be invoked by the scheduler
 123:../../os/rt/src/chschd.c ****  *          itself.
 124:../../os/rt/src/chschd.c ****  *
 125:../../os/rt/src/chschd.c ****  * @notapi
 126:../../os/rt/src/chschd.c ****  */
 127:../../os/rt/src/chschd.c **** static void __sch_reschedule_behind(void) {
 128:../../os/rt/src/chschd.c ****   os_instance_t *oip = currcore;
 129:../../os/rt/src/chschd.c ****   thread_t *otp = __instance_get_currthread(oip);
 130:../../os/rt/src/chschd.c ****   thread_t *ntp;
 131:../../os/rt/src/chschd.c **** 
 132:../../os/rt/src/chschd.c ****   /* Picks the first thread from the ready queue and makes it current.*/
 133:../../os/rt/src/chschd.c ****   ntp = threadref(ch_pqueue_remove_highest(&oip->rlist.pqueue));
 134:../../os/rt/src/chschd.c ****   ntp->state = CH_STATE_CURRENT;
 135:../../os/rt/src/chschd.c ****   __instance_set_currthread(oip, ntp);
 136:../../os/rt/src/chschd.c **** 
 137:../../os/rt/src/chschd.c ****   /* Handling idle-leave hook.*/
 138:../../os/rt/src/chschd.c ****   if (otp->hdr.pqueue.prio == IDLEPRIO) {
 139:../../os/rt/src/chschd.c ****     CH_CFG_IDLE_LEAVE_HOOK();
 140:../../os/rt/src/chschd.c ****   }
 141:../../os/rt/src/chschd.c **** 
 142:../../os/rt/src/chschd.c **** #if CH_CFG_TIME_QUANTUM > 0
 143:../../os/rt/src/chschd.c ****   /* It went behind peers so it gets a new time quantum.*/
 144:../../os/rt/src/chschd.c ****   otp->ticks = (tslices_t)CH_CFG_TIME_QUANTUM;
 145:../../os/rt/src/chschd.c **** #endif
 146:../../os/rt/src/chschd.c **** 
 147:../../os/rt/src/chschd.c ****   /* Placing in ready list behind peers.*/
 148:../../os/rt/src/chschd.c ****   otp = __sch_ready_behind(otp);
 149:../../os/rt/src/chschd.c **** 
 150:../../os/rt/src/chschd.c ****   /* Swap operation as tail call.*/
 151:../../os/rt/src/chschd.c ****   chSysSwitch(ntp, otp);
 152:../../os/rt/src/chschd.c **** }
 153:../../os/rt/src/chschd.c **** 
 154:../../os/rt/src/chschd.c **** /**
 155:../../os/rt/src/chschd.c ****  * @brief   Switches to the first thread on the runnable queue.
 156:../../os/rt/src/chschd.c ****  * @details The current thread is positioned in the ready list ahead of all
 157:../../os/rt/src/chschd.c ****  *          threads having the same priority.
 158:../../os/rt/src/chschd.c ****  * @note    Not a user function, it is meant to be invoked by the scheduler
 159:../../os/rt/src/chschd.c ****  *          itself.
 160:../../os/rt/src/chschd.c ****  *
 161:../../os/rt/src/chschd.c ****  * @notapi
 162:../../os/rt/src/chschd.c ****  */
 163:../../os/rt/src/chschd.c **** static void __sch_reschedule_ahead(void) {
 164:../../os/rt/src/chschd.c ****   os_instance_t *oip = currcore;
 165:../../os/rt/src/chschd.c ****   thread_t *otp = __instance_get_currthread(oip);
 166:../../os/rt/src/chschd.c ****   thread_t *ntp;
 167:../../os/rt/src/chschd.c **** 
 168:../../os/rt/src/chschd.c ****   /* Picks the first thread from the ready queue and makes it current.*/
 169:../../os/rt/src/chschd.c ****   ntp = threadref(ch_pqueue_remove_highest(&oip->rlist.pqueue));
 170:../../os/rt/src/chschd.c ****   ntp->state = CH_STATE_CURRENT;
 171:../../os/rt/src/chschd.c ****   __instance_set_currthread(oip, ntp);
 172:../../os/rt/src/chschd.c **** 
 173:../../os/rt/src/chschd.c ****   /* Handling idle-leave hook.*/
 174:../../os/rt/src/chschd.c ****   if (otp->hdr.pqueue.prio == IDLEPRIO) {
 175:../../os/rt/src/chschd.c ****     CH_CFG_IDLE_LEAVE_HOOK();
 176:../../os/rt/src/chschd.c ****   }
 177:../../os/rt/src/chschd.c **** 
 178:../../os/rt/src/chschd.c ****   /* Placing in ready list ahead of peers.*/
 179:../../os/rt/src/chschd.c ****   otp = __sch_ready_ahead(otp);
 180:../../os/rt/src/chschd.c **** 
 181:../../os/rt/src/chschd.c ****   /* Swap operation as tail call.*/
 182:../../os/rt/src/chschd.c ****   chSysSwitch(ntp, otp);
 183:../../os/rt/src/chschd.c **** }
 184:../../os/rt/src/chschd.c **** 
 185:../../os/rt/src/chschd.c **** /*
 186:../../os/rt/src/chschd.c ****  * Timeout wakeup callback.
 187:../../os/rt/src/chschd.c ****  */
 188:../../os/rt/src/chschd.c **** static void __sch_wakeup(virtual_timer_t *vtp, void *p) {
  15               		.loc 1 188 0
  16               		.cfi_startproc
  17               	.LVL0:
  18 0000 CF93      		push r28
  19               	.LCFI0:
  20               		.cfi_def_cfa_offset 3
  21               		.cfi_offset 28, -2
  22 0002 DF93      		push r29
  23               	.LCFI1:
  24               		.cfi_def_cfa_offset 4
  25               		.cfi_offset 29, -3
  26               	/* prologue: function */
  27               	/* frame size = 0 */
  28               	/* stack size = 2 */
  29               	.L__stack_usage = 2
  30 0004 DB01      		movw r26,r22
  31               	.LVL1:
 189:../../os/rt/src/chschd.c ****   thread_t *tp = threadref(p);
 190:../../os/rt/src/chschd.c **** 
 191:../../os/rt/src/chschd.c ****   (void)vtp;
 192:../../os/rt/src/chschd.c **** 
 193:../../os/rt/src/chschd.c ****   chSysLockFromISR();
 194:../../os/rt/src/chschd.c ****   switch (tp->state) {
  32               		.loc 1 194 0
  33 0006 1F96      		adiw r26,15
  34 0008 8C91      		ld r24,X
  35 000a 1F97      		sbiw r26,15
  36               	.LVL2:
  37 000c 8430      		cpi r24,lo8(4)
  38 000e 01F0      		breq .L3
  39 0010 00F4      		brsh .L4
  40 0012 8823      		tst r24
  41 0014 01F0      		breq .L1
  42 0016 8330      		cpi r24,lo8(3)
  43 0018 01F4      		brne .L2
 195:../../os/rt/src/chschd.c ****   case CH_STATE_READY:
 196:../../os/rt/src/chschd.c ****     /* Handling the special case where the thread has been made ready by
 197:../../os/rt/src/chschd.c ****        another thread with higher priority.*/
 198:../../os/rt/src/chschd.c ****     chSysUnlockFromISR();
 199:../../os/rt/src/chschd.c ****     return;
 200:../../os/rt/src/chschd.c ****   case CH_STATE_SUSPENDED:
 201:../../os/rt/src/chschd.c ****     *tp->u.wttrp = NULL;
  44               		.loc 1 201 0
  45 001a 5296      		adiw r26,18
  46 001c ED91      		ld r30,X+
  47 001e FC91      		ld r31,X
  48 0020 5397      		sbiw r26,18+1
  49 0022 1182      		std Z+1,__zero_reg__
  50 0024 1082      		st Z,__zero_reg__
  51               	.L2:
 202:../../os/rt/src/chschd.c ****     break;
 203:../../os/rt/src/chschd.c **** #if CH_CFG_USE_SEMAPHORES == TRUE
 204:../../os/rt/src/chschd.c ****   case CH_STATE_WTSEM:
 205:../../os/rt/src/chschd.c ****     chSemFastSignalI(tp->u.wtsemp);
 206:../../os/rt/src/chschd.c **** #endif
 207:../../os/rt/src/chschd.c ****     /* Falls through.*/
 208:../../os/rt/src/chschd.c ****   case CH_STATE_QUEUED:
 209:../../os/rt/src/chschd.c ****     /* Falls through.*/
 210:../../os/rt/src/chschd.c **** #if CH_CFG_USE_MESSAGES == TRUE
 211:../../os/rt/src/chschd.c ****   case CH_STATE_SNDMSGQ:
 212:../../os/rt/src/chschd.c ****     /* Falls through.*/
 213:../../os/rt/src/chschd.c **** #endif
 214:../../os/rt/src/chschd.c **** #if (CH_CFG_USE_CONDVARS == TRUE) && (CH_CFG_USE_CONDVARS_TIMEOUT == TRUE)
 215:../../os/rt/src/chschd.c ****   case CH_STATE_WTCOND:
 216:../../os/rt/src/chschd.c **** #endif
 217:../../os/rt/src/chschd.c ****     /* States requiring dequeuing.*/
 218:../../os/rt/src/chschd.c ****     (void) ch_queue_dequeue(&tp->hdr.queue);
 219:../../os/rt/src/chschd.c ****     break;
 220:../../os/rt/src/chschd.c ****   default:
 221:../../os/rt/src/chschd.c ****     /* Any other state, nothing to do.*/
 222:../../os/rt/src/chschd.c ****     break;
 223:../../os/rt/src/chschd.c ****   }
 224:../../os/rt/src/chschd.c **** 
 225:../../os/rt/src/chschd.c ****   /* Standard message for timeout conditions.*/
 226:../../os/rt/src/chschd.c ****   tp->u.rdymsg = MSG_TIMEOUT;
  52               		.loc 1 226 0
  53 0026 8FEF      		ldi r24,lo8(-1)
  54 0028 9FEF      		ldi r25,lo8(-1)
  55 002a 5396      		adiw r26,18+1
  56 002c 9C93      		st X,r25
  57 002e 8E93      		st -X,r24
  58 0030 5297      		sbiw r26,18
  59               	.LVL3:
  60               	.LBB65:
  61               	.LBB66:
  77:../../os/rt/src/chschd.c **** 
  62               		.loc 1 77 0
  63 0032 1F96      		adiw r26,15
  64 0034 1C92      		st X,__zero_reg__
  65 0036 1F97      		sbiw r26,15
  80:../../os/rt/src/chschd.c ****                                            &tp->hdr.pqueue));
  66               		.loc 1 80 0
  67 0038 1B96      		adiw r26,11
  68 003a ED91      		ld r30,X+
  69 003c FC91      		ld r31,X
  70 003e 1C97      		sbiw r26,11+1
  71               	.LVL4:
  72               	.LBB67:
  73               	.LBB68:
  74               		.file 2 "../../os/rt/include/chlists.h"
   1:../../os/rt/include/chlists.h **** /*
   2:../../os/rt/include/chlists.h ****     ChibiOS - Copyright (C) 2006,2007,2008,2009,2010,2011,2012,2013,2014,
   3:../../os/rt/include/chlists.h ****               2015,2016,2017,2018,2019,2020,2021 Giovanni Di Sirio.
   4:../../os/rt/include/chlists.h **** 
   5:../../os/rt/include/chlists.h ****     This file is part of ChibiOS.
   6:../../os/rt/include/chlists.h **** 
   7:../../os/rt/include/chlists.h ****     ChibiOS is free software; you can redistribute it and/or modify
   8:../../os/rt/include/chlists.h ****     it under the terms of the GNU General Public License as published by
   9:../../os/rt/include/chlists.h ****     the Free Software Foundation version 3 of the License.
  10:../../os/rt/include/chlists.h **** 
  11:../../os/rt/include/chlists.h ****     ChibiOS is distributed in the hope that it will be useful,
  12:../../os/rt/include/chlists.h ****     but WITHOUT ANY WARRANTY; without even the implied warranty of
  13:../../os/rt/include/chlists.h ****     MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
  14:../../os/rt/include/chlists.h ****     GNU General Public License for more details.
  15:../../os/rt/include/chlists.h **** 
  16:../../os/rt/include/chlists.h ****     You should have received a copy of the GNU General Public License
  17:../../os/rt/include/chlists.h ****     along with this program.  If not, see <http://www.gnu.org/licenses/>.
  18:../../os/rt/include/chlists.h **** */
  19:../../os/rt/include/chlists.h **** 
  20:../../os/rt/include/chlists.h **** /**
  21:../../os/rt/include/chlists.h ****  * @file    chlists.h
  22:../../os/rt/include/chlists.h ****  * @brief   Lists and Queues header.
  23:../../os/rt/include/chlists.h ****  *
  24:../../os/rt/include/chlists.h ****  * @addtogroup os_lists
  25:../../os/rt/include/chlists.h ****  * @{
  26:../../os/rt/include/chlists.h ****  */
  27:../../os/rt/include/chlists.h **** 
  28:../../os/rt/include/chlists.h **** #ifndef CHLISTS_H
  29:../../os/rt/include/chlists.h **** #define CHLISTS_H
  30:../../os/rt/include/chlists.h **** 
  31:../../os/rt/include/chlists.h **** /*===========================================================================*/
  32:../../os/rt/include/chlists.h **** /* Module constants.                                                         */
  33:../../os/rt/include/chlists.h **** /*===========================================================================*/
  34:../../os/rt/include/chlists.h **** 
  35:../../os/rt/include/chlists.h **** /*===========================================================================*/
  36:../../os/rt/include/chlists.h **** /* Module pre-compile time settings.                                         */
  37:../../os/rt/include/chlists.h **** /*===========================================================================*/
  38:../../os/rt/include/chlists.h **** 
  39:../../os/rt/include/chlists.h **** /*===========================================================================*/
  40:../../os/rt/include/chlists.h **** /* Derived constants and error checks.                                       */
  41:../../os/rt/include/chlists.h **** /*===========================================================================*/
  42:../../os/rt/include/chlists.h **** 
  43:../../os/rt/include/chlists.h **** /*===========================================================================*/
  44:../../os/rt/include/chlists.h **** /* Module data structures and types.                                         */
  45:../../os/rt/include/chlists.h **** /*===========================================================================*/
  46:../../os/rt/include/chlists.h **** 
  47:../../os/rt/include/chlists.h **** /**
  48:../../os/rt/include/chlists.h ****  * @brief   Type of a generic single link list header and element.
  49:../../os/rt/include/chlists.h ****  */
  50:../../os/rt/include/chlists.h **** typedef struct ch_list ch_list_t;
  51:../../os/rt/include/chlists.h **** 
  52:../../os/rt/include/chlists.h **** /**
  53:../../os/rt/include/chlists.h ****  * @brief   Structure representing a generic single link list header
  54:../../os/rt/include/chlists.h ****  *          and element.
  55:../../os/rt/include/chlists.h ****  */
  56:../../os/rt/include/chlists.h **** struct ch_list {
  57:../../os/rt/include/chlists.h ****   ch_list_t             *next;      /**< @brief Next in the list/queue.     */
  58:../../os/rt/include/chlists.h **** };
  59:../../os/rt/include/chlists.h **** 
  60:../../os/rt/include/chlists.h **** /**
  61:../../os/rt/include/chlists.h ****  * @brief   Type of a generic bidirectional linked list header and element.
  62:../../os/rt/include/chlists.h ****  */
  63:../../os/rt/include/chlists.h **** typedef struct ch_queue ch_queue_t;
  64:../../os/rt/include/chlists.h **** 
  65:../../os/rt/include/chlists.h **** /**
  66:../../os/rt/include/chlists.h ****  * @brief   Structure representing a generic bidirectional linked list header
  67:../../os/rt/include/chlists.h ****  *          and element.
  68:../../os/rt/include/chlists.h ****  */
  69:../../os/rt/include/chlists.h **** struct ch_queue {
  70:../../os/rt/include/chlists.h ****   ch_queue_t            *next;      /**< @brief Next in the list/queue.     */
  71:../../os/rt/include/chlists.h ****   ch_queue_t            *prev;      /**< @brief Previous in the queue.      */
  72:../../os/rt/include/chlists.h **** };
  73:../../os/rt/include/chlists.h **** 
  74:../../os/rt/include/chlists.h **** /**
  75:../../os/rt/include/chlists.h ****  * @brief   Type of a generic priority-ordered bidirectional linked list
  76:../../os/rt/include/chlists.h ****  *          header and element.
  77:../../os/rt/include/chlists.h ****  */
  78:../../os/rt/include/chlists.h **** typedef struct ch_priority_queue ch_priority_queue_t;
  79:../../os/rt/include/chlists.h **** 
  80:../../os/rt/include/chlists.h **** /**
  81:../../os/rt/include/chlists.h ****  * @brief   Structure representing a generic priority-ordered bidirectional
  82:../../os/rt/include/chlists.h ****  *          linked list header and element.
  83:../../os/rt/include/chlists.h ****  * @note    Link fields are void pointers in order to avoid aliasing issues.
  84:../../os/rt/include/chlists.h ****  */
  85:../../os/rt/include/chlists.h **** struct ch_priority_queue {
  86:../../os/rt/include/chlists.h ****   ch_priority_queue_t   *next;      /**< @brief Next in the queue.          */
  87:../../os/rt/include/chlists.h ****   ch_priority_queue_t   *prev;      /**< @brief Previous in the queue.      */
  88:../../os/rt/include/chlists.h ****   tprio_t               prio;       /**< @brief Priority of this element.   */
  89:../../os/rt/include/chlists.h **** };
  90:../../os/rt/include/chlists.h **** 
  91:../../os/rt/include/chlists.h **** /**
  92:../../os/rt/include/chlists.h ****  * @brief   Type of a generic bidirectional linked delta list
  93:../../os/rt/include/chlists.h ****  *          header and element.
  94:../../os/rt/include/chlists.h ****  */
  95:../../os/rt/include/chlists.h **** typedef struct ch_delta_list ch_delta_list_t;
  96:../../os/rt/include/chlists.h **** 
  97:../../os/rt/include/chlists.h **** /**
  98:../../os/rt/include/chlists.h ****  * @brief   Delta list element and header structure.
  99:../../os/rt/include/chlists.h ****  */
 100:../../os/rt/include/chlists.h **** struct ch_delta_list {
 101:../../os/rt/include/chlists.h ****   ch_delta_list_t       *next;      /**< @brief Next in the delta list.     */
 102:../../os/rt/include/chlists.h ****   ch_delta_list_t       *prev;      /**< @brief Previous in the delta list. */
 103:../../os/rt/include/chlists.h ****   sysinterval_t         delta;      /**< @brief Time interval from previous.*/
 104:../../os/rt/include/chlists.h **** };
 105:../../os/rt/include/chlists.h **** 
 106:../../os/rt/include/chlists.h **** /*===========================================================================*/
 107:../../os/rt/include/chlists.h **** /* Module macros.                                                            */
 108:../../os/rt/include/chlists.h **** /*===========================================================================*/
 109:../../os/rt/include/chlists.h **** 
 110:../../os/rt/include/chlists.h **** /**
 111:../../os/rt/include/chlists.h ****  * @brief   Data part of a static queue object initializer.
 112:../../os/rt/include/chlists.h ****  * @details This macro should be used when statically initializing a
 113:../../os/rt/include/chlists.h ****  *          queue that is part of a bigger structure.
 114:../../os/rt/include/chlists.h ****  *
 115:../../os/rt/include/chlists.h ****  * @param[in] name      the name of the queue variable
 116:../../os/rt/include/chlists.h ****  */
 117:../../os/rt/include/chlists.h **** #define __CH_QUEUE_DATA(name) {(ch_queue_t *)&name, (ch_queue_t *)&name}
 118:../../os/rt/include/chlists.h **** 
 119:../../os/rt/include/chlists.h **** /**
 120:../../os/rt/include/chlists.h ****  * @brief   Static queue object initializer.
 121:../../os/rt/include/chlists.h ****  * @details Statically initialized queues require no explicit
 122:../../os/rt/include/chlists.h ****  *          initialization using @p queue_init().
 123:../../os/rt/include/chlists.h ****  *
 124:../../os/rt/include/chlists.h ****  * @param[in] name      the name of the queue variable
 125:../../os/rt/include/chlists.h ****  */
 126:../../os/rt/include/chlists.h **** #define CH_QUEUE_DECL(name)                                                 \
 127:../../os/rt/include/chlists.h ****     ch_queue_t name = __CH_QUEUE_DATA(name)
 128:../../os/rt/include/chlists.h **** 
 129:../../os/rt/include/chlists.h **** /*===========================================================================*/
 130:../../os/rt/include/chlists.h **** /* External declarations.                                                    */
 131:../../os/rt/include/chlists.h **** /*===========================================================================*/
 132:../../os/rt/include/chlists.h **** 
 133:../../os/rt/include/chlists.h **** /* Early function prototypes required by the following headers.*/
 134:../../os/rt/include/chlists.h **** #ifdef __cplusplus
 135:../../os/rt/include/chlists.h **** extern "C" {
 136:../../os/rt/include/chlists.h **** #endif
 137:../../os/rt/include/chlists.h **** 
 138:../../os/rt/include/chlists.h **** #ifdef __cplusplus
 139:../../os/rt/include/chlists.h **** }
 140:../../os/rt/include/chlists.h **** #endif
 141:../../os/rt/include/chlists.h **** 
 142:../../os/rt/include/chlists.h **** /*===========================================================================*/
 143:../../os/rt/include/chlists.h **** /* Module inline functions.                                                  */
 144:../../os/rt/include/chlists.h **** /*===========================================================================*/
 145:../../os/rt/include/chlists.h **** 
 146:../../os/rt/include/chlists.h **** /**
 147:../../os/rt/include/chlists.h ****  * @brief   List initialization.
 148:../../os/rt/include/chlists.h ****  *
 149:../../os/rt/include/chlists.h ****  * @param[out] lp       pointer to the list header
 150:../../os/rt/include/chlists.h ****  *
 151:../../os/rt/include/chlists.h ****  * @notapi
 152:../../os/rt/include/chlists.h ****  */
 153:../../os/rt/include/chlists.h **** static inline void ch_list_init(ch_list_t *lp) {
 154:../../os/rt/include/chlists.h **** 
 155:../../os/rt/include/chlists.h ****   lp->next = lp;
 156:../../os/rt/include/chlists.h **** }
 157:../../os/rt/include/chlists.h **** 
 158:../../os/rt/include/chlists.h **** /**
 159:../../os/rt/include/chlists.h ****  * @brief   Evaluates to @p true if the specified list is empty.
 160:../../os/rt/include/chlists.h ****  *
 161:../../os/rt/include/chlists.h ****  * @param[in] lp        pointer to the list header
 162:../../os/rt/include/chlists.h ****  * @return              The status of the list.
 163:../../os/rt/include/chlists.h ****  *
 164:../../os/rt/include/chlists.h ****  * @notapi
 165:../../os/rt/include/chlists.h ****  */
 166:../../os/rt/include/chlists.h **** static inline bool ch_list_isempty(ch_list_t *lp) {
 167:../../os/rt/include/chlists.h **** 
 168:../../os/rt/include/chlists.h ****   return (bool)(lp->next == lp);
 169:../../os/rt/include/chlists.h **** }
 170:../../os/rt/include/chlists.h **** 
 171:../../os/rt/include/chlists.h **** /**
 172:../../os/rt/include/chlists.h ****  * @brief   Evaluates to @p true if the specified list is not empty.
 173:../../os/rt/include/chlists.h ****  *
 174:../../os/rt/include/chlists.h ****  * @param[in] lp        pointer to the list header
 175:../../os/rt/include/chlists.h ****  * @return              The status of the list.
 176:../../os/rt/include/chlists.h ****  *
 177:../../os/rt/include/chlists.h ****  * @notapi
 178:../../os/rt/include/chlists.h ****  */
 179:../../os/rt/include/chlists.h **** static inline bool ch_list_notempty(ch_list_t *lp) {
 180:../../os/rt/include/chlists.h **** 
 181:../../os/rt/include/chlists.h ****   return (bool)(lp->next != lp);
 182:../../os/rt/include/chlists.h **** }
 183:../../os/rt/include/chlists.h **** 
 184:../../os/rt/include/chlists.h **** /**
 185:../../os/rt/include/chlists.h ****  * @brief   Pushes an element on top of a stack list.
 186:../../os/rt/include/chlists.h ****  *
 187:../../os/rt/include/chlists.h ****  * @param[in] lp    the pointer to the list header
 188:../../os/rt/include/chlists.h ****  * @param[in] p     the pointer to the element to be inserted in the list
 189:../../os/rt/include/chlists.h ****  *
 190:../../os/rt/include/chlists.h ****  * @notapi
 191:../../os/rt/include/chlists.h ****  */
 192:../../os/rt/include/chlists.h **** static inline void ch_list_link(ch_list_t *lp, ch_list_t *p) {
 193:../../os/rt/include/chlists.h **** 
 194:../../os/rt/include/chlists.h ****   p->next = lp->next;
 195:../../os/rt/include/chlists.h ****   lp->next = p;
 196:../../os/rt/include/chlists.h **** }
 197:../../os/rt/include/chlists.h **** 
 198:../../os/rt/include/chlists.h **** /**
 199:../../os/rt/include/chlists.h ****  * @brief   Pops an element from the top of a stack list and returns it.
 200:../../os/rt/include/chlists.h ****  * @pre     The list must be non-empty before calling this function.
 201:../../os/rt/include/chlists.h ****  *
 202:../../os/rt/include/chlists.h ****  * @param[in] lp        the pointer to the list header
 203:../../os/rt/include/chlists.h ****  * @return              The removed element pointer.
 204:../../os/rt/include/chlists.h ****  *
 205:../../os/rt/include/chlists.h ****  * @notapi
 206:../../os/rt/include/chlists.h ****  */
 207:../../os/rt/include/chlists.h **** static inline ch_list_t *ch_list_unlink(ch_list_t *lp) {
 208:../../os/rt/include/chlists.h **** 
 209:../../os/rt/include/chlists.h ****   ch_list_t *p = lp->next;
 210:../../os/rt/include/chlists.h ****   lp->next = p->next;
 211:../../os/rt/include/chlists.h **** 
 212:../../os/rt/include/chlists.h ****   return p;
 213:../../os/rt/include/chlists.h **** }
 214:../../os/rt/include/chlists.h **** 
 215:../../os/rt/include/chlists.h **** /**
 216:../../os/rt/include/chlists.h ****  * @brief   Queue initialization.
 217:../../os/rt/include/chlists.h ****  *
 218:../../os/rt/include/chlists.h ****  * @param[out] qp       pointer to the queue header
 219:../../os/rt/include/chlists.h ****  *
 220:../../os/rt/include/chlists.h ****  * @notapi
 221:../../os/rt/include/chlists.h ****  */
 222:../../os/rt/include/chlists.h **** static inline void ch_queue_init(ch_queue_t *qp) {
 223:../../os/rt/include/chlists.h **** 
 224:../../os/rt/include/chlists.h ****   qp->next = qp;
 225:../../os/rt/include/chlists.h ****   qp->prev = qp;
 226:../../os/rt/include/chlists.h **** }
 227:../../os/rt/include/chlists.h **** 
 228:../../os/rt/include/chlists.h **** /**
 229:../../os/rt/include/chlists.h ****  * @brief   Evaluates to @p true if the specified queue is empty.
 230:../../os/rt/include/chlists.h ****  *
 231:../../os/rt/include/chlists.h ****  * @param[in] qp        pointer to the queue header
 232:../../os/rt/include/chlists.h ****  * @return              The status of the queue.
 233:../../os/rt/include/chlists.h ****  *
 234:../../os/rt/include/chlists.h ****  * @notapi
 235:../../os/rt/include/chlists.h ****  */
 236:../../os/rt/include/chlists.h **** static inline bool ch_queue_isempty(const ch_queue_t *qp) {
 237:../../os/rt/include/chlists.h **** 
 238:../../os/rt/include/chlists.h ****   return (bool)(qp->next == qp);
 239:../../os/rt/include/chlists.h **** }
 240:../../os/rt/include/chlists.h **** 
 241:../../os/rt/include/chlists.h **** /**
 242:../../os/rt/include/chlists.h ****  * @brief   Evaluates to @p true if the specified queue is not empty.
 243:../../os/rt/include/chlists.h ****  *
 244:../../os/rt/include/chlists.h ****  * @param[in] qp        pointer to the queue header
 245:../../os/rt/include/chlists.h ****  * @return              The status of the queue.
 246:../../os/rt/include/chlists.h ****  *
 247:../../os/rt/include/chlists.h ****  * @notapi
 248:../../os/rt/include/chlists.h ****  */
 249:../../os/rt/include/chlists.h **** static inline bool ch_queue_notempty(const ch_queue_t *qp) {
 250:../../os/rt/include/chlists.h **** 
 251:../../os/rt/include/chlists.h ****   return (bool)(qp->next != qp);
 252:../../os/rt/include/chlists.h **** }
 253:../../os/rt/include/chlists.h **** 
 254:../../os/rt/include/chlists.h **** /**
 255:../../os/rt/include/chlists.h ****  * @brief   Inserts an element into a queue.
 256:../../os/rt/include/chlists.h ****  *
 257:../../os/rt/include/chlists.h ****  * @param[in] qp        the pointer to the queue header
 258:../../os/rt/include/chlists.h ****  * @param[in] p         the pointer to the element to be inserted in the queue
 259:../../os/rt/include/chlists.h ****  *
 260:../../os/rt/include/chlists.h ****  * @notapi
 261:../../os/rt/include/chlists.h ****  */
 262:../../os/rt/include/chlists.h **** static inline void ch_queue_insert(ch_queue_t *qp, ch_queue_t *p) {
 263:../../os/rt/include/chlists.h **** 
 264:../../os/rt/include/chlists.h ****   p->next       = qp;
 265:../../os/rt/include/chlists.h ****   p->prev       = qp->prev;
 266:../../os/rt/include/chlists.h ****   p->prev->next = p;
 267:../../os/rt/include/chlists.h ****   qp->prev      = p;
 268:../../os/rt/include/chlists.h **** }
 269:../../os/rt/include/chlists.h **** 
 270:../../os/rt/include/chlists.h **** /**
 271:../../os/rt/include/chlists.h ****  * @brief   Removes the first-out element from a queue and returns it.
 272:../../os/rt/include/chlists.h ****  * @note    If the queue is priority ordered then this function returns the
 273:../../os/rt/include/chlists.h ****  *          element with the highest priority.
 274:../../os/rt/include/chlists.h ****  *
 275:../../os/rt/include/chlists.h ****  * @param[in] qp        the pointer to the queue list header
 276:../../os/rt/include/chlists.h ****  * @return              The removed element pointer.
 277:../../os/rt/include/chlists.h ****  *
 278:../../os/rt/include/chlists.h ****  * @notapi
 279:../../os/rt/include/chlists.h ****  */
 280:../../os/rt/include/chlists.h **** static inline ch_queue_t *ch_queue_fifo_remove(ch_queue_t *qp) {
 281:../../os/rt/include/chlists.h ****   ch_queue_t *p = qp->next;
 282:../../os/rt/include/chlists.h **** 
 283:../../os/rt/include/chlists.h ****   qp->next       = p->next;
 284:../../os/rt/include/chlists.h ****   qp->next->prev = qp;
 285:../../os/rt/include/chlists.h **** 
 286:../../os/rt/include/chlists.h ****   return p;
 287:../../os/rt/include/chlists.h **** }
 288:../../os/rt/include/chlists.h **** 
 289:../../os/rt/include/chlists.h **** /**
 290:../../os/rt/include/chlists.h ****  * @brief   Removes the last-out element from a queue and returns it.
 291:../../os/rt/include/chlists.h ****  * @note    If the queue is priority ordered then this function returns the
 292:../../os/rt/include/chlists.h ****  *          element with the lowest priority.
 293:../../os/rt/include/chlists.h ****  *
 294:../../os/rt/include/chlists.h ****  * @param[in] qp    the pointer to the queue list header
 295:../../os/rt/include/chlists.h ****  * @return          The removed element pointer.
 296:../../os/rt/include/chlists.h ****  *
 297:../../os/rt/include/chlists.h ****  * @notapi
 298:../../os/rt/include/chlists.h ****  */
 299:../../os/rt/include/chlists.h **** static inline ch_queue_t *ch_queue_lifo_remove(ch_queue_t *qp) {
 300:../../os/rt/include/chlists.h ****   ch_queue_t *p = qp->prev;
 301:../../os/rt/include/chlists.h **** 
 302:../../os/rt/include/chlists.h ****   qp->prev       = p->prev;
 303:../../os/rt/include/chlists.h ****   qp->prev->next = qp;
 304:../../os/rt/include/chlists.h **** 
 305:../../os/rt/include/chlists.h ****   return p;
 306:../../os/rt/include/chlists.h **** }
 307:../../os/rt/include/chlists.h **** 
 308:../../os/rt/include/chlists.h **** /**
 309:../../os/rt/include/chlists.h ****  * @brief   Removes an element from a queue and returns it.
 310:../../os/rt/include/chlists.h ****  * @details The element is removed from the queue regardless of its relative
 311:../../os/rt/include/chlists.h ****  *          position and regardless the used insertion method.
 312:../../os/rt/include/chlists.h ****  *
 313:../../os/rt/include/chlists.h ****  * @param[in] p         the pointer to the element to be removed from the queue
 314:../../os/rt/include/chlists.h ****  * @return              The removed element pointer.
 315:../../os/rt/include/chlists.h ****  *
 316:../../os/rt/include/chlists.h ****  * @notapi
 317:../../os/rt/include/chlists.h ****  */
 318:../../os/rt/include/chlists.h **** static inline ch_queue_t *ch_queue_dequeue(ch_queue_t *p) {
 319:../../os/rt/include/chlists.h **** 
 320:../../os/rt/include/chlists.h ****   p->prev->next = p->next;
 321:../../os/rt/include/chlists.h ****   p->next->prev = p->prev;
 322:../../os/rt/include/chlists.h **** 
 323:../../os/rt/include/chlists.h ****   return p;
 324:../../os/rt/include/chlists.h **** }
 325:../../os/rt/include/chlists.h **** 
 326:../../os/rt/include/chlists.h **** /**
 327:../../os/rt/include/chlists.h ****  * @brief   Priority queue initialization.
 328:../../os/rt/include/chlists.h ****  * @note    The queue header priority is initialized to zero, all other
 329:../../os/rt/include/chlists.h ****  *          elements in the queue are assumed to have priority greater
 330:../../os/rt/include/chlists.h ****  *          than zero.
 331:../../os/rt/include/chlists.h ****  *
 332:../../os/rt/include/chlists.h ****  * @param[out] pqp      pointer to the priority queue header
 333:../../os/rt/include/chlists.h ****  *
 334:../../os/rt/include/chlists.h ****  * @notapi
 335:../../os/rt/include/chlists.h ****  */
 336:../../os/rt/include/chlists.h **** static inline void ch_pqueue_init(ch_priority_queue_t *pqp) {
 337:../../os/rt/include/chlists.h **** 
 338:../../os/rt/include/chlists.h ****   pqp->next = pqp;
 339:../../os/rt/include/chlists.h ****   pqp->prev = pqp;
 340:../../os/rt/include/chlists.h ****   pqp->prio = (tprio_t)0;
 341:../../os/rt/include/chlists.h **** }
 342:../../os/rt/include/chlists.h **** 
 343:../../os/rt/include/chlists.h **** /**
 344:../../os/rt/include/chlists.h ****  * @brief   Removes the highest priority element from a priority queue and
 345:../../os/rt/include/chlists.h ****  *          returns it.
 346:../../os/rt/include/chlists.h ****  *
 347:../../os/rt/include/chlists.h ****  * @param[in] pqp       the pointer to the priority queue list header
 348:../../os/rt/include/chlists.h ****  * @return              The removed element pointer.
 349:../../os/rt/include/chlists.h ****  *
 350:../../os/rt/include/chlists.h ****  * @notapi
 351:../../os/rt/include/chlists.h ****  */
 352:../../os/rt/include/chlists.h **** static inline ch_priority_queue_t *ch_pqueue_remove_highest(ch_priority_queue_t *pqp) {
 353:../../os/rt/include/chlists.h ****   ch_priority_queue_t *p = pqp->next;
 354:../../os/rt/include/chlists.h **** 
 355:../../os/rt/include/chlists.h ****   pqp->next       = p->next;
 356:../../os/rt/include/chlists.h ****   pqp->next->prev = pqp;
 357:../../os/rt/include/chlists.h **** 
 358:../../os/rt/include/chlists.h ****   return p;
 359:../../os/rt/include/chlists.h **** }
 360:../../os/rt/include/chlists.h **** 
 361:../../os/rt/include/chlists.h **** /**
 362:../../os/rt/include/chlists.h ****  * @brief   Inserts an element in the priority queue placing it behind
 363:../../os/rt/include/chlists.h ****  *          its peers.
 364:../../os/rt/include/chlists.h ****  * @details The element is positioned behind all elements with higher or
 365:../../os/rt/include/chlists.h ****  *          equal priority.
 366:../../os/rt/include/chlists.h ****  *
 367:../../os/rt/include/chlists.h ****  * @param[in] pqp       the pointer to the priority queue list header
 368:../../os/rt/include/chlists.h ****  * @param[in] p         the pointer to the element to be inserted in the queue
 369:../../os/rt/include/chlists.h ****  * @return              The inserted element pointer.
 370:../../os/rt/include/chlists.h ****  *
 371:../../os/rt/include/chlists.h ****  * @notapi
 372:../../os/rt/include/chlists.h ****  */
 373:../../os/rt/include/chlists.h **** static inline ch_priority_queue_t *ch_pqueue_insert_behind(ch_priority_queue_t *pqp,
 374:../../os/rt/include/chlists.h ****                                                            ch_priority_queue_t *p) {
 375:../../os/rt/include/chlists.h **** 
 376:../../os/rt/include/chlists.h ****   /* Scanning priority queue, the list is assumed to be mostly empty.*/
 377:../../os/rt/include/chlists.h ****   do {
 378:../../os/rt/include/chlists.h ****     pqp = pqp->next;
 379:../../os/rt/include/chlists.h ****   } while (unlikely(pqp->prio >= p->prio));
  75               		.loc 2 379 0
  76 0040 1496      		adiw r26,4
  77 0042 9C91      		ld r25,X
  78 0044 1497      		sbiw r26,4
  79               	.L8:
 378:../../os/rt/include/chlists.h ****   } while (unlikely(pqp->prio >= p->prio));
  80               		.loc 2 378 0
  81 0046 0190      		ld __tmp_reg__,Z+
  82 0048 F081      		ld r31,Z
  83 004a E02D      		mov r30,__tmp_reg__
  84               	.LVL5:
  85               		.loc 2 379 0
  86 004c 8481      		ldd r24,Z+4
  87 004e 8917      		cp r24,r25
  88 0050 00F4      		brsh .L8
 380:../../os/rt/include/chlists.h **** 
 381:../../os/rt/include/chlists.h ****   /* Insertion on prev.*/
 382:../../os/rt/include/chlists.h ****   p->next       = pqp;
  89               		.loc 2 382 0
  90 0052 1196      		adiw r26,1
  91 0054 FC93      		st X,r31
  92 0056 EE93      		st -X,r30
 383:../../os/rt/include/chlists.h ****   p->prev       = pqp->prev;
  93               		.loc 2 383 0
  94 0058 C281      		ldd r28,Z+2
  95 005a D381      		ldd r29,Z+3
  96 005c 1396      		adiw r26,2+1
  97 005e DC93      		st X,r29
  98 0060 CE93      		st -X,r28
  99 0062 1297      		sbiw r26,2
 384:../../os/rt/include/chlists.h ****   p->prev->next = p;
 100               		.loc 2 384 0
 101 0064 B983      		std Y+1,r27
 102 0066 A883      		st Y,r26
 385:../../os/rt/include/chlists.h ****   pqp->prev     = p;
 103               		.loc 2 385 0
 104 0068 B383      		std Z+3,r27
 105 006a A283      		std Z+2,r26
 106               	.LVL6:
 107               	.L1:
 108               	/* epilogue start */
 109               	.LBE68:
 110               	.LBE67:
 111               	.LBE66:
 112               	.LBE65:
 227:../../os/rt/src/chschd.c **** 
 228:../../os/rt/src/chschd.c ****   /* Goes behind peers because it went to sleep voluntarily.*/
 229:../../os/rt/src/chschd.c ****   (void) __sch_ready_behind(tp);
 230:../../os/rt/src/chschd.c ****   chSysUnlockFromISR();
 231:../../os/rt/src/chschd.c **** 
 232:../../os/rt/src/chschd.c ****   return;
 233:../../os/rt/src/chschd.c **** }
 113               		.loc 1 233 0
 114 006c DF91      		pop r29
 115 006e CF91      		pop r28
 116 0070 0895      		ret
 117               	.L4:
 194:../../os/rt/src/chschd.c ****   case CH_STATE_READY:
 118               		.loc 1 194 0
 119 0072 8730      		cpi r24,lo8(7)
 120 0074 01F0      		breq .L3
 121 0076 8C30      		cpi r24,lo8(12)
 122 0078 01F0      		breq .L3
 123 007a 8530      		cpi r24,lo8(5)
 124 007c 01F4      		brne .L2
 205:../../os/rt/src/chschd.c **** #endif
 125               		.loc 1 205 0
 126 007e 5296      		adiw r26,18
 127 0080 ED91      		ld r30,X+
 128 0082 FC91      		ld r31,X
 129 0084 5397      		sbiw r26,18+1
 130               	.LVL7:
 131               	.LBB69:
 132               	.LBB70:
 133               		.file 3 "../../os/rt/include/chsem.h"
   1:../../os/rt/include/chsem.h **** /*
   2:../../os/rt/include/chsem.h ****     ChibiOS - Copyright (C) 2006,2007,2008,2009,2010,2011,2012,2013,2014,
   3:../../os/rt/include/chsem.h ****               2015,2016,2017,2018,2019,2020,2021 Giovanni Di Sirio.
   4:../../os/rt/include/chsem.h **** 
   5:../../os/rt/include/chsem.h ****     This file is part of ChibiOS.
   6:../../os/rt/include/chsem.h **** 
   7:../../os/rt/include/chsem.h ****     ChibiOS is free software; you can redistribute it and/or modify
   8:../../os/rt/include/chsem.h ****     it under the terms of the GNU General Public License as published by
   9:../../os/rt/include/chsem.h ****     the Free Software Foundation version 3 of the License.
  10:../../os/rt/include/chsem.h **** 
  11:../../os/rt/include/chsem.h ****     ChibiOS is distributed in the hope that it will be useful,
  12:../../os/rt/include/chsem.h ****     but WITHOUT ANY WARRANTY; without even the implied warranty of
  13:../../os/rt/include/chsem.h ****     MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
  14:../../os/rt/include/chsem.h ****     GNU General Public License for more details.
  15:../../os/rt/include/chsem.h **** 
  16:../../os/rt/include/chsem.h ****     You should have received a copy of the GNU General Public License
  17:../../os/rt/include/chsem.h ****     along with this program.  If not, see <http://www.gnu.org/licenses/>.
  18:../../os/rt/include/chsem.h **** */
  19:../../os/rt/include/chsem.h **** 
  20:../../os/rt/include/chsem.h **** /**
  21:../../os/rt/include/chsem.h ****  * @file    rt/include/chsem.h
  22:../../os/rt/include/chsem.h ****  * @brief   Semaphores macros and structures.
  23:../../os/rt/include/chsem.h ****  *
  24:../../os/rt/include/chsem.h ****  * @addtogroup semaphores
  25:../../os/rt/include/chsem.h ****  * @{
  26:../../os/rt/include/chsem.h ****  */
  27:../../os/rt/include/chsem.h **** 
  28:../../os/rt/include/chsem.h **** #ifndef CHSEM_H
  29:../../os/rt/include/chsem.h **** #define CHSEM_H
  30:../../os/rt/include/chsem.h **** 
  31:../../os/rt/include/chsem.h **** #if (CH_CFG_USE_SEMAPHORES == TRUE) || defined(__DOXYGEN__)
  32:../../os/rt/include/chsem.h **** 
  33:../../os/rt/include/chsem.h **** /*===========================================================================*/
  34:../../os/rt/include/chsem.h **** /* Module constants.                                                         */
  35:../../os/rt/include/chsem.h **** /*===========================================================================*/
  36:../../os/rt/include/chsem.h **** 
  37:../../os/rt/include/chsem.h **** /*===========================================================================*/
  38:../../os/rt/include/chsem.h **** /* Module pre-compile time settings.                                         */
  39:../../os/rt/include/chsem.h **** /*===========================================================================*/
  40:../../os/rt/include/chsem.h **** 
  41:../../os/rt/include/chsem.h **** /*===========================================================================*/
  42:../../os/rt/include/chsem.h **** /* Derived constants and error checks.                                       */
  43:../../os/rt/include/chsem.h **** /*===========================================================================*/
  44:../../os/rt/include/chsem.h **** 
  45:../../os/rt/include/chsem.h **** /*===========================================================================*/
  46:../../os/rt/include/chsem.h **** /* Module data structures and types.                                         */
  47:../../os/rt/include/chsem.h **** /*===========================================================================*/
  48:../../os/rt/include/chsem.h **** 
  49:../../os/rt/include/chsem.h **** /**
  50:../../os/rt/include/chsem.h ****  * @brief   Semaphore structure.
  51:../../os/rt/include/chsem.h ****  */
  52:../../os/rt/include/chsem.h **** typedef struct ch_semaphore {
  53:../../os/rt/include/chsem.h ****   ch_queue_t            queue;      /**< @brief Queue of the threads sleeping
  54:../../os/rt/include/chsem.h ****                                                 on this semaphore.          */
  55:../../os/rt/include/chsem.h ****   cnt_t                 cnt;        /**< @brief The semaphore counter.      */
  56:../../os/rt/include/chsem.h **** } semaphore_t;
  57:../../os/rt/include/chsem.h **** 
  58:../../os/rt/include/chsem.h **** /*===========================================================================*/
  59:../../os/rt/include/chsem.h **** /* Module macros.                                                            */
  60:../../os/rt/include/chsem.h **** /*===========================================================================*/
  61:../../os/rt/include/chsem.h **** 
  62:../../os/rt/include/chsem.h **** /**
  63:../../os/rt/include/chsem.h ****  * @brief   Data part of a static semaphore initializer.
  64:../../os/rt/include/chsem.h ****  * @details This macro should be used when statically initializing a semaphore
  65:../../os/rt/include/chsem.h ****  *          that is part of a bigger structure.
  66:../../os/rt/include/chsem.h ****  *
  67:../../os/rt/include/chsem.h ****  * @param[in] name      the name of the semaphore variable
  68:../../os/rt/include/chsem.h ****  * @param[in] n         the counter initial value, this value must be
  69:../../os/rt/include/chsem.h ****  *                      non-negative
  70:../../os/rt/include/chsem.h ****  */
  71:../../os/rt/include/chsem.h **** #define __SEMAPHORE_DATA(name, n) {__CH_QUEUE_DATA(name.queue), n}
  72:../../os/rt/include/chsem.h **** 
  73:../../os/rt/include/chsem.h **** /**
  74:../../os/rt/include/chsem.h ****  * @brief   Static semaphore initializer.
  75:../../os/rt/include/chsem.h ****  * @details Statically initialized semaphores require no explicit
  76:../../os/rt/include/chsem.h ****  *          initialization using @p chSemInit().
  77:../../os/rt/include/chsem.h ****  *
  78:../../os/rt/include/chsem.h ****  * @param[in] name      the name of the semaphore variable
  79:../../os/rt/include/chsem.h ****  * @param[in] n         the counter initial value, this value must be
  80:../../os/rt/include/chsem.h ****  *                      non-negative
  81:../../os/rt/include/chsem.h ****  */
  82:../../os/rt/include/chsem.h **** #define SEMAPHORE_DECL(name, n) semaphore_t name = __SEMAPHORE_DATA(name, n)
  83:../../os/rt/include/chsem.h **** 
  84:../../os/rt/include/chsem.h **** /*===========================================================================*/
  85:../../os/rt/include/chsem.h **** /* External declarations.                                                    */
  86:../../os/rt/include/chsem.h **** /*===========================================================================*/
  87:../../os/rt/include/chsem.h **** 
  88:../../os/rt/include/chsem.h **** #ifdef __cplusplus
  89:../../os/rt/include/chsem.h **** extern "C" {
  90:../../os/rt/include/chsem.h **** #endif
  91:../../os/rt/include/chsem.h ****   void chSemObjectInit(semaphore_t *sp, cnt_t n);
  92:../../os/rt/include/chsem.h ****   void chSemResetWithMessage(semaphore_t *sp, cnt_t n, msg_t msg);
  93:../../os/rt/include/chsem.h ****   void chSemResetWithMessageI(semaphore_t *sp, cnt_t n, msg_t msg);
  94:../../os/rt/include/chsem.h ****   msg_t chSemWait(semaphore_t *sp);
  95:../../os/rt/include/chsem.h ****   msg_t chSemWaitS(semaphore_t *sp);
  96:../../os/rt/include/chsem.h ****   msg_t chSemWaitTimeout(semaphore_t *sp, sysinterval_t timeout);
  97:../../os/rt/include/chsem.h ****   msg_t chSemWaitTimeoutS(semaphore_t *sp, sysinterval_t timeout);
  98:../../os/rt/include/chsem.h ****   void chSemSignal(semaphore_t *sp);
  99:../../os/rt/include/chsem.h ****   void chSemSignalI(semaphore_t *sp);
 100:../../os/rt/include/chsem.h ****   void chSemAddCounterI(semaphore_t *sp, cnt_t n);
 101:../../os/rt/include/chsem.h ****   msg_t chSemSignalWait(semaphore_t *sps, semaphore_t *spw);
 102:../../os/rt/include/chsem.h **** #ifdef __cplusplus
 103:../../os/rt/include/chsem.h **** }
 104:../../os/rt/include/chsem.h **** #endif
 105:../../os/rt/include/chsem.h **** 
 106:../../os/rt/include/chsem.h **** /*===========================================================================*/
 107:../../os/rt/include/chsem.h **** /* Module inline functions.                                                  */
 108:../../os/rt/include/chsem.h **** /*===========================================================================*/
 109:../../os/rt/include/chsem.h **** 
 110:../../os/rt/include/chsem.h **** /**
 111:../../os/rt/include/chsem.h ****  * @brief   Performs a reset operation on the semaphore.
 112:../../os/rt/include/chsem.h ****  * @post    After invoking this function all the threads waiting on the
 113:../../os/rt/include/chsem.h ****  *          semaphore, if any, are released and the semaphore counter is set
 114:../../os/rt/include/chsem.h ****  *          to the specified, non negative, value.
 115:../../os/rt/include/chsem.h ****  * @note    This function implicitly sends @p MSG_RESET as message.
 116:../../os/rt/include/chsem.h ****  *
 117:../../os/rt/include/chsem.h ****  * @param[in] sp        pointer to a @p semaphore_t structure
 118:../../os/rt/include/chsem.h ****  * @param[in] n         the new value of the semaphore counter. The value must
 119:../../os/rt/include/chsem.h ****  *                      be non-negative.
 120:../../os/rt/include/chsem.h ****  *
 121:../../os/rt/include/chsem.h ****  * @api
 122:../../os/rt/include/chsem.h ****  */
 123:../../os/rt/include/chsem.h **** static inline void chSemReset(semaphore_t *sp, cnt_t n) {
 124:../../os/rt/include/chsem.h **** 
 125:../../os/rt/include/chsem.h ****   chSemResetWithMessage(sp, n, MSG_RESET);
 126:../../os/rt/include/chsem.h **** }
 127:../../os/rt/include/chsem.h **** 
 128:../../os/rt/include/chsem.h **** /**
 129:../../os/rt/include/chsem.h ****  * @brief   Performs a reset operation on the semaphore.
 130:../../os/rt/include/chsem.h ****  * @post    After invoking this function all the threads waiting on the
 131:../../os/rt/include/chsem.h ****  *          semaphore, if any, are released and the semaphore counter is set
 132:../../os/rt/include/chsem.h ****  *          to the specified, non negative, value.
 133:../../os/rt/include/chsem.h ****  * @post    This function does not reschedule so a call to a rescheduling
 134:../../os/rt/include/chsem.h ****  *          function must be performed before unlocking the kernel. Note that
 135:../../os/rt/include/chsem.h ****  *          interrupt handlers always reschedule on exit so an explicit
 136:../../os/rt/include/chsem.h ****  *          reschedule must not be performed in ISRs.
 137:../../os/rt/include/chsem.h ****  * @note    This function implicitly sends @p MSG_RESET as message.
 138:../../os/rt/include/chsem.h ****  *
 139:../../os/rt/include/chsem.h ****  * @param[in] sp        pointer to a @p semaphore_t structure
 140:../../os/rt/include/chsem.h ****  * @param[in] n         the new value of the semaphore counter. The value must
 141:../../os/rt/include/chsem.h ****  *                      be non-negative.
 142:../../os/rt/include/chsem.h ****  *
 143:../../os/rt/include/chsem.h ****  * @iclass
 144:../../os/rt/include/chsem.h ****  */
 145:../../os/rt/include/chsem.h **** static inline void chSemResetI(semaphore_t *sp, cnt_t n) {
 146:../../os/rt/include/chsem.h **** 
 147:../../os/rt/include/chsem.h ****   chSemResetWithMessageI(sp, n, MSG_RESET);
 148:../../os/rt/include/chsem.h **** }
 149:../../os/rt/include/chsem.h **** 
 150:../../os/rt/include/chsem.h **** /**
 151:../../os/rt/include/chsem.h ****  * @brief   Decreases the semaphore counter.
 152:../../os/rt/include/chsem.h ****  * @details This macro can be used when the counter is known to be positive.
 153:../../os/rt/include/chsem.h ****  *
 154:../../os/rt/include/chsem.h ****  * @param[in] sp        pointer to a @p semaphore_t structure
 155:../../os/rt/include/chsem.h ****  *
 156:../../os/rt/include/chsem.h ****  * @iclass
 157:../../os/rt/include/chsem.h ****  */
 158:../../os/rt/include/chsem.h **** static inline void chSemFastWaitI(semaphore_t *sp) {
 159:../../os/rt/include/chsem.h **** 
 160:../../os/rt/include/chsem.h ****   chDbgCheckClassI();
 161:../../os/rt/include/chsem.h **** 
 162:../../os/rt/include/chsem.h ****   sp->cnt--;
 163:../../os/rt/include/chsem.h **** }
 164:../../os/rt/include/chsem.h **** 
 165:../../os/rt/include/chsem.h **** /**
 166:../../os/rt/include/chsem.h ****  * @brief   Increases the semaphore counter.
 167:../../os/rt/include/chsem.h ****  * @details This macro can be used when the counter is known to be not
 168:../../os/rt/include/chsem.h ****  *          negative.
 169:../../os/rt/include/chsem.h ****  *
 170:../../os/rt/include/chsem.h ****  * @param[in] sp        pointer to a @p semaphore_t structure
 171:../../os/rt/include/chsem.h ****  *
 172:../../os/rt/include/chsem.h ****  * @iclass
 173:../../os/rt/include/chsem.h ****  */
 174:../../os/rt/include/chsem.h **** static inline void chSemFastSignalI(semaphore_t *sp) {
 175:../../os/rt/include/chsem.h **** 
 176:../../os/rt/include/chsem.h ****   chDbgCheckClassI();
 177:../../os/rt/include/chsem.h **** 
 178:../../os/rt/include/chsem.h ****   sp->cnt++;
 134               		.loc 3 178 0
 135 0086 8481      		ldd r24,Z+4
 136 0088 8F5F      		subi r24,lo8(-(1))
 137 008a 8483      		std Z+4,r24
 138               	.LVL8:
 139               	.L3:
 140               	.LBE70:
 141               	.LBE69:
 142               	.LBB71:
 143               	.LBB72:
 320:../../os/rt/include/chlists.h ****   p->next->prev = p->prev;
 144               		.loc 2 320 0
 145 008c 1296      		adiw r26,2
 146 008e ED91      		ld r30,X+
 147 0090 FC91      		ld r31,X
 148 0092 1397      		sbiw r26,2+1
 149 0094 8D91      		ld r24,X+
 150 0096 9C91      		ld r25,X
 151 0098 1197      		sbiw r26,1
 152 009a 9183      		std Z+1,r25
 153 009c 8083      		st Z,r24
 321:../../os/rt/include/chlists.h **** 
 154               		.loc 2 321 0
 155 009e CD91      		ld r28,X+
 156 00a0 DC91      		ld r29,X
 157 00a2 1197      		sbiw r26,1
 158 00a4 FB83      		std Y+3,r31
 159 00a6 EA83      		std Y+2,r30
 160 00a8 00C0      		rjmp .L2
 161               	.LBE72:
 162               	.LBE71:
 163               		.cfi_endproc
 164               	.LFE199:
 166               		.section	.text.chSchReadyI,"ax",@progbits
 167               	.global	chSchReadyI
 169               	chSchReadyI:
 170               	.LFB200:
 234:../../os/rt/src/chschd.c **** 
 235:../../os/rt/src/chschd.c **** /*===========================================================================*/
 236:../../os/rt/src/chschd.c **** /* Module exported functions.                                                */
 237:../../os/rt/src/chschd.c **** /*===========================================================================*/
 238:../../os/rt/src/chschd.c **** 
 239:../../os/rt/src/chschd.c **** #if (CH_CFG_OPTIMIZE_SPEED == FALSE) || defined(__DOXYGEN__)
 240:../../os/rt/src/chschd.c **** /**
 241:../../os/rt/src/chschd.c ****  * @brief   Inserts a thread into a priority ordered queue.
 242:../../os/rt/src/chschd.c ****  * @note    The insertion is done by scanning the list from the highest
 243:../../os/rt/src/chschd.c ****  *          priority toward the lowest.
 244:../../os/rt/src/chschd.c ****  *
 245:../../os/rt/src/chschd.c ****  * @param[in] qp        the pointer to the threads list header
 246:../../os/rt/src/chschd.c ****  * @param[in] tp        the pointer to the thread to be inserted in the list
 247:../../os/rt/src/chschd.c ****  *
 248:../../os/rt/src/chschd.c ****  * @notapi
 249:../../os/rt/src/chschd.c ****  */
 250:../../os/rt/src/chschd.c **** void ch_sch_prio_insert(ch_queue_t *qp, ch_queue_t *tp) {
 251:../../os/rt/src/chschd.c **** 
 252:../../os/rt/src/chschd.c ****   ch_queue_t *cp = qp;
 253:../../os/rt/src/chschd.c ****   do {
 254:../../os/rt/src/chschd.c ****     cp = cp->next;
 255:../../os/rt/src/chschd.c ****   } while ((cp != qp) &&
 256:../../os/rt/src/chschd.c ****            (threadref(cp)->hdr.pqueue.prio >= threadref(tp)->hdr.pqueue.prio));
 257:../../os/rt/src/chschd.c ****   tp->next       = cp;
 258:../../os/rt/src/chschd.c ****   tp->prev       = cp->prev;
 259:../../os/rt/src/chschd.c ****   tp->prev->next = tp;
 260:../../os/rt/src/chschd.c ****   cp->prev       = tp;
 261:../../os/rt/src/chschd.c **** }
 262:../../os/rt/src/chschd.c **** #endif /* CH_CFG_OPTIMIZE_SPEED */
 263:../../os/rt/src/chschd.c **** 
 264:../../os/rt/src/chschd.c **** /**
 265:../../os/rt/src/chschd.c ****  * @brief   Inserts a thread in the Ready List placing it behind its peers.
 266:../../os/rt/src/chschd.c ****  * @details The thread is positioned behind all threads with higher or equal
 267:../../os/rt/src/chschd.c ****  *          priority.
 268:../../os/rt/src/chschd.c ****  * @pre     The thread must not be already inserted in any list through its
 269:../../os/rt/src/chschd.c ****  *          @p next and @p prev or list corruption would occur.
 270:../../os/rt/src/chschd.c ****  * @post    This function does not reschedule so a call to a rescheduling
 271:../../os/rt/src/chschd.c ****  *          function must be performed before unlocking the kernel. Note that
 272:../../os/rt/src/chschd.c ****  *          interrupt handlers always reschedule on exit so an explicit
 273:../../os/rt/src/chschd.c ****  *          reschedule must not be performed in ISRs.
 274:../../os/rt/src/chschd.c ****  *
 275:../../os/rt/src/chschd.c ****  * @param[in] tp        the thread to be made ready
 276:../../os/rt/src/chschd.c ****  * @return              The thread pointer.
 277:../../os/rt/src/chschd.c ****  *
 278:../../os/rt/src/chschd.c ****  * @iclass
 279:../../os/rt/src/chschd.c ****  */
 280:../../os/rt/src/chschd.c **** thread_t *chSchReadyI(thread_t *tp) {
 171               		.loc 1 280 0
 172               		.cfi_startproc
 173               	.LVL9:
 174 0000 CF93      		push r28
 175               	.LCFI2:
 176               		.cfi_def_cfa_offset 3
 177               		.cfi_offset 28, -2
 178 0002 DF93      		push r29
 179               	.LCFI3:
 180               		.cfi_def_cfa_offset 4
 181               		.cfi_offset 29, -3
 182               	/* prologue: function */
 183               	/* frame size = 0 */
 184               	/* stack size = 2 */
 185               	.L__stack_usage = 2
 186 0004 DC01      		movw r26,r24
 187               	.LVL10:
 188               	.LBB73:
 189               	.LBB74:
  77:../../os/rt/src/chschd.c **** 
 190               		.loc 1 77 0
 191 0006 1F96      		adiw r26,15
 192 0008 1C92      		st X,__zero_reg__
 193 000a 1F97      		sbiw r26,15
  80:../../os/rt/src/chschd.c ****                                            &tp->hdr.pqueue));
 194               		.loc 1 80 0
 195 000c 1B96      		adiw r26,11
 196 000e ED91      		ld r30,X+
 197 0010 FC91      		ld r31,X
 198 0012 1C97      		sbiw r26,11+1
 199               	.LVL11:
 200               	.LBB75:
 201               	.LBB76:
 379:../../os/rt/include/chlists.h **** 
 202               		.loc 2 379 0
 203 0014 1496      		adiw r26,4
 204 0016 8C91      		ld r24,X
 205 0018 1497      		sbiw r26,4
 206               	.LVL12:
 207               	.L24:
 378:../../os/rt/include/chlists.h ****   } while (unlikely(pqp->prio >= p->prio));
 208               		.loc 2 378 0
 209 001a 0190      		ld __tmp_reg__,Z+
 210 001c F081      		ld r31,Z
 211 001e E02D      		mov r30,__tmp_reg__
 212               	.LVL13:
 379:../../os/rt/include/chlists.h **** 
 213               		.loc 2 379 0
 214 0020 9481      		ldd r25,Z+4
 215 0022 9817      		cp r25,r24
 216 0024 00F4      		brsh .L24
 382:../../os/rt/include/chlists.h ****   p->prev       = pqp->prev;
 217               		.loc 2 382 0
 218 0026 1196      		adiw r26,1
 219 0028 FC93      		st X,r31
 220 002a EE93      		st -X,r30
 383:../../os/rt/include/chlists.h ****   p->prev->next = p;
 221               		.loc 2 383 0
 222 002c C281      		ldd r28,Z+2
 223 002e D381      		ldd r29,Z+3
 224 0030 1396      		adiw r26,2+1
 225 0032 DC93      		st X,r29
 226 0034 CE93      		st -X,r28
 227 0036 1297      		sbiw r26,2
 384:../../os/rt/include/chlists.h ****   pqp->prev     = p;
 228               		.loc 2 384 0
 229 0038 B983      		std Y+1,r27
 230 003a A883      		st Y,r26
 231               		.loc 2 385 0
 232 003c B383      		std Z+3,r27
 233 003e A283      		std Z+2,r26
 234               	.LVL14:
 235               	.LBE76:
 236               	.LBE75:
 237               	.LBE74:
 238               	.LBE73:
 281:../../os/rt/src/chschd.c **** 
 282:../../os/rt/src/chschd.c ****   chDbgCheckClassI();
 283:../../os/rt/src/chschd.c ****   chDbgCheck(tp != NULL);
 284:../../os/rt/src/chschd.c **** 
 285:../../os/rt/src/chschd.c **** #if CH_CFG_SMP_MODE == TRUE
 286:../../os/rt/src/chschd.c ****   if (tp->owner != currcore) {
 287:../../os/rt/src/chschd.c ****     /* Readying up the remote thread and triggering a reschedule on
 288:../../os/rt/src/chschd.c ****        the other core.*/
 289:../../os/rt/src/chschd.c ****     chSysNotifyInstance(tp->owner);
 290:../../os/rt/src/chschd.c ****   }
 291:../../os/rt/src/chschd.c **** #endif
 292:../../os/rt/src/chschd.c **** 
 293:../../os/rt/src/chschd.c ****   return __sch_ready_behind(tp);
 294:../../os/rt/src/chschd.c **** }
 239               		.loc 1 294 0
 240 0040 CD01      		movw r24,r26
 241               	/* epilogue start */
 242 0042 DF91      		pop r29
 243 0044 CF91      		pop r28
 244 0046 0895      		ret
 245               		.cfi_endproc
 246               	.LFE200:
 248               		.section	.text.chSchGoSleepS,"ax",@progbits
 249               	.global	chSchGoSleepS
 251               	chSchGoSleepS:
 252               	.LFB201:
 295:../../os/rt/src/chschd.c **** 
 296:../../os/rt/src/chschd.c **** /**
 297:../../os/rt/src/chschd.c ****  * @brief   Puts the current thread to sleep into the specified state.
 298:../../os/rt/src/chschd.c ****  * @details The thread goes into a sleeping state. The possible
 299:../../os/rt/src/chschd.c ****  *          @ref thread_states are defined into @p threads.h.
 300:../../os/rt/src/chschd.c ****  *
 301:../../os/rt/src/chschd.c ****  * @param[in] newstate  the new thread state
 302:../../os/rt/src/chschd.c ****  *
 303:../../os/rt/src/chschd.c ****  * @sclass
 304:../../os/rt/src/chschd.c ****  */
 305:../../os/rt/src/chschd.c **** void chSchGoSleepS(tstate_t newstate) {
 253               		.loc 1 305 0
 254               		.cfi_startproc
 255               	.LVL15:
 256 0000 CF93      		push r28
 257               	.LCFI4:
 258               		.cfi_def_cfa_offset 3
 259               		.cfi_offset 28, -2
 260 0002 DF93      		push r29
 261               	.LCFI5:
 262               		.cfi_def_cfa_offset 4
 263               		.cfi_offset 29, -3
 264               	/* prologue: function */
 265               	/* frame size = 0 */
 266               	/* stack size = 2 */
 267               	.L__stack_usage = 2
 268               	.LVL16:
 306:../../os/rt/src/chschd.c ****   os_instance_t *oip = currcore;
 307:../../os/rt/src/chschd.c ****   thread_t *otp = __instance_get_currthread(oip);
 269               		.loc 1 307 0
 270 0004 E0E0      		ldi r30,lo8(ch0)
 271 0006 F0E0      		ldi r31,hi8(ch0)
 272 0008 6581      		ldd r22,Z+5
 273 000a 7681      		ldd r23,Z+6
 274               	.LVL17:
 308:../../os/rt/src/chschd.c ****   thread_t *ntp;
 309:../../os/rt/src/chschd.c **** 
 310:../../os/rt/src/chschd.c ****   chDbgCheckClassS();
 311:../../os/rt/src/chschd.c **** 
 312:../../os/rt/src/chschd.c ****   chDbgAssert(otp != chSysGetIdleThreadX(), "sleeping in idle thread");
 313:../../os/rt/src/chschd.c ****   chDbgAssert(otp->owner == oip, "invalid core");
 314:../../os/rt/src/chschd.c **** 
 315:../../os/rt/src/chschd.c ****   /* New state.*/
 316:../../os/rt/src/chschd.c ****   otp->state = newstate;
 275               		.loc 1 316 0
 276 000c DB01      		movw r26,r22
 277 000e 1F96      		adiw r26,15
 278 0010 8C93      		st X,r24
 279               	.LVL18:
 280               	.LBB77:
 281               	.LBB78:
 353:../../os/rt/include/chlists.h **** 
 282               		.loc 2 353 0
 283 0012 8081      		ld r24,Z
 284 0014 9181      		ldd r25,Z+1
 285               	.LVL19:
 355:../../os/rt/include/chlists.h ****   pqp->next->prev = pqp;
 286               		.loc 2 355 0
 287 0016 EC01      		movw r28,r24
 288 0018 A881      		ld r26,Y
 289 001a B981      		ldd r27,Y+1
 290 001c B183      		std Z+1,r27
 291 001e A083      		st Z,r26
 356:../../os/rt/include/chlists.h **** 
 292               		.loc 2 356 0
 293 0020 1396      		adiw r26,2+1
 294 0022 FC93      		st X,r31
 295 0024 EE93      		st -X,r30
 296 0026 1297      		sbiw r26,2
 297               	.LVL20:
 298               	.LBE78:
 299               	.LBE77:
 317:../../os/rt/src/chschd.c **** 
 318:../../os/rt/src/chschd.c **** #if CH_CFG_TIME_QUANTUM > 0
 319:../../os/rt/src/chschd.c ****   /* The thread is renouncing its remaining time slices so it will have a new
 320:../../os/rt/src/chschd.c ****      time quantum when it will wakeup.*/
 321:../../os/rt/src/chschd.c ****   otp->ticks = (tslices_t)CH_CFG_TIME_QUANTUM;
 322:../../os/rt/src/chschd.c **** #endif
 323:../../os/rt/src/chschd.c **** 
 324:../../os/rt/src/chschd.c ****   /* Next thread in ready list becomes current.*/
 325:../../os/rt/src/chschd.c ****   ntp = threadref(ch_pqueue_remove_highest(&oip->rlist.pqueue));
 326:../../os/rt/src/chschd.c ****   ntp->state = CH_STATE_CURRENT;
 300               		.loc 1 326 0
 301 0028 21E0      		ldi r18,lo8(1)
 302 002a 2F87      		std Y+15,r18
 327:../../os/rt/src/chschd.c ****   __instance_set_currthread(oip, ntp);
 303               		.loc 1 327 0
 304 002c 9683      		std Z+6,r25
 305 002e 8583      		std Z+5,r24
 328:../../os/rt/src/chschd.c **** 
 329:../../os/rt/src/chschd.c ****   /* Handling idle-enter hook.*/
 330:../../os/rt/src/chschd.c ****   if (ntp->hdr.pqueue.prio == IDLEPRIO) {
 331:../../os/rt/src/chschd.c ****     CH_CFG_IDLE_ENTER_HOOK();
 332:../../os/rt/src/chschd.c ****   }
 333:../../os/rt/src/chschd.c **** 
 334:../../os/rt/src/chschd.c ****   /* Swap operation as tail call.*/
 335:../../os/rt/src/chschd.c ****   chSysSwitch(ntp, otp);
 306               		.loc 1 335 0
 307 0030 0E94 0000 		call _port_switch
 308               	.LVL21:
 309               	/* epilogue start */
 336:../../os/rt/src/chschd.c **** }
 310               		.loc 1 336 0
 311 0034 DF91      		pop r29
 312 0036 CF91      		pop r28
 313 0038 0895      		ret
 314               		.cfi_endproc
 315               	.LFE201:
 317               		.section	.text.chSchGoSleepTimeoutS,"ax",@progbits
 318               	.global	chSchGoSleepTimeoutS
 320               	chSchGoSleepTimeoutS:
 321               	.LFB202:
 337:../../os/rt/src/chschd.c **** 
 338:../../os/rt/src/chschd.c **** /**
 339:../../os/rt/src/chschd.c ****  * @brief   Puts the current thread to sleep into the specified state with
 340:../../os/rt/src/chschd.c ****  *          timeout specification.
 341:../../os/rt/src/chschd.c ****  * @details The thread goes into a sleeping state, if it is not awakened
 342:../../os/rt/src/chschd.c ****  *          explicitly within the specified timeout then it is forcibly
 343:../../os/rt/src/chschd.c ****  *          awakened with a @p MSG_TIMEOUT low level message. The possible
 344:../../os/rt/src/chschd.c ****  *          @ref thread_states are defined into @p threads.h.
 345:../../os/rt/src/chschd.c ****  *
 346:../../os/rt/src/chschd.c ****  * @param[in] newstate  the new thread state
 347:../../os/rt/src/chschd.c ****  * @param[in] timeout   the number of ticks before the operation timeouts, the
 348:../../os/rt/src/chschd.c ****  *                      special values are handled as follow:
 349:../../os/rt/src/chschd.c ****  *                      - @a TIME_INFINITE the thread enters an infinite sleep
 350:../../os/rt/src/chschd.c ****  *                        state, this is equivalent to invoking
 351:../../os/rt/src/chschd.c ****  *                        @p chSchGoSleepS() but, of course, less efficient.
 352:../../os/rt/src/chschd.c ****  *                      - @a TIME_IMMEDIATE this value is not allowed.
 353:../../os/rt/src/chschd.c ****  *                      .
 354:../../os/rt/src/chschd.c ****  * @return              The wakeup message.
 355:../../os/rt/src/chschd.c ****  * @retval MSG_TIMEOUT  if a timeout occurs.
 356:../../os/rt/src/chschd.c ****  *
 357:../../os/rt/src/chschd.c ****  * @sclass
 358:../../os/rt/src/chschd.c ****  */
 359:../../os/rt/src/chschd.c **** msg_t chSchGoSleepTimeoutS(tstate_t newstate, sysinterval_t timeout) {
 322               		.loc 1 359 0
 323               		.cfi_startproc
 324               	.LVL22:
 325 0000 FF92      		push r15
 326               	.LCFI6:
 327               		.cfi_def_cfa_offset 3
 328               		.cfi_offset 15, -2
 329 0002 0F93      		push r16
 330               	.LCFI7:
 331               		.cfi_def_cfa_offset 4
 332               		.cfi_offset 16, -3
 333 0004 1F93      		push r17
 334               	.LCFI8:
 335               		.cfi_def_cfa_offset 5
 336               		.cfi_offset 17, -4
 337 0006 CF93      		push r28
 338               	.LCFI9:
 339               		.cfi_def_cfa_offset 6
 340               		.cfi_offset 28, -5
 341 0008 DF93      		push r29
 342               	.LCFI10:
 343               		.cfi_def_cfa_offset 7
 344               		.cfi_offset 29, -6
 345 000a CDB7      		in r28,__SP_L__
 346 000c DEB7      		in r29,__SP_H__
 347               	.LCFI11:
 348               		.cfi_def_cfa_register 28
 349 000e 2C97      		sbiw r28,12
 350               	.LCFI12:
 351               		.cfi_def_cfa_offset 19
 352 0010 0FB6      		in __tmp_reg__,__SREG__
 353 0012 F894      		cli
 354 0014 DEBF      		out __SP_H__,r29
 355 0016 0FBE      		out __SREG__,__tmp_reg__
 356 0018 CDBF      		out __SP_L__,r28
 357               	/* prologue: function */
 358               	/* frame size = 12 */
 359               	/* stack size = 17 */
 360               	.L__stack_usage = 17
 361 001a F82E      		mov r15,r24
 360:../../os/rt/src/chschd.c ****   thread_t *tp = __instance_get_currthread(currcore);
 362               		.loc 1 360 0
 363 001c 0091 0000 		lds r16,ch0+5
 364 0020 1091 0000 		lds r17,ch0+5+1
 365               	.LVL23:
 361:../../os/rt/src/chschd.c **** 
 362:../../os/rt/src/chschd.c ****   chDbgCheckClassS();
 363:../../os/rt/src/chschd.c **** 
 364:../../os/rt/src/chschd.c ****   if (TIME_INFINITE != timeout) {
 366               		.loc 1 364 0
 367 0024 6F3F      		cpi r22,-1
 368 0026 7607      		cpc r23,r22
 369               	.LVL24:
 370 0028 01F0      		breq .L28
 371               	.LBB79:
 365:../../os/rt/src/chschd.c ****     virtual_timer_t vt;
 366:../../os/rt/src/chschd.c **** 
 367:../../os/rt/src/chschd.c ****     chVTDoSetI(&vt, timeout, __sch_wakeup, (void *)tp);
 372               		.loc 1 367 0
 373 002a 9801      		movw r18,r16
 374 002c 40E0      		ldi r20,lo8(gs(__sch_wakeup))
 375 002e 50E0      		ldi r21,hi8(gs(__sch_wakeup))
 376 0030 CE01      		movw r24,r28
 377 0032 0196      		adiw r24,1
 378 0034 0E94 0000 		call chVTDoSetI
 379               	.LVL25:
 368:../../os/rt/src/chschd.c ****     chSchGoSleepS(newstate);
 380               		.loc 1 368 0
 381 0038 8F2D      		mov r24,r15
 382 003a 0E94 0000 		call chSchGoSleepS
 383               	.LVL26:
 369:../../os/rt/src/chschd.c ****     if (chVTIsArmedI(&vt)) {
 384               		.loc 1 369 0
 385 003e 8981      		ldd r24,Y+1
 386 0040 9A81      		ldd r25,Y+2
 387 0042 892B      		or r24,r25
 388 0044 01F0      		breq .L30
 370:../../os/rt/src/chschd.c ****       chVTDoResetI(&vt);
 389               		.loc 1 370 0
 390 0046 CE01      		movw r24,r28
 391 0048 0196      		adiw r24,1
 392 004a 0E94 0000 		call chVTDoResetI
 393               	.LVL27:
 394               	.L30:
 395               	.LBE79:
 371:../../os/rt/src/chschd.c ****     }
 372:../../os/rt/src/chschd.c ****   }
 373:../../os/rt/src/chschd.c ****   else {
 374:../../os/rt/src/chschd.c ****     chSchGoSleepS(newstate);
 375:../../os/rt/src/chschd.c ****   }
 376:../../os/rt/src/chschd.c **** 
 377:../../os/rt/src/chschd.c ****   return tp->u.rdymsg;
 378:../../os/rt/src/chschd.c **** }
 396               		.loc 1 378 0
 397 004e F801      		movw r30,r16
 398 0050 8289      		ldd r24,Z+18
 399 0052 9389      		ldd r25,Z+19
 400               	/* epilogue start */
 401 0054 2C96      		adiw r28,12
 402 0056 0FB6      		in __tmp_reg__,__SREG__
 403 0058 F894      		cli
 404 005a DEBF      		out __SP_H__,r29
 405 005c 0FBE      		out __SREG__,__tmp_reg__
 406 005e CDBF      		out __SP_L__,r28
 407 0060 DF91      		pop r29
 408 0062 CF91      		pop r28
 409 0064 1F91      		pop r17
 410 0066 0F91      		pop r16
 411               	.LVL28:
 412 0068 FF90      		pop r15
 413               	.LVL29:
 414 006a 0895      		ret
 415               	.LVL30:
 416               	.L28:
 374:../../os/rt/src/chschd.c ****   }
 417               		.loc 1 374 0
 418 006c 8F2D      		mov r24,r15
 419 006e 0E94 0000 		call chSchGoSleepS
 420               	.LVL31:
 421 0072 00C0      		rjmp .L30
 422               		.cfi_endproc
 423               	.LFE202:
 425               		.section	.text.chSchWakeupS,"ax",@progbits
 426               	.global	chSchWakeupS
 428               	chSchWakeupS:
 429               	.LFB203:
 379:../../os/rt/src/chschd.c **** 
 380:../../os/rt/src/chschd.c **** /**
 381:../../os/rt/src/chschd.c ****  * @brief   Wakes up a thread.
 382:../../os/rt/src/chschd.c ****  * @details The thread is inserted into the ready list or immediately made
 383:../../os/rt/src/chschd.c ****  *          running depending on its relative priority compared to the current
 384:../../os/rt/src/chschd.c ****  *          thread.
 385:../../os/rt/src/chschd.c ****  * @pre     The thread must not be already inserted in any list through its
 386:../../os/rt/src/chschd.c ****  *          @p next and @p prev or list corruption would occur.
 387:../../os/rt/src/chschd.c ****  * @note    It is equivalent to a @p chSchReadyI() followed by a
 388:../../os/rt/src/chschd.c ****  *          @p chSchRescheduleS() but much more efficient.
 389:../../os/rt/src/chschd.c ****  * @note    The function assumes that the current thread has the highest
 390:../../os/rt/src/chschd.c ****  *          priority.
 391:../../os/rt/src/chschd.c ****  *
 392:../../os/rt/src/chschd.c ****  * @param[in] ntp       the thread to be made ready
 393:../../os/rt/src/chschd.c ****  * @param[in] msg       the wakeup message
 394:../../os/rt/src/chschd.c ****  *
 395:../../os/rt/src/chschd.c ****  * @sclass
 396:../../os/rt/src/chschd.c ****  */
 397:../../os/rt/src/chschd.c **** void chSchWakeupS(thread_t *ntp, msg_t msg) {
 430               		.loc 1 397 0
 431               		.cfi_startproc
 432               	.LVL32:
 433 0000 CF93      		push r28
 434               	.LCFI13:
 435               		.cfi_def_cfa_offset 3
 436               		.cfi_offset 28, -2
 437 0002 DF93      		push r29
 438               	.LCFI14:
 439               		.cfi_def_cfa_offset 4
 440               		.cfi_offset 29, -3
 441               	/* prologue: function */
 442               	/* frame size = 0 */
 443               	/* stack size = 2 */
 444               	.L__stack_usage = 2
 445 0004 DC01      		movw r26,r24
 446               	.LVL33:
 398:../../os/rt/src/chschd.c ****   os_instance_t *oip = currcore;
 399:../../os/rt/src/chschd.c ****   thread_t *otp = __instance_get_currthread(oip);
 447               		.loc 1 399 0
 448 0006 C091 0000 		lds r28,ch0+5
 449 000a D091 0000 		lds r29,ch0+5+1
 450               	.LVL34:
 400:../../os/rt/src/chschd.c **** 
 401:../../os/rt/src/chschd.c ****   chDbgCheckClassS();
 402:../../os/rt/src/chschd.c **** 
 403:../../os/rt/src/chschd.c ****   chDbgAssert((oip->rlist.pqueue.next == &oip->rlist.pqueue) ||
 404:../../os/rt/src/chschd.c ****               (oip->rlist.current->hdr.pqueue.prio >= oip->rlist.pqueue.next->prio),
 405:../../os/rt/src/chschd.c ****               "priority order violation");
 406:../../os/rt/src/chschd.c **** 
 407:../../os/rt/src/chschd.c ****   /* Storing the message to be retrieved by the target thread when it will
 408:../../os/rt/src/chschd.c ****      restart execution.*/
 409:../../os/rt/src/chschd.c ****   ntp->u.rdymsg = msg;
 451               		.loc 1 409 0
 452 000e 5396      		adiw r26,18+1
 453 0010 7C93      		st X,r23
 454 0012 6E93      		st -X,r22
 455 0014 5297      		sbiw r26,18
 410:../../os/rt/src/chschd.c **** 
 411:../../os/rt/src/chschd.c **** #if CH_CFG_SMP_MODE == TRUE
 412:../../os/rt/src/chschd.c ****   if (ntp->owner != oip) {
 413:../../os/rt/src/chschd.c ****     /* Readying up the remote thread and triggering a reschedule on
 414:../../os/rt/src/chschd.c ****        the other core.*/
 415:../../os/rt/src/chschd.c ****     chSysNotifyInstance(ntp->owner);
 416:../../os/rt/src/chschd.c ****     (void) __sch_ready_behind(ntp);
 417:../../os/rt/src/chschd.c ****     return;
 418:../../os/rt/src/chschd.c ****   }
 419:../../os/rt/src/chschd.c **** #endif
 420:../../os/rt/src/chschd.c **** 
 421:../../os/rt/src/chschd.c ****   /* If the woken thread has a not-greater priority than the current
 422:../../os/rt/src/chschd.c ****      one then it is just inserted in the ready list else it made
 423:../../os/rt/src/chschd.c ****      running immediately and the invoking thread goes in the ready
 424:../../os/rt/src/chschd.c ****      list instead.
 425:../../os/rt/src/chschd.c ****      Note, we are favoring the path where the woken thread has higher
 426:../../os/rt/src/chschd.c ****      priority.*/
 427:../../os/rt/src/chschd.c ****   if (unlikely(ntp->hdr.pqueue.prio <= otp->hdr.pqueue.prio)) {
 456               		.loc 1 427 0
 457 0016 1496      		adiw r26,4
 458 0018 2C91      		ld r18,X
 459 001a 1497      		sbiw r26,4
 460 001c 9C81      		ldd r25,Y+4
 461 001e 9217      		cp r25,r18
 462 0020 00F0      		brlo .L35
 463               	.LVL35:
 464               	.LBB80:
 465               	.LBB81:
  77:../../os/rt/src/chschd.c **** 
 466               		.loc 1 77 0
 467 0022 1F96      		adiw r26,15
 468 0024 1C92      		st X,__zero_reg__
 469 0026 1F97      		sbiw r26,15
  80:../../os/rt/src/chschd.c ****                                            &tp->hdr.pqueue));
 470               		.loc 1 80 0
 471 0028 1B96      		adiw r26,11
 472 002a ED91      		ld r30,X+
 473 002c FC91      		ld r31,X
 474 002e 1C97      		sbiw r26,11+1
 475               	.LVL36:
 476               	.L36:
 477               	.LBB82:
 478               	.LBB83:
 378:../../os/rt/include/chlists.h ****   } while (unlikely(pqp->prio >= p->prio));
 479               		.loc 2 378 0
 480 0030 0190      		ld __tmp_reg__,Z+
 481 0032 F081      		ld r31,Z
 482 0034 E02D      		mov r30,__tmp_reg__
 483               	.LVL37:
 379:../../os/rt/include/chlists.h **** 
 484               		.loc 2 379 0
 485 0036 8481      		ldd r24,Z+4
 486 0038 8217      		cp r24,r18
 487 003a 00F4      		brsh .L36
 382:../../os/rt/include/chlists.h ****   p->prev       = pqp->prev;
 488               		.loc 2 382 0
 489 003c 1196      		adiw r26,1
 490 003e FC93      		st X,r31
 491 0040 EE93      		st -X,r30
 383:../../os/rt/include/chlists.h ****   p->prev->next = p;
 492               		.loc 2 383 0
 493 0042 C281      		ldd r28,Z+2
 494 0044 D381      		ldd r29,Z+3
 495               	.LVL38:
 496 0046 1396      		adiw r26,2+1
 497 0048 DC93      		st X,r29
 498 004a CE93      		st -X,r28
 499 004c 1297      		sbiw r26,2
 384:../../os/rt/include/chlists.h ****   pqp->prev     = p;
 500               		.loc 2 384 0
 501 004e B983      		std Y+1,r27
 502 0050 A883      		st Y,r26
 503               		.loc 2 385 0
 504 0052 B383      		std Z+3,r27
 505 0054 A283      		std Z+2,r26
 506               	.LVL39:
 507               	/* epilogue start */
 508               	.LBE83:
 509               	.LBE82:
 510               	.LBE81:
 511               	.LBE80:
 428:../../os/rt/src/chschd.c ****     (void) __sch_ready_behind(ntp);
 429:../../os/rt/src/chschd.c ****   }
 430:../../os/rt/src/chschd.c ****   else {
 431:../../os/rt/src/chschd.c ****     /* The old thread goes back in the ready list ahead of its peers
 432:../../os/rt/src/chschd.c ****        because it has not exhausted its time slice.*/
 433:../../os/rt/src/chschd.c ****     otp = __sch_ready_ahead(otp);
 434:../../os/rt/src/chschd.c **** 
 435:../../os/rt/src/chschd.c ****     /* Handling idle-leave hook.*/
 436:../../os/rt/src/chschd.c ****     if (otp->hdr.pqueue.prio == IDLEPRIO) {
 437:../../os/rt/src/chschd.c ****       CH_CFG_IDLE_LEAVE_HOOK();
 438:../../os/rt/src/chschd.c ****     }
 439:../../os/rt/src/chschd.c **** 
 440:../../os/rt/src/chschd.c ****     /* The extracted thread is marked as current.*/
 441:../../os/rt/src/chschd.c ****     ntp->state = CH_STATE_CURRENT;
 442:../../os/rt/src/chschd.c ****     __instance_set_currthread(oip, ntp);
 443:../../os/rt/src/chschd.c **** 
 444:../../os/rt/src/chschd.c ****     /* Swap operation as tail call.*/
 445:../../os/rt/src/chschd.c ****     chSysSwitch(ntp, otp);
 446:../../os/rt/src/chschd.c ****   }
 447:../../os/rt/src/chschd.c **** }
 512               		.loc 1 447 0
 513 0056 DF91      		pop r29
 514 0058 CF91      		pop r28
 515 005a 0895      		ret
 516               	.LVL40:
 517               	.L35:
 518               	.LBB84:
 519               	.LBB85:
 110:../../os/rt/src/chschd.c **** 
 520               		.loc 1 110 0
 521 005c 1F86      		std Y+15,__zero_reg__
 113:../../os/rt/src/chschd.c ****                                           &tp->hdr.pqueue));
 522               		.loc 1 113 0
 523 005e EB85      		ldd r30,Y+11
 524 0060 FC85      		ldd r31,Y+12
 525               	.LVL41:
 526               	.L38:
 527               	.LBB86:
 528               	.LBB87:
 386:../../os/rt/include/chlists.h **** 
 387:../../os/rt/include/chlists.h ****   return p;
 388:../../os/rt/include/chlists.h **** }
 389:../../os/rt/include/chlists.h **** 
 390:../../os/rt/include/chlists.h **** /**
 391:../../os/rt/include/chlists.h ****  * @brief   Inserts an element in the priority queue placing it ahead of
 392:../../os/rt/include/chlists.h ****  *          its peers.
 393:../../os/rt/include/chlists.h ****  * @details The element is positioned ahead of all elements with higher or
 394:../../os/rt/include/chlists.h ****  *          equal priority.
 395:../../os/rt/include/chlists.h ****  *
 396:../../os/rt/include/chlists.h ****  * @param[in] pqp       the pointer to the priority queue list header
 397:../../os/rt/include/chlists.h ****  * @param[in] p         the pointer to the element to be inserted in the queue
 398:../../os/rt/include/chlists.h ****  * @return              The inserted element pointer.
 399:../../os/rt/include/chlists.h ****  *
 400:../../os/rt/include/chlists.h ****  * @notapi
 401:../../os/rt/include/chlists.h ****  */
 402:../../os/rt/include/chlists.h **** static inline ch_priority_queue_t *ch_pqueue_insert_ahead(ch_priority_queue_t *pqp,
 403:../../os/rt/include/chlists.h ****                                                           ch_priority_queue_t *p) {
 404:../../os/rt/include/chlists.h **** 
 405:../../os/rt/include/chlists.h ****   /* Scanning priority queue, the list is assumed to be mostly empty.*/
 406:../../os/rt/include/chlists.h ****   do {
 407:../../os/rt/include/chlists.h ****     pqp = pqp->next;
 529               		.loc 2 407 0
 530 0062 0190      		ld __tmp_reg__,Z+
 531 0064 F081      		ld r31,Z
 532 0066 E02D      		mov r30,__tmp_reg__
 533               	.LVL42:
 408:../../os/rt/include/chlists.h ****   } while (unlikely(pqp->prio > p->prio));
 534               		.loc 2 408 0
 535 0068 8481      		ldd r24,Z+4
 536 006a 9817      		cp r25,r24
 537 006c 00F0      		brlo .L38
 538 006e CD01      		movw r24,r26
 409:../../os/rt/include/chlists.h **** 
 410:../../os/rt/include/chlists.h ****   /* Insertion on prev.*/
 411:../../os/rt/include/chlists.h ****   p->next       = pqp;
 539               		.loc 2 411 0
 540 0070 F983      		std Y+1,r31
 541 0072 E883      		st Y,r30
 412:../../os/rt/include/chlists.h ****   p->prev       = pqp->prev;
 542               		.loc 2 412 0
 543 0074 A281      		ldd r26,Z+2
 544 0076 B381      		ldd r27,Z+3
 545               	.LVL43:
 546 0078 BB83      		std Y+3,r27
 547 007a AA83      		std Y+2,r26
 413:../../os/rt/include/chlists.h ****   p->prev->next = p;
 548               		.loc 2 413 0
 549 007c CD93      		st X+,r28
 550 007e DC93      		st X,r29
 414:../../os/rt/include/chlists.h ****   pqp->prev     = p;
 551               		.loc 2 414 0
 552 0080 D383      		std Z+3,r29
 553 0082 C283      		std Z+2,r28
 554               	.LVL44:
 555               	.LBE87:
 556               	.LBE86:
 557               	.LBE85:
 558               	.LBE84:
 441:../../os/rt/src/chschd.c ****     __instance_set_currthread(oip, ntp);
 559               		.loc 1 441 0
 560 0084 21E0      		ldi r18,lo8(1)
 561 0086 FC01      		movw r30,r24
 562 0088 2787      		std Z+15,r18
 442:../../os/rt/src/chschd.c **** 
 563               		.loc 1 442 0
 564 008a 9093 0000 		sts ch0+5+1,r25
 565 008e 8093 0000 		sts ch0+5,r24
 445:../../os/rt/src/chschd.c ****   }
 566               		.loc 1 445 0
 567 0092 BE01      		movw r22,r28
 568               	.LVL45:
 569 0094 0E94 0000 		call _port_switch
 570               	.LVL46:
 571               	/* epilogue start */
 572               		.loc 1 447 0
 573 0098 DF91      		pop r29
 574 009a CF91      		pop r28
 575 009c 0895      		ret
 576               		.cfi_endproc
 577               	.LFE203:
 579               		.section	.text.chSchIsPreemptionRequired,"ax",@progbits
 580               	.global	chSchIsPreemptionRequired
 582               	chSchIsPreemptionRequired:
 583               	.LFB205:
 448:../../os/rt/src/chschd.c **** 
 449:../../os/rt/src/chschd.c **** /**
 450:../../os/rt/src/chschd.c ****  * @brief   Performs a reschedule if a higher priority thread is runnable.
 451:../../os/rt/src/chschd.c ****  * @details If a thread with a higher priority than the current thread is in
 452:../../os/rt/src/chschd.c ****  *          the ready list then make the higher priority thread running.
 453:../../os/rt/src/chschd.c ****  * @note    Only local threads are considered, other cores are signaled
 454:../../os/rt/src/chschd.c ****  *          and perform a reschedule locally.
 455:../../os/rt/src/chschd.c ****  *
 456:../../os/rt/src/chschd.c ****  * @sclass
 457:../../os/rt/src/chschd.c ****  */
 458:../../os/rt/src/chschd.c **** void chSchRescheduleS(void) {
 459:../../os/rt/src/chschd.c ****   os_instance_t *oip = currcore;
 460:../../os/rt/src/chschd.c ****   thread_t *tp = __instance_get_currthread(oip);
 461:../../os/rt/src/chschd.c **** 
 462:../../os/rt/src/chschd.c ****   chDbgCheckClassS();
 463:../../os/rt/src/chschd.c **** 
 464:../../os/rt/src/chschd.c ****   /* Note, we are favoring the path where the reschedule is necessary
 465:../../os/rt/src/chschd.c ****      because higher priority threads are ready.*/
 466:../../os/rt/src/chschd.c ****   if (likely(firstprio(&oip->rlist.pqueue) > tp->hdr.pqueue.prio)) {
 467:../../os/rt/src/chschd.c ****     __sch_reschedule_ahead();
 468:../../os/rt/src/chschd.c ****   }
 469:../../os/rt/src/chschd.c **** }
 470:../../os/rt/src/chschd.c **** 
 471:../../os/rt/src/chschd.c **** #if !defined(CH_SCH_IS_PREEMPTION_REQUIRED_HOOKED)
 472:../../os/rt/src/chschd.c **** /**
 473:../../os/rt/src/chschd.c ****  * @brief   Evaluates if preemption is required.
 474:../../os/rt/src/chschd.c ****  * @details The decision is taken by comparing the relative priorities and
 475:../../os/rt/src/chschd.c ****  *          depending on the state of the round robin timeout counter.
 476:../../os/rt/src/chschd.c ****  * @note    Not a user function, it is meant to be invoked from within
 477:../../os/rt/src/chschd.c ****  *          the port layer in the IRQ-related preemption code.
 478:../../os/rt/src/chschd.c ****  *
 479:../../os/rt/src/chschd.c ****  * @retval true         if there is a thread that must go in running state
 480:../../os/rt/src/chschd.c ****  *                      immediately.
 481:../../os/rt/src/chschd.c ****  * @retval false        if preemption is not required.
 482:../../os/rt/src/chschd.c ****  *
 483:../../os/rt/src/chschd.c ****  * @special
 484:../../os/rt/src/chschd.c ****  */
 485:../../os/rt/src/chschd.c **** bool chSchIsPreemptionRequired(void) {
 584               		.loc 1 485 0
 585               		.cfi_startproc
 586               	/* prologue: function */
 587               	/* frame size = 0 */
 588               	/* stack size = 0 */
 589               	.L__stack_usage = 0
 590               	.LVL47:
 486:../../os/rt/src/chschd.c ****   os_instance_t *oip = currcore;
 487:../../os/rt/src/chschd.c ****   thread_t *tp = __instance_get_currthread(oip);
 488:../../os/rt/src/chschd.c **** 
 489:../../os/rt/src/chschd.c ****   tprio_t p1 = firstprio(&oip->rlist.pqueue);
 591               		.loc 1 489 0
 592 0000 A091 0000 		lds r26,ch0
 593 0004 B091 0000 		lds r27,ch0+1
 490:../../os/rt/src/chschd.c ****   tprio_t p2 = tp->hdr.pqueue.prio;
 594               		.loc 1 490 0
 595 0008 E091 0000 		lds r30,ch0+5
 596 000c F091 0000 		lds r31,ch0+5+1
 491:../../os/rt/src/chschd.c **** 
 492:../../os/rt/src/chschd.c **** #if CH_CFG_TIME_QUANTUM > 0
 493:../../os/rt/src/chschd.c ****   /* If the running thread has not reached its time quantum, reschedule only
 494:../../os/rt/src/chschd.c ****      if the first thread on the ready queue has a higher priority.
 495:../../os/rt/src/chschd.c ****      Otherwise, if the running thread has used up its time quantum, reschedule
 496:../../os/rt/src/chschd.c ****      if the first thread on the ready queue has equal or higher priority.*/
 497:../../os/rt/src/chschd.c ****   return (tp->ticks > (tslices_t)0) ? (p1 > p2) : (p1 >= p2);
 498:../../os/rt/src/chschd.c **** #else
 499:../../os/rt/src/chschd.c ****   /* If the round robin preemption feature is not enabled then performs a
 500:../../os/rt/src/chschd.c ****      simpler comparison.*/
 501:../../os/rt/src/chschd.c ****   return p1 > p2;
 597               		.loc 1 501 0
 598 0010 81E0      		ldi r24,lo8(1)
 599 0012 1496      		adiw r26,4
 600 0014 2C91      		ld r18,X
 601 0016 9481      		ldd r25,Z+4
 602 0018 9217      		cp r25,r18
 603 001a 00F0      		brlo .L42
 604 001c 80E0      		ldi r24,0
 605               	.L42:
 606               	/* epilogue start */
 502:../../os/rt/src/chschd.c **** #endif
 503:../../os/rt/src/chschd.c **** }
 607               		.loc 1 503 0
 608 001e 0895      		ret
 609               		.cfi_endproc
 610               	.LFE205:
 612               		.section	.text.chSchDoPreemption,"ax",@progbits
 613               	.global	chSchDoPreemption
 615               	chSchDoPreemption:
 616               	.LFB206:
 504:../../os/rt/src/chschd.c **** #endif /* !defined(CH_SCH_IS_PREEMPTION_REQUIRED_HOOKED) */
 505:../../os/rt/src/chschd.c **** 
 506:../../os/rt/src/chschd.c **** #if !defined(CH_SCH_DO_PREEMPTION_HOOKED)
 507:../../os/rt/src/chschd.c **** /**
 508:../../os/rt/src/chschd.c ****  * @brief   Switches to the first thread on the runnable queue.
 509:../../os/rt/src/chschd.c ****  * @details The current thread is positioned in the ready list behind or
 510:../../os/rt/src/chschd.c ****  *          ahead of all threads having the same priority depending on
 511:../../os/rt/src/chschd.c ****  *          if it used its whole time slice.
 512:../../os/rt/src/chschd.c ****  * @note    Not a user function, it is meant to be invoked from within
 513:../../os/rt/src/chschd.c ****  *          the port layer in the IRQ-related preemption code.
 514:../../os/rt/src/chschd.c ****  *
 515:../../os/rt/src/chschd.c ****  * @special
 516:../../os/rt/src/chschd.c ****  */
 517:../../os/rt/src/chschd.c **** void chSchDoPreemption(void) {
 617               		.loc 1 517 0
 618               		.cfi_startproc
 619 0000 CF93      		push r28
 620               	.LCFI15:
 621               		.cfi_def_cfa_offset 3
 622               		.cfi_offset 28, -2
 623 0002 DF93      		push r29
 624               	.LCFI16:
 625               		.cfi_def_cfa_offset 4
 626               		.cfi_offset 29, -3
 627               	/* prologue: function */
 628               	/* frame size = 0 */
 629               	/* stack size = 2 */
 630               	.L__stack_usage = 2
 631               	.LVL48:
 518:../../os/rt/src/chschd.c ****   os_instance_t *oip = currcore;
 519:../../os/rt/src/chschd.c ****   thread_t *otp = __instance_get_currthread(oip);
 632               		.loc 1 519 0
 633 0004 A091 0000 		lds r26,ch0+5
 634 0008 B091 0000 		lds r27,ch0+5+1
 635               	.LVL49:
 636               	.LBB88:
 637               	.LBB89:
 353:../../os/rt/include/chlists.h **** 
 638               		.loc 2 353 0
 639 000c 4091 0000 		lds r20,ch0
 640 0010 5091 0000 		lds r21,ch0+1
 641               	.LVL50:
 355:../../os/rt/include/chlists.h ****   pqp->next->prev = pqp;
 642               		.loc 2 355 0
 643 0014 EA01      		movw r28,r20
 644 0016 E881      		ld r30,Y
 645 0018 F981      		ldd r31,Y+1
 646 001a F093 0000 		sts ch0+1,r31
 647 001e E093 0000 		sts ch0,r30
 356:../../os/rt/include/chlists.h **** 
 648               		.loc 2 356 0
 649 0022 80E0      		ldi r24,lo8(ch0)
 650 0024 90E0      		ldi r25,hi8(ch0)
 651 0026 9383      		std Z+3,r25
 652 0028 8283      		std Z+2,r24
 653               	.LVL51:
 654               	.LBE89:
 655               	.LBE88:
 520:../../os/rt/src/chschd.c ****   thread_t *ntp;
 521:../../os/rt/src/chschd.c **** 
 522:../../os/rt/src/chschd.c ****   /* Picks the first thread from the ready queue and makes it current.*/
 523:../../os/rt/src/chschd.c ****   ntp = threadref(ch_pqueue_remove_highest(&oip->rlist.pqueue));
 524:../../os/rt/src/chschd.c ****   ntp->state = CH_STATE_CURRENT;
 656               		.loc 1 524 0
 657 002a 81E0      		ldi r24,lo8(1)
 658 002c 8F87      		std Y+15,r24
 525:../../os/rt/src/chschd.c ****   __instance_set_currthread(oip, ntp);
 659               		.loc 1 525 0
 660 002e 5093 0000 		sts ch0+5+1,r21
 661 0032 4093 0000 		sts ch0+5,r20
 662               	.LVL52:
 663               	.LBB90:
 664               	.LBB91:
 110:../../os/rt/src/chschd.c **** 
 665               		.loc 1 110 0
 666 0036 1F96      		adiw r26,15
 667 0038 1C92      		st X,__zero_reg__
 668 003a 1F97      		sbiw r26,15
 113:../../os/rt/src/chschd.c ****                                           &tp->hdr.pqueue));
 669               		.loc 1 113 0
 670 003c 1B96      		adiw r26,11
 671 003e ED91      		ld r30,X+
 672 0040 FC91      		ld r31,X
 673 0042 1C97      		sbiw r26,11+1
 674               	.LVL53:
 675               	.LBB92:
 676               	.LBB93:
 408:../../os/rt/include/chlists.h **** 
 677               		.loc 2 408 0
 678 0044 1496      		adiw r26,4
 679 0046 2C91      		ld r18,X
 680 0048 1497      		sbiw r26,4
 681               	.L44:
 407:../../os/rt/include/chlists.h ****   } while (unlikely(pqp->prio > p->prio));
 682               		.loc 2 407 0
 683 004a 0190      		ld __tmp_reg__,Z+
 684 004c F081      		ld r31,Z
 685 004e E02D      		mov r30,__tmp_reg__
 686               	.LVL54:
 408:../../os/rt/include/chlists.h **** 
 687               		.loc 2 408 0
 688 0050 9481      		ldd r25,Z+4
 689 0052 2917      		cp r18,r25
 690 0054 00F0      		brlo .L44
 411:../../os/rt/include/chlists.h ****   p->prev       = pqp->prev;
 691               		.loc 2 411 0
 692 0056 1196      		adiw r26,1
 693 0058 FC93      		st X,r31
 694 005a EE93      		st -X,r30
 412:../../os/rt/include/chlists.h ****   p->prev->next = p;
 695               		.loc 2 412 0
 696 005c 8281      		ldd r24,Z+2
 697 005e 9381      		ldd r25,Z+3
 698 0060 1396      		adiw r26,2+1
 699 0062 9C93      		st X,r25
 700 0064 8E93      		st -X,r24
 701 0066 1297      		sbiw r26,2
 413:../../os/rt/include/chlists.h ****   pqp->prev     = p;
 702               		.loc 2 413 0
 703 0068 EC01      		movw r28,r24
 704 006a B983      		std Y+1,r27
 705 006c A883      		st Y,r26
 706               		.loc 2 414 0
 707 006e B383      		std Z+3,r27
 708 0070 A283      		std Z+2,r26
 709               	.LVL55:
 710               	.LBE93:
 711               	.LBE92:
 712               	.LBE91:
 713               	.LBE90:
 526:../../os/rt/src/chschd.c **** 
 527:../../os/rt/src/chschd.c ****   /* Handling idle-leave hook.*/
 528:../../os/rt/src/chschd.c ****   if (otp->hdr.pqueue.prio == IDLEPRIO) {
 529:../../os/rt/src/chschd.c ****     CH_CFG_IDLE_LEAVE_HOOK();
 530:../../os/rt/src/chschd.c ****   }
 531:../../os/rt/src/chschd.c **** 
 532:../../os/rt/src/chschd.c **** #if CH_CFG_TIME_QUANTUM > 0
 533:../../os/rt/src/chschd.c ****   /* If CH_CFG_TIME_QUANTUM is enabled then there are two different scenarios
 534:../../os/rt/src/chschd.c ****      to handle on preemption: time quantum elapsed or not.*/
 535:../../os/rt/src/chschd.c ****   if (otp->ticks == (tslices_t)0) {
 536:../../os/rt/src/chschd.c **** 
 537:../../os/rt/src/chschd.c ****     /* The thread consumed its time quantum so it is enqueued behind threads
 538:../../os/rt/src/chschd.c ****        with same priority level, however, it acquires a new time quantum.*/
 539:../../os/rt/src/chschd.c ****     otp = __sch_ready_behind(otp);
 540:../../os/rt/src/chschd.c **** 
 541:../../os/rt/src/chschd.c ****     /* The thread being swapped out receives a new time quantum.*/
 542:../../os/rt/src/chschd.c ****     otp->ticks = (tslices_t)CH_CFG_TIME_QUANTUM;
 543:../../os/rt/src/chschd.c ****   }
 544:../../os/rt/src/chschd.c ****   else {
 545:../../os/rt/src/chschd.c ****     /* The thread didn't consume all its time quantum so it is put ahead of
 546:../../os/rt/src/chschd.c ****        threads with equal priority and does not acquire a new time quantum.*/
 547:../../os/rt/src/chschd.c ****     otp = __sch_ready_ahead(otp);
 548:../../os/rt/src/chschd.c ****   }
 549:../../os/rt/src/chschd.c **** #else /* !(CH_CFG_TIME_QUANTUM > 0) */
 550:../../os/rt/src/chschd.c ****   /* If the round-robin mechanism is disabled then the thread goes always
 551:../../os/rt/src/chschd.c ****      ahead of its peers.*/
 552:../../os/rt/src/chschd.c ****   otp = __sch_ready_ahead(otp);
 553:../../os/rt/src/chschd.c **** #endif /* !(CH_CFG_TIME_QUANTUM > 0) */
 554:../../os/rt/src/chschd.c **** 
 555:../../os/rt/src/chschd.c ****   /* Swap operation as tail call.*/
 556:../../os/rt/src/chschd.c ****   chSysSwitch(ntp, otp);
 714               		.loc 1 556 0
 715 0072 BD01      		movw r22,r26
 716 0074 CA01      		movw r24,r20
 717 0076 0E94 0000 		call _port_switch
 718               	.LVL56:
 719               	/* epilogue start */
 557:../../os/rt/src/chschd.c **** }
 720               		.loc 1 557 0
 721 007a DF91      		pop r29
 722 007c CF91      		pop r28
 723 007e 0895      		ret
 724               		.cfi_endproc
 725               	.LFE206:
 727               		.set	__sch_reschedule_ahead,chSchDoPreemption
 728               		.section	.text.chSchRescheduleS,"ax",@progbits
 729               	.global	chSchRescheduleS
 731               	chSchRescheduleS:
 732               	.LFB204:
 458:../../os/rt/src/chschd.c ****   os_instance_t *oip = currcore;
 733               		.loc 1 458 0
 734               		.cfi_startproc
 735               	/* prologue: function */
 736               	/* frame size = 0 */
 737               	/* stack size = 0 */
 738               	.L__stack_usage = 0
 739               	.LVL57:
 466:../../os/rt/src/chschd.c ****     __sch_reschedule_ahead();
 740               		.loc 1 466 0
 741 0000 A091 0000 		lds r26,ch0
 742 0004 B091 0000 		lds r27,ch0+1
 743 0008 E091 0000 		lds r30,ch0+5
 744 000c F091 0000 		lds r31,ch0+5+1
 745 0010 1496      		adiw r26,4
 746 0012 9C91      		ld r25,X
 747 0014 8481      		ldd r24,Z+4
 748 0016 8917      		cp r24,r25
 749 0018 00F0      		brlo .L48
 750               	/* epilogue start */
 469:../../os/rt/src/chschd.c **** 
 751               		.loc 1 469 0
 752 001a 0895      		ret
 753               	.L48:
 467:../../os/rt/src/chschd.c ****   }
 754               		.loc 1 467 0
 755 001c 0C94 0000 		jmp __sch_reschedule_ahead
 756               	.LVL58:
 757               		.cfi_endproc
 758               	.LFE204:
 760               		.section	.text.chSchPreemption,"ax",@progbits
 761               	.global	chSchPreemption
 763               	chSchPreemption:
 764               	.LFB213:
 765               		.cfi_startproc
 766               	/* prologue: function */
 767               	/* frame size = 0 */
 768               	/* stack size = 0 */
 769               	.L__stack_usage = 0
 770 0000 0C94 0000 		jmp chSchRescheduleS
 771               		.cfi_endproc
 772               	.LFE213:
 774               		.section	.text.chSchDoYieldS,"ax",@progbits
 775               	.global	chSchDoYieldS
 777               	chSchDoYieldS:
 778               	.LFB208:
 558:../../os/rt/src/chschd.c **** #endif /* !defined(CH_SCH_DO_PREEMPTION_HOOKED) */
 559:../../os/rt/src/chschd.c **** 
 560:../../os/rt/src/chschd.c **** #if !defined(CH_SCH_PREEMPTION_HOOKED)
 561:../../os/rt/src/chschd.c **** /**
 562:../../os/rt/src/chschd.c ****  * @brief   All-in-one preemption code.
 563:../../os/rt/src/chschd.c ****  * @note    Not a user function, it is meant to be invoked from within
 564:../../os/rt/src/chschd.c ****  *          the port layer in the IRQ-related preemption code.
 565:../../os/rt/src/chschd.c ****  *
 566:../../os/rt/src/chschd.c ****  * @special
 567:../../os/rt/src/chschd.c ****  */
 568:../../os/rt/src/chschd.c **** void chSchPreemption(void) {
 569:../../os/rt/src/chschd.c ****   os_instance_t *oip = currcore;
 570:../../os/rt/src/chschd.c ****   thread_t *tp = __instance_get_currthread(oip);
 571:../../os/rt/src/chschd.c ****   tprio_t p1 = firstprio(&oip->rlist.pqueue);
 572:../../os/rt/src/chschd.c ****   tprio_t p2 = tp->hdr.pqueue.prio;
 573:../../os/rt/src/chschd.c **** 
 574:../../os/rt/src/chschd.c ****   /* Note, we are favoring the path where preemption is necessary
 575:../../os/rt/src/chschd.c ****      because higher priority threads are ready.*/
 576:../../os/rt/src/chschd.c **** #if CH_CFG_TIME_QUANTUM > 0
 577:../../os/rt/src/chschd.c ****   if (tp->ticks > (tslices_t)0) {
 578:../../os/rt/src/chschd.c ****     if (likely(p1 > p2)) {
 579:../../os/rt/src/chschd.c ****       __sch_reschedule_ahead();
 580:../../os/rt/src/chschd.c ****     }
 581:../../os/rt/src/chschd.c ****   }
 582:../../os/rt/src/chschd.c ****   else {
 583:../../os/rt/src/chschd.c ****     if (likely(p1 >= p2)) {
 584:../../os/rt/src/chschd.c ****       __sch_reschedule_behind();
 585:../../os/rt/src/chschd.c ****     }
 586:../../os/rt/src/chschd.c ****   }
 587:../../os/rt/src/chschd.c **** #else /* CH_CFG_TIME_QUANTUM == 0 */
 588:../../os/rt/src/chschd.c ****   if (likely(p1 > p2)) {
 589:../../os/rt/src/chschd.c ****     __sch_reschedule_ahead();
 590:../../os/rt/src/chschd.c ****   }
 591:../../os/rt/src/chschd.c **** #endif /* CH_CFG_TIME_QUANTUM == 0 */
 592:../../os/rt/src/chschd.c **** }
 593:../../os/rt/src/chschd.c **** #endif /* !defined(CH_SCH_PREEMPTION_HOOKED) */
 594:../../os/rt/src/chschd.c **** 
 595:../../os/rt/src/chschd.c **** /**
 596:../../os/rt/src/chschd.c ****  * @brief   Yields the time slot.
 597:../../os/rt/src/chschd.c ****  * @details Yields the CPU control to the next thread in the ready list with
 598:../../os/rt/src/chschd.c ****  *          equal or higher priority, if any.
 599:../../os/rt/src/chschd.c ****  *
 600:../../os/rt/src/chschd.c ****  * @sclass
 601:../../os/rt/src/chschd.c ****  */
 602:../../os/rt/src/chschd.c **** void chSchDoYieldS(void) {
 779               		.loc 1 602 0
 780               		.cfi_startproc
 781               		.loc 1 602 0
 782 0000 CF93      		push r28
 783               	.LCFI17:
 784               		.cfi_def_cfa_offset 3
 785               		.cfi_offset 28, -2
 786 0002 DF93      		push r29
 787               	.LCFI18:
 788               		.cfi_def_cfa_offset 4
 789               		.cfi_offset 29, -3
 790               	/* prologue: function */
 791               	/* frame size = 0 */
 792               	/* stack size = 2 */
 793               	.L__stack_usage = 2
 794               	.LVL59:
 603:../../os/rt/src/chschd.c ****   os_instance_t *oip = currcore;
 604:../../os/rt/src/chschd.c ****   thread_t *tp = __instance_get_currthread(oip);
 795               		.loc 1 604 0
 796 0004 A091 0000 		lds r26,ch0+5
 797 0008 B091 0000 		lds r27,ch0+5+1
 798               	.LVL60:
 605:../../os/rt/src/chschd.c **** 
 606:../../os/rt/src/chschd.c ****   chDbgCheckClassS();
 607:../../os/rt/src/chschd.c **** 
 608:../../os/rt/src/chschd.c ****   /* If this function has been called then it is likely there are threads
 609:../../os/rt/src/chschd.c ****      at same priority level.*/
 610:../../os/rt/src/chschd.c ****   if (likely(firstprio(&oip->rlist.pqueue) >= tp->hdr.pqueue.prio)) {
 799               		.loc 1 610 0
 800 000c 2091 0000 		lds r18,ch0
 801 0010 3091 0000 		lds r19,ch0+1
 802 0014 E901      		movw r28,r18
 803 0016 9C81      		ldd r25,Y+4
 804 0018 1496      		adiw r26,4
 805 001a 8C91      		ld r24,X
 806 001c 1497      		sbiw r26,4
 807 001e 9817      		cp r25,r24
 808 0020 00F4      		brsh .L54
 809               	/* epilogue start */
 611:../../os/rt/src/chschd.c ****     __sch_reschedule_behind();
 612:../../os/rt/src/chschd.c ****   }
 613:../../os/rt/src/chschd.c **** }
 810               		.loc 1 613 0
 811 0022 DF91      		pop r29
 812 0024 CF91      		pop r28
 813 0026 0895      		ret
 814               	.L54:
 815               	.LVL61:
 816               	.LBB102:
 817               	.LBB103:
 818               	.LBB104:
 819               	.LBB105:
 355:../../os/rt/include/chlists.h ****   pqp->next->prev = pqp;
 820               		.loc 2 355 0
 821 0028 E881      		ld r30,Y
 822 002a F981      		ldd r31,Y+1
 823 002c F093 0000 		sts ch0+1,r31
 824 0030 E093 0000 		sts ch0,r30
 356:../../os/rt/include/chlists.h **** 
 825               		.loc 2 356 0
 826 0034 80E0      		ldi r24,lo8(ch0)
 827 0036 90E0      		ldi r25,hi8(ch0)
 828 0038 9383      		std Z+3,r25
 829 003a 8283      		std Z+2,r24
 830               	.LVL62:
 831               	.LBE105:
 832               	.LBE104:
 134:../../os/rt/src/chschd.c ****   __instance_set_currthread(oip, ntp);
 833               		.loc 1 134 0
 834 003c 81E0      		ldi r24,lo8(1)
 835 003e 8F87      		std Y+15,r24
 135:../../os/rt/src/chschd.c **** 
 836               		.loc 1 135 0
 837 0040 3093 0000 		sts ch0+5+1,r19
 838 0044 2093 0000 		sts ch0+5,r18
 839               	.LVL63:
 840               	.LBB106:
 841               	.LBB107:
  77:../../os/rt/src/chschd.c **** 
 842               		.loc 1 77 0
 843 0048 1F96      		adiw r26,15
 844 004a 1C92      		st X,__zero_reg__
 845 004c 1F97      		sbiw r26,15
  80:../../os/rt/src/chschd.c ****                                            &tp->hdr.pqueue));
 846               		.loc 1 80 0
 847 004e 1B96      		adiw r26,11
 848 0050 ED91      		ld r30,X+
 849 0052 FC91      		ld r31,X
 850 0054 1C97      		sbiw r26,11+1
 851               	.LVL64:
 852               	.LBB108:
 853               	.LBB109:
 379:../../os/rt/include/chlists.h **** 
 854               		.loc 2 379 0
 855 0056 1496      		adiw r26,4
 856 0058 8C91      		ld r24,X
 857 005a 1497      		sbiw r26,4
 858               	.L52:
 378:../../os/rt/include/chlists.h ****   } while (unlikely(pqp->prio >= p->prio));
 859               		.loc 2 378 0
 860 005c 0190      		ld __tmp_reg__,Z+
 861 005e F081      		ld r31,Z
 862 0060 E02D      		mov r30,__tmp_reg__
 863               	.LVL65:
 379:../../os/rt/include/chlists.h **** 
 864               		.loc 2 379 0
 865 0062 9481      		ldd r25,Z+4
 866 0064 9817      		cp r25,r24
 867 0066 00F4      		brsh .L52
 382:../../os/rt/include/chlists.h ****   p->prev       = pqp->prev;
 868               		.loc 2 382 0
 869 0068 1196      		adiw r26,1
 870 006a FC93      		st X,r31
 871 006c EE93      		st -X,r30
 383:../../os/rt/include/chlists.h ****   p->prev->next = p;
 872               		.loc 2 383 0
 873 006e 8281      		ldd r24,Z+2
 874 0070 9381      		ldd r25,Z+3
 875 0072 1396      		adiw r26,2+1
 876 0074 9C93      		st X,r25
 877 0076 8E93      		st -X,r24
 878 0078 1297      		sbiw r26,2
 384:../../os/rt/include/chlists.h ****   pqp->prev     = p;
 879               		.loc 2 384 0
 880 007a EC01      		movw r28,r24
 881 007c B983      		std Y+1,r27
 882 007e A883      		st Y,r26
 385:../../os/rt/include/chlists.h **** 
 883               		.loc 2 385 0
 884 0080 B383      		std Z+3,r27
 885 0082 A283      		std Z+2,r26
 886               	.LVL66:
 887               	.LBE109:
 888               	.LBE108:
 889               	.LBE107:
 890               	.LBE106:
 151:../../os/rt/src/chschd.c **** }
 891               		.loc 1 151 0
 892 0084 BD01      		movw r22,r26
 893 0086 C901      		movw r24,r18
 894 0088 0E94 0000 		call _port_switch
 895               	.LVL67:
 896               	/* epilogue start */
 897               	.LBE103:
 898               	.LBE102:
 899               		.loc 1 613 0
 900 008c DF91      		pop r29
 901 008e CF91      		pop r28
 902 0090 0895      		ret
 903               		.cfi_endproc
 904               	.LFE208:
 906               		.section	.text.chSchSelectFirst,"ax",@progbits
 907               	.global	chSchSelectFirst
 909               	chSchSelectFirst:
 910               	.LFB209:
 614:../../os/rt/src/chschd.c **** 
 615:../../os/rt/src/chschd.c **** /**
 616:../../os/rt/src/chschd.c ****  * @brief   Makes runnable the fist thread in the ready list, does not
 617:../../os/rt/src/chschd.c ****  *          reschedule internally.
 618:../../os/rt/src/chschd.c ****  * @details The current thread is positioned in the ready list ahead of all
 619:../../os/rt/src/chschd.c ****  *          threads having the same priority.
 620:../../os/rt/src/chschd.c ****  * @note    Not a user function, it is meant to be invoked by the scheduler
 621:../../os/rt/src/chschd.c ****  *          itself.
 622:../../os/rt/src/chschd.c ****  *
 623:../../os/rt/src/chschd.c ****  * @return              The pointer to the thread being switched in.
 624:../../os/rt/src/chschd.c ****  *
 625:../../os/rt/src/chschd.c ****  * @special
 626:../../os/rt/src/chschd.c ****  */
 627:../../os/rt/src/chschd.c **** thread_t *chSchSelectFirst(void) {
 911               		.loc 1 627 0
 912               		.cfi_startproc
 913 0000 CF93      		push r28
 914               	.LCFI19:
 915               		.cfi_def_cfa_offset 3
 916               		.cfi_offset 28, -2
 917 0002 DF93      		push r29
 918               	.LCFI20:
 919               		.cfi_def_cfa_offset 4
 920               		.cfi_offset 29, -3
 921               	/* prologue: function */
 922               	/* frame size = 0 */
 923               	/* stack size = 2 */
 924               	.L__stack_usage = 2
 925               	.LVL68:
 628:../../os/rt/src/chschd.c ****   os_instance_t *oip = currcore;
 629:../../os/rt/src/chschd.c ****   thread_t *otp = __instance_get_currthread(oip);
 926               		.loc 1 629 0
 927 0004 A091 0000 		lds r26,ch0+5
 928 0008 B091 0000 		lds r27,ch0+5+1
 929               	.LVL69:
 930               	.LBB110:
 931               	.LBB111:
 353:../../os/rt/include/chlists.h **** 
 932               		.loc 2 353 0
 933 000c 4091 0000 		lds r20,ch0
 934 0010 5091 0000 		lds r21,ch0+1
 935               	.LVL70:
 355:../../os/rt/include/chlists.h ****   pqp->next->prev = pqp;
 936               		.loc 2 355 0
 937 0014 EA01      		movw r28,r20
 938 0016 E881      		ld r30,Y
 939 0018 F981      		ldd r31,Y+1
 940 001a F093 0000 		sts ch0+1,r31
 941 001e E093 0000 		sts ch0,r30
 356:../../os/rt/include/chlists.h **** 
 942               		.loc 2 356 0
 943 0022 80E0      		ldi r24,lo8(ch0)
 944 0024 90E0      		ldi r25,hi8(ch0)
 945 0026 9383      		std Z+3,r25
 946 0028 8283      		std Z+2,r24
 947               	.LVL71:
 948               	.LBE111:
 949               	.LBE110:
 630:../../os/rt/src/chschd.c ****   thread_t *ntp;
 631:../../os/rt/src/chschd.c **** 
 632:../../os/rt/src/chschd.c ****   /* Picks the first thread from the ready queue and makes it current.*/
 633:../../os/rt/src/chschd.c ****   ntp = threadref(ch_pqueue_remove_highest(&oip->rlist.pqueue));
 634:../../os/rt/src/chschd.c ****   ntp->state = CH_STATE_CURRENT;
 950               		.loc 1 634 0
 951 002a 81E0      		ldi r24,lo8(1)
 952 002c 8F87      		std Y+15,r24
 635:../../os/rt/src/chschd.c ****   __instance_set_currthread(oip, ntp);
 953               		.loc 1 635 0
 954 002e 5093 0000 		sts ch0+5+1,r21
 955 0032 4093 0000 		sts ch0+5,r20
 956               	.LVL72:
 957               	.LBB112:
 958               	.LBB113:
 110:../../os/rt/src/chschd.c **** 
 959               		.loc 1 110 0
 960 0036 1F96      		adiw r26,15
 961 0038 1C92      		st X,__zero_reg__
 962 003a 1F97      		sbiw r26,15
 113:../../os/rt/src/chschd.c ****                                           &tp->hdr.pqueue));
 963               		.loc 1 113 0
 964 003c 1B96      		adiw r26,11
 965 003e ED91      		ld r30,X+
 966 0040 FC91      		ld r31,X
 967 0042 1C97      		sbiw r26,11+1
 968               	.LVL73:
 969               	.LBB114:
 970               	.LBB115:
 408:../../os/rt/include/chlists.h **** 
 971               		.loc 2 408 0
 972 0044 1496      		adiw r26,4
 973 0046 2C91      		ld r18,X
 974 0048 1497      		sbiw r26,4
 975               	.L56:
 407:../../os/rt/include/chlists.h ****   } while (unlikely(pqp->prio > p->prio));
 976               		.loc 2 407 0
 977 004a 0190      		ld __tmp_reg__,Z+
 978 004c F081      		ld r31,Z
 979 004e E02D      		mov r30,__tmp_reg__
 980               	.LVL74:
 408:../../os/rt/include/chlists.h **** 
 981               		.loc 2 408 0
 982 0050 9481      		ldd r25,Z+4
 983 0052 2917      		cp r18,r25
 984 0054 00F0      		brlo .L56
 411:../../os/rt/include/chlists.h ****   p->prev       = pqp->prev;
 985               		.loc 2 411 0
 986 0056 1196      		adiw r26,1
 987 0058 FC93      		st X,r31
 988 005a EE93      		st -X,r30
 412:../../os/rt/include/chlists.h ****   p->prev->next = p;
 989               		.loc 2 412 0
 990 005c 8281      		ldd r24,Z+2
 991 005e 9381      		ldd r25,Z+3
 992 0060 1396      		adiw r26,2+1
 993 0062 9C93      		st X,r25
 994 0064 8E93      		st -X,r24
 995 0066 1297      		sbiw r26,2
 413:../../os/rt/include/chlists.h ****   pqp->prev     = p;
 996               		.loc 2 413 0
 997 0068 EC01      		movw r28,r24
 998 006a B983      		std Y+1,r27
 999 006c A883      		st Y,r26
 1000               		.loc 2 414 0
 1001 006e B383      		std Z+3,r27
 1002 0070 A283      		std Z+2,r26
 1003               	.LVL75:
 1004               	.LBE115:
 1005               	.LBE114:
 1006               	.LBE113:
 1007               	.LBE112:
 636:../../os/rt/src/chschd.c **** 
 637:../../os/rt/src/chschd.c ****   /* Handling idle-leave hook.*/
 638:../../os/rt/src/chschd.c ****   if (otp->hdr.pqueue.prio == IDLEPRIO) {
 639:../../os/rt/src/chschd.c ****     CH_CFG_IDLE_LEAVE_HOOK();
 640:../../os/rt/src/chschd.c ****   }
 641:../../os/rt/src/chschd.c **** 
 642:../../os/rt/src/chschd.c ****   /* Placing in ready list ahead of peers.*/
 643:../../os/rt/src/chschd.c ****   (void) __sch_ready_ahead(otp);
 644:../../os/rt/src/chschd.c **** 
 645:../../os/rt/src/chschd.c ****   return ntp;
 646:../../os/rt/src/chschd.c **** }
 1008               		.loc 1 646 0
 1009 0072 CA01      		movw r24,r20
 1010               	/* epilogue start */
 1011 0074 DF91      		pop r29
 1012 0076 CF91      		pop r28
 1013 0078 0895      		ret
 1014               		.cfi_endproc
 1015               	.LFE209:
 1017               		.text
 1018               	.Letext0:
 1019               		.file 4 "/usr/lib/avr/include/stdint.h"
 1020               		.file 5 "../../os/common/ports/AVR/compilers/GCC/chtypes.h"
 1021               		.file 6 "../../os/rt/include/chearly.h"
 1022               		.file 7 "../../os/rt/include/chobjects.h"
 1023               		.file 8 "../../os/rt/include/chrfcu.h"
 1024               		.file 9 "../../os/rt/include/chdebug.h"
 1025               		.file 10 "../../os/rt/include/chtime.h"
 1026               		.file 11 "../../os/common/ports/AVR/chcore.h"
 1027               		.file 12 "../../os/rt/include/chmtx.h"
 1028               		.file 13 "../../os/rt/include/chsys.h"
 1029               		.file 14 "../../os/rt/include/chregistry.h"
 1030               		.file 15 "../../os/oslib/include/chmemcore.h"
 1031               		.file 16 "../../os/rt/include/chvt.h"
DEFINED SYMBOLS
                            *ABS*:0000000000000000 chschd.c
     /tmp/cc6sDpNi.s:2      *ABS*:000000000000003e __SP_H__
     /tmp/cc6sDpNi.s:3      *ABS*:000000000000003d __SP_L__
     /tmp/cc6sDpNi.s:4      *ABS*:000000000000003f __SREG__
     /tmp/cc6sDpNi.s:5      *ABS*:0000000000000000 __tmp_reg__
     /tmp/cc6sDpNi.s:6      *ABS*:0000000000000001 __zero_reg__
     /tmp/cc6sDpNi.s:12     .text.__sch_wakeup:0000000000000000 __sch_wakeup
     /tmp/cc6sDpNi.s:169    .text.chSchReadyI:0000000000000000 chSchReadyI
     /tmp/cc6sDpNi.s:251    .text.chSchGoSleepS:0000000000000000 chSchGoSleepS
     /tmp/cc6sDpNi.s:320    .text.chSchGoSleepTimeoutS:0000000000000000 chSchGoSleepTimeoutS
     /tmp/cc6sDpNi.s:428    .text.chSchWakeupS:0000000000000000 chSchWakeupS
     /tmp/cc6sDpNi.s:582    .text.chSchIsPreemptionRequired:0000000000000000 chSchIsPreemptionRequired
     /tmp/cc6sDpNi.s:615    .text.chSchDoPreemption:0000000000000000 chSchDoPreemption
     /tmp/cc6sDpNi.s:615    .text.chSchDoPreemption:0000000000000000 __sch_reschedule_ahead
     /tmp/cc6sDpNi.s:731    .text.chSchRescheduleS:0000000000000000 chSchRescheduleS
     /tmp/cc6sDpNi.s:763    .text.chSchPreemption:0000000000000000 chSchPreemption
     /tmp/cc6sDpNi.s:777    .text.chSchDoYieldS:0000000000000000 chSchDoYieldS
     /tmp/cc6sDpNi.s:909    .text.chSchSelectFirst:0000000000000000 chSchSelectFirst

UNDEFINED SYMBOLS
ch0
_port_switch
chVTDoSetI
chVTDoResetI
