   1               		.file	"chmtx.c"
   2               	__SP_H__ = 0x3e
   3               	__SP_L__ = 0x3d
   4               	__SREG__ = 0x3f
   5               	__tmp_reg__ = 0
   6               	__zero_reg__ = 1
   7               		.text
   8               	.Ltext0:
   9               		.cfi_sections	.debug_frame
  10               		.section	.text.chMtxObjectInit,"ax",@progbits
  11               	.global	chMtxObjectInit
  13               	chMtxObjectInit:
  14               	.LFB195:
  15               		.file 1 "../../os/rt/src/chmtx.c"
   1:../../os/rt/src/chmtx.c **** /*
   2:../../os/rt/src/chmtx.c ****     ChibiOS - Copyright (C) 2006,2007,2008,2009,2010,2011,2012,2013,2014,
   3:../../os/rt/src/chmtx.c ****               2015,2016,2017,2018,2019,2020,2021 Giovanni Di Sirio.
   4:../../os/rt/src/chmtx.c **** 
   5:../../os/rt/src/chmtx.c ****     This file is part of ChibiOS.
   6:../../os/rt/src/chmtx.c **** 
   7:../../os/rt/src/chmtx.c ****     ChibiOS is free software; you can redistribute it and/or modify
   8:../../os/rt/src/chmtx.c ****     it under the terms of the GNU General Public License as published by
   9:../../os/rt/src/chmtx.c ****     the Free Software Foundation version 3 of the License.
  10:../../os/rt/src/chmtx.c **** 
  11:../../os/rt/src/chmtx.c ****     ChibiOS is distributed in the hope that it will be useful,
  12:../../os/rt/src/chmtx.c ****     but WITHOUT ANY WARRANTY; without even the implied warranty of
  13:../../os/rt/src/chmtx.c ****     MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
  14:../../os/rt/src/chmtx.c ****     GNU General Public License for more details.
  15:../../os/rt/src/chmtx.c **** 
  16:../../os/rt/src/chmtx.c ****     You should have received a copy of the GNU General Public License
  17:../../os/rt/src/chmtx.c ****     along with this program.  If not, see <http://www.gnu.org/licenses/>.
  18:../../os/rt/src/chmtx.c **** */
  19:../../os/rt/src/chmtx.c **** 
  20:../../os/rt/src/chmtx.c **** /**
  21:../../os/rt/src/chmtx.c ****  * @file    rt/src/chmtx.c
  22:../../os/rt/src/chmtx.c ****  * @brief   Mutexes code.
  23:../../os/rt/src/chmtx.c ****  *
  24:../../os/rt/src/chmtx.c ****  * @addtogroup mutexes
  25:../../os/rt/src/chmtx.c ****  * @details Mutexes related APIs and services.
  26:../../os/rt/src/chmtx.c ****  *          <h2>Operation mode</h2>
  27:../../os/rt/src/chmtx.c ****  *          A mutex is a threads synchronization object that can be in two
  28:../../os/rt/src/chmtx.c ****  *          distinct states:
  29:../../os/rt/src/chmtx.c ****  *          - Not owned (unlocked).
  30:../../os/rt/src/chmtx.c ****  *          - Owned by a thread (locked).
  31:../../os/rt/src/chmtx.c ****  *          .
  32:../../os/rt/src/chmtx.c ****  *          Operations defined for mutexes:
  33:../../os/rt/src/chmtx.c ****  *          - <b>Lock</b>: The mutex is checked, if the mutex is not owned by
  34:../../os/rt/src/chmtx.c ****  *            some other thread then it is associated to the locking thread
  35:../../os/rt/src/chmtx.c ****  *            else the thread is queued on the mutex in a list ordered by
  36:../../os/rt/src/chmtx.c ****  *            priority.
  37:../../os/rt/src/chmtx.c ****  *          - <b>Unlock</b>: The mutex is released by the owner and the highest
  38:../../os/rt/src/chmtx.c ****  *            priority thread waiting in the queue, if any, is resumed and made
  39:../../os/rt/src/chmtx.c ****  *            owner of the mutex.
  40:../../os/rt/src/chmtx.c ****  *          .
  41:../../os/rt/src/chmtx.c ****  *          <h2>Constraints</h2>
  42:../../os/rt/src/chmtx.c ****  *          In ChibiOS/RT the Unlock operations must always be performed
  43:../../os/rt/src/chmtx.c ****  *          in lock-reverse order. This restriction both improves the
  44:../../os/rt/src/chmtx.c ****  *          performance and is required for an efficient implementation
  45:../../os/rt/src/chmtx.c ****  *          of the priority inheritance mechanism.<br>
  46:../../os/rt/src/chmtx.c ****  *          Operating under this restriction also ensures that deadlocks
  47:../../os/rt/src/chmtx.c ****  *          are no possible.
  48:../../os/rt/src/chmtx.c ****  *
  49:../../os/rt/src/chmtx.c ****  *          <h2>Recursive mode</h2>
  50:../../os/rt/src/chmtx.c ****  *          By default mutexes are not recursive, this mean that it is not
  51:../../os/rt/src/chmtx.c ****  *          possible to take a mutex already owned by the same thread.
  52:../../os/rt/src/chmtx.c ****  *          It is possible to enable the recursive behavior by enabling the
  53:../../os/rt/src/chmtx.c ****  *          option @p CH_CFG_USE_MUTEXES_RECURSIVE.
  54:../../os/rt/src/chmtx.c ****  *
  55:../../os/rt/src/chmtx.c ****  *          <h2>The priority inversion problem</h2>
  56:../../os/rt/src/chmtx.c ****  *          The mutexes in ChibiOS/RT implements the <b>full</b> priority
  57:../../os/rt/src/chmtx.c ****  *          inheritance mechanism in order handle the priority inversion
  58:../../os/rt/src/chmtx.c ****  *          problem.<br>
  59:../../os/rt/src/chmtx.c ****  *          When a thread is queued on a mutex, any thread, directly or
  60:../../os/rt/src/chmtx.c ****  *          indirectly, holding the mutex gains the same priority of the
  61:../../os/rt/src/chmtx.c ****  *          waiting thread (if their priority was not already equal or higher).
  62:../../os/rt/src/chmtx.c ****  *          The mechanism works with any number of nested mutexes and any
  63:../../os/rt/src/chmtx.c ****  *          number of involved threads. The algorithm complexity (worst case)
  64:../../os/rt/src/chmtx.c ****  *          is N with N equal to the number of nested mutexes.
  65:../../os/rt/src/chmtx.c ****  * @pre     In order to use the mutex APIs the @p CH_CFG_USE_MUTEXES option
  66:../../os/rt/src/chmtx.c ****  *          must be enabled in @p chconf.h.
  67:../../os/rt/src/chmtx.c ****  * @post    Enabling mutexes requires 5-12 (depending on the architecture)
  68:../../os/rt/src/chmtx.c ****  *          extra bytes in the @p thread_t structure.
  69:../../os/rt/src/chmtx.c ****  * @{
  70:../../os/rt/src/chmtx.c ****  */
  71:../../os/rt/src/chmtx.c **** 
  72:../../os/rt/src/chmtx.c **** #include "ch.h"
  73:../../os/rt/src/chmtx.c **** 
  74:../../os/rt/src/chmtx.c **** #if (CH_CFG_USE_MUTEXES == TRUE) || defined(__DOXYGEN__)
  75:../../os/rt/src/chmtx.c **** 
  76:../../os/rt/src/chmtx.c **** /*===========================================================================*/
  77:../../os/rt/src/chmtx.c **** /* Module exported variables.                                                */
  78:../../os/rt/src/chmtx.c **** /*===========================================================================*/
  79:../../os/rt/src/chmtx.c **** 
  80:../../os/rt/src/chmtx.c **** /*===========================================================================*/
  81:../../os/rt/src/chmtx.c **** /* Module local types.                                                       */
  82:../../os/rt/src/chmtx.c **** /*===========================================================================*/
  83:../../os/rt/src/chmtx.c **** 
  84:../../os/rt/src/chmtx.c **** /*===========================================================================*/
  85:../../os/rt/src/chmtx.c **** /* Module local variables.                                                   */
  86:../../os/rt/src/chmtx.c **** /*===========================================================================*/
  87:../../os/rt/src/chmtx.c **** 
  88:../../os/rt/src/chmtx.c **** /*===========================================================================*/
  89:../../os/rt/src/chmtx.c **** /* Module local functions.                                                   */
  90:../../os/rt/src/chmtx.c **** /*===========================================================================*/
  91:../../os/rt/src/chmtx.c **** 
  92:../../os/rt/src/chmtx.c **** /*===========================================================================*/
  93:../../os/rt/src/chmtx.c **** /* Module exported functions.                                                */
  94:../../os/rt/src/chmtx.c **** /*===========================================================================*/
  95:../../os/rt/src/chmtx.c **** 
  96:../../os/rt/src/chmtx.c **** /**
  97:../../os/rt/src/chmtx.c ****  * @brief   Initializes s @p mutex_t structure.
  98:../../os/rt/src/chmtx.c ****  *
  99:../../os/rt/src/chmtx.c ****  * @param[out] mp       pointer to a @p mutex_t structure
 100:../../os/rt/src/chmtx.c ****  *
 101:../../os/rt/src/chmtx.c ****  * @init
 102:../../os/rt/src/chmtx.c ****  */
 103:../../os/rt/src/chmtx.c **** void chMtxObjectInit(mutex_t *mp) {
  16               		.loc 1 103 0
  17               		.cfi_startproc
  18               	.LVL0:
  19               	/* prologue: function */
  20               	/* frame size = 0 */
  21               	/* stack size = 0 */
  22               	.L__stack_usage = 0
  23 0000 FC01      		movw r30,r24
  24               	.LVL1:
  25               	.LBB99:
  26               	.LBB100:
  27               		.file 2 "../../os/rt/include/chlists.h"
   1:../../os/rt/include/chlists.h **** /*
   2:../../os/rt/include/chlists.h ****     ChibiOS - Copyright (C) 2006,2007,2008,2009,2010,2011,2012,2013,2014,
   3:../../os/rt/include/chlists.h ****               2015,2016,2017,2018,2019,2020,2021 Giovanni Di Sirio.
   4:../../os/rt/include/chlists.h **** 
   5:../../os/rt/include/chlists.h ****     This file is part of ChibiOS.
   6:../../os/rt/include/chlists.h **** 
   7:../../os/rt/include/chlists.h ****     ChibiOS is free software; you can redistribute it and/or modify
   8:../../os/rt/include/chlists.h ****     it under the terms of the GNU General Public License as published by
   9:../../os/rt/include/chlists.h ****     the Free Software Foundation version 3 of the License.
  10:../../os/rt/include/chlists.h **** 
  11:../../os/rt/include/chlists.h ****     ChibiOS is distributed in the hope that it will be useful,
  12:../../os/rt/include/chlists.h ****     but WITHOUT ANY WARRANTY; without even the implied warranty of
  13:../../os/rt/include/chlists.h ****     MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
  14:../../os/rt/include/chlists.h ****     GNU General Public License for more details.
  15:../../os/rt/include/chlists.h **** 
  16:../../os/rt/include/chlists.h ****     You should have received a copy of the GNU General Public License
  17:../../os/rt/include/chlists.h ****     along with this program.  If not, see <http://www.gnu.org/licenses/>.
  18:../../os/rt/include/chlists.h **** */
  19:../../os/rt/include/chlists.h **** 
  20:../../os/rt/include/chlists.h **** /**
  21:../../os/rt/include/chlists.h ****  * @file    chlists.h
  22:../../os/rt/include/chlists.h ****  * @brief   Lists and Queues header.
  23:../../os/rt/include/chlists.h ****  *
  24:../../os/rt/include/chlists.h ****  * @addtogroup os_lists
  25:../../os/rt/include/chlists.h ****  * @{
  26:../../os/rt/include/chlists.h ****  */
  27:../../os/rt/include/chlists.h **** 
  28:../../os/rt/include/chlists.h **** #ifndef CHLISTS_H
  29:../../os/rt/include/chlists.h **** #define CHLISTS_H
  30:../../os/rt/include/chlists.h **** 
  31:../../os/rt/include/chlists.h **** /*===========================================================================*/
  32:../../os/rt/include/chlists.h **** /* Module constants.                                                         */
  33:../../os/rt/include/chlists.h **** /*===========================================================================*/
  34:../../os/rt/include/chlists.h **** 
  35:../../os/rt/include/chlists.h **** /*===========================================================================*/
  36:../../os/rt/include/chlists.h **** /* Module pre-compile time settings.                                         */
  37:../../os/rt/include/chlists.h **** /*===========================================================================*/
  38:../../os/rt/include/chlists.h **** 
  39:../../os/rt/include/chlists.h **** /*===========================================================================*/
  40:../../os/rt/include/chlists.h **** /* Derived constants and error checks.                                       */
  41:../../os/rt/include/chlists.h **** /*===========================================================================*/
  42:../../os/rt/include/chlists.h **** 
  43:../../os/rt/include/chlists.h **** /*===========================================================================*/
  44:../../os/rt/include/chlists.h **** /* Module data structures and types.                                         */
  45:../../os/rt/include/chlists.h **** /*===========================================================================*/
  46:../../os/rt/include/chlists.h **** 
  47:../../os/rt/include/chlists.h **** /**
  48:../../os/rt/include/chlists.h ****  * @brief   Type of a generic single link list header and element.
  49:../../os/rt/include/chlists.h ****  */
  50:../../os/rt/include/chlists.h **** typedef struct ch_list ch_list_t;
  51:../../os/rt/include/chlists.h **** 
  52:../../os/rt/include/chlists.h **** /**
  53:../../os/rt/include/chlists.h ****  * @brief   Structure representing a generic single link list header
  54:../../os/rt/include/chlists.h ****  *          and element.
  55:../../os/rt/include/chlists.h ****  */
  56:../../os/rt/include/chlists.h **** struct ch_list {
  57:../../os/rt/include/chlists.h ****   ch_list_t             *next;      /**< @brief Next in the list/queue.     */
  58:../../os/rt/include/chlists.h **** };
  59:../../os/rt/include/chlists.h **** 
  60:../../os/rt/include/chlists.h **** /**
  61:../../os/rt/include/chlists.h ****  * @brief   Type of a generic bidirectional linked list header and element.
  62:../../os/rt/include/chlists.h ****  */
  63:../../os/rt/include/chlists.h **** typedef struct ch_queue ch_queue_t;
  64:../../os/rt/include/chlists.h **** 
  65:../../os/rt/include/chlists.h **** /**
  66:../../os/rt/include/chlists.h ****  * @brief   Structure representing a generic bidirectional linked list header
  67:../../os/rt/include/chlists.h ****  *          and element.
  68:../../os/rt/include/chlists.h ****  */
  69:../../os/rt/include/chlists.h **** struct ch_queue {
  70:../../os/rt/include/chlists.h ****   ch_queue_t            *next;      /**< @brief Next in the list/queue.     */
  71:../../os/rt/include/chlists.h ****   ch_queue_t            *prev;      /**< @brief Previous in the queue.      */
  72:../../os/rt/include/chlists.h **** };
  73:../../os/rt/include/chlists.h **** 
  74:../../os/rt/include/chlists.h **** /**
  75:../../os/rt/include/chlists.h ****  * @brief   Type of a generic priority-ordered bidirectional linked list
  76:../../os/rt/include/chlists.h ****  *          header and element.
  77:../../os/rt/include/chlists.h ****  */
  78:../../os/rt/include/chlists.h **** typedef struct ch_priority_queue ch_priority_queue_t;
  79:../../os/rt/include/chlists.h **** 
  80:../../os/rt/include/chlists.h **** /**
  81:../../os/rt/include/chlists.h ****  * @brief   Structure representing a generic priority-ordered bidirectional
  82:../../os/rt/include/chlists.h ****  *          linked list header and element.
  83:../../os/rt/include/chlists.h ****  * @note    Link fields are void pointers in order to avoid aliasing issues.
  84:../../os/rt/include/chlists.h ****  */
  85:../../os/rt/include/chlists.h **** struct ch_priority_queue {
  86:../../os/rt/include/chlists.h ****   ch_priority_queue_t   *next;      /**< @brief Next in the queue.          */
  87:../../os/rt/include/chlists.h ****   ch_priority_queue_t   *prev;      /**< @brief Previous in the queue.      */
  88:../../os/rt/include/chlists.h ****   tprio_t               prio;       /**< @brief Priority of this element.   */
  89:../../os/rt/include/chlists.h **** };
  90:../../os/rt/include/chlists.h **** 
  91:../../os/rt/include/chlists.h **** /**
  92:../../os/rt/include/chlists.h ****  * @brief   Type of a generic bidirectional linked delta list
  93:../../os/rt/include/chlists.h ****  *          header and element.
  94:../../os/rt/include/chlists.h ****  */
  95:../../os/rt/include/chlists.h **** typedef struct ch_delta_list ch_delta_list_t;
  96:../../os/rt/include/chlists.h **** 
  97:../../os/rt/include/chlists.h **** /**
  98:../../os/rt/include/chlists.h ****  * @brief   Delta list element and header structure.
  99:../../os/rt/include/chlists.h ****  */
 100:../../os/rt/include/chlists.h **** struct ch_delta_list {
 101:../../os/rt/include/chlists.h ****   ch_delta_list_t       *next;      /**< @brief Next in the delta list.     */
 102:../../os/rt/include/chlists.h ****   ch_delta_list_t       *prev;      /**< @brief Previous in the delta list. */
 103:../../os/rt/include/chlists.h ****   sysinterval_t         delta;      /**< @brief Time interval from previous.*/
 104:../../os/rt/include/chlists.h **** };
 105:../../os/rt/include/chlists.h **** 
 106:../../os/rt/include/chlists.h **** /*===========================================================================*/
 107:../../os/rt/include/chlists.h **** /* Module macros.                                                            */
 108:../../os/rt/include/chlists.h **** /*===========================================================================*/
 109:../../os/rt/include/chlists.h **** 
 110:../../os/rt/include/chlists.h **** /**
 111:../../os/rt/include/chlists.h ****  * @brief   Data part of a static queue object initializer.
 112:../../os/rt/include/chlists.h ****  * @details This macro should be used when statically initializing a
 113:../../os/rt/include/chlists.h ****  *          queue that is part of a bigger structure.
 114:../../os/rt/include/chlists.h ****  *
 115:../../os/rt/include/chlists.h ****  * @param[in] name      the name of the queue variable
 116:../../os/rt/include/chlists.h ****  */
 117:../../os/rt/include/chlists.h **** #define __CH_QUEUE_DATA(name) {(ch_queue_t *)&name, (ch_queue_t *)&name}
 118:../../os/rt/include/chlists.h **** 
 119:../../os/rt/include/chlists.h **** /**
 120:../../os/rt/include/chlists.h ****  * @brief   Static queue object initializer.
 121:../../os/rt/include/chlists.h ****  * @details Statically initialized queues require no explicit
 122:../../os/rt/include/chlists.h ****  *          initialization using @p queue_init().
 123:../../os/rt/include/chlists.h ****  *
 124:../../os/rt/include/chlists.h ****  * @param[in] name      the name of the queue variable
 125:../../os/rt/include/chlists.h ****  */
 126:../../os/rt/include/chlists.h **** #define CH_QUEUE_DECL(name)                                                 \
 127:../../os/rt/include/chlists.h ****     ch_queue_t name = __CH_QUEUE_DATA(name)
 128:../../os/rt/include/chlists.h **** 
 129:../../os/rt/include/chlists.h **** /*===========================================================================*/
 130:../../os/rt/include/chlists.h **** /* External declarations.                                                    */
 131:../../os/rt/include/chlists.h **** /*===========================================================================*/
 132:../../os/rt/include/chlists.h **** 
 133:../../os/rt/include/chlists.h **** /* Early function prototypes required by the following headers.*/
 134:../../os/rt/include/chlists.h **** #ifdef __cplusplus
 135:../../os/rt/include/chlists.h **** extern "C" {
 136:../../os/rt/include/chlists.h **** #endif
 137:../../os/rt/include/chlists.h **** 
 138:../../os/rt/include/chlists.h **** #ifdef __cplusplus
 139:../../os/rt/include/chlists.h **** }
 140:../../os/rt/include/chlists.h **** #endif
 141:../../os/rt/include/chlists.h **** 
 142:../../os/rt/include/chlists.h **** /*===========================================================================*/
 143:../../os/rt/include/chlists.h **** /* Module inline functions.                                                  */
 144:../../os/rt/include/chlists.h **** /*===========================================================================*/
 145:../../os/rt/include/chlists.h **** 
 146:../../os/rt/include/chlists.h **** /**
 147:../../os/rt/include/chlists.h ****  * @brief   List initialization.
 148:../../os/rt/include/chlists.h ****  *
 149:../../os/rt/include/chlists.h ****  * @param[out] lp       pointer to the list header
 150:../../os/rt/include/chlists.h ****  *
 151:../../os/rt/include/chlists.h ****  * @notapi
 152:../../os/rt/include/chlists.h ****  */
 153:../../os/rt/include/chlists.h **** static inline void ch_list_init(ch_list_t *lp) {
 154:../../os/rt/include/chlists.h **** 
 155:../../os/rt/include/chlists.h ****   lp->next = lp;
 156:../../os/rt/include/chlists.h **** }
 157:../../os/rt/include/chlists.h **** 
 158:../../os/rt/include/chlists.h **** /**
 159:../../os/rt/include/chlists.h ****  * @brief   Evaluates to @p true if the specified list is empty.
 160:../../os/rt/include/chlists.h ****  *
 161:../../os/rt/include/chlists.h ****  * @param[in] lp        pointer to the list header
 162:../../os/rt/include/chlists.h ****  * @return              The status of the list.
 163:../../os/rt/include/chlists.h ****  *
 164:../../os/rt/include/chlists.h ****  * @notapi
 165:../../os/rt/include/chlists.h ****  */
 166:../../os/rt/include/chlists.h **** static inline bool ch_list_isempty(ch_list_t *lp) {
 167:../../os/rt/include/chlists.h **** 
 168:../../os/rt/include/chlists.h ****   return (bool)(lp->next == lp);
 169:../../os/rt/include/chlists.h **** }
 170:../../os/rt/include/chlists.h **** 
 171:../../os/rt/include/chlists.h **** /**
 172:../../os/rt/include/chlists.h ****  * @brief   Evaluates to @p true if the specified list is not empty.
 173:../../os/rt/include/chlists.h ****  *
 174:../../os/rt/include/chlists.h ****  * @param[in] lp        pointer to the list header
 175:../../os/rt/include/chlists.h ****  * @return              The status of the list.
 176:../../os/rt/include/chlists.h ****  *
 177:../../os/rt/include/chlists.h ****  * @notapi
 178:../../os/rt/include/chlists.h ****  */
 179:../../os/rt/include/chlists.h **** static inline bool ch_list_notempty(ch_list_t *lp) {
 180:../../os/rt/include/chlists.h **** 
 181:../../os/rt/include/chlists.h ****   return (bool)(lp->next != lp);
 182:../../os/rt/include/chlists.h **** }
 183:../../os/rt/include/chlists.h **** 
 184:../../os/rt/include/chlists.h **** /**
 185:../../os/rt/include/chlists.h ****  * @brief   Pushes an element on top of a stack list.
 186:../../os/rt/include/chlists.h ****  *
 187:../../os/rt/include/chlists.h ****  * @param[in] lp    the pointer to the list header
 188:../../os/rt/include/chlists.h ****  * @param[in] p     the pointer to the element to be inserted in the list
 189:../../os/rt/include/chlists.h ****  *
 190:../../os/rt/include/chlists.h ****  * @notapi
 191:../../os/rt/include/chlists.h ****  */
 192:../../os/rt/include/chlists.h **** static inline void ch_list_link(ch_list_t *lp, ch_list_t *p) {
 193:../../os/rt/include/chlists.h **** 
 194:../../os/rt/include/chlists.h ****   p->next = lp->next;
 195:../../os/rt/include/chlists.h ****   lp->next = p;
 196:../../os/rt/include/chlists.h **** }
 197:../../os/rt/include/chlists.h **** 
 198:../../os/rt/include/chlists.h **** /**
 199:../../os/rt/include/chlists.h ****  * @brief   Pops an element from the top of a stack list and returns it.
 200:../../os/rt/include/chlists.h ****  * @pre     The list must be non-empty before calling this function.
 201:../../os/rt/include/chlists.h ****  *
 202:../../os/rt/include/chlists.h ****  * @param[in] lp        the pointer to the list header
 203:../../os/rt/include/chlists.h ****  * @return              The removed element pointer.
 204:../../os/rt/include/chlists.h ****  *
 205:../../os/rt/include/chlists.h ****  * @notapi
 206:../../os/rt/include/chlists.h ****  */
 207:../../os/rt/include/chlists.h **** static inline ch_list_t *ch_list_unlink(ch_list_t *lp) {
 208:../../os/rt/include/chlists.h **** 
 209:../../os/rt/include/chlists.h ****   ch_list_t *p = lp->next;
 210:../../os/rt/include/chlists.h ****   lp->next = p->next;
 211:../../os/rt/include/chlists.h **** 
 212:../../os/rt/include/chlists.h ****   return p;
 213:../../os/rt/include/chlists.h **** }
 214:../../os/rt/include/chlists.h **** 
 215:../../os/rt/include/chlists.h **** /**
 216:../../os/rt/include/chlists.h ****  * @brief   Queue initialization.
 217:../../os/rt/include/chlists.h ****  *
 218:../../os/rt/include/chlists.h ****  * @param[out] qp       pointer to the queue header
 219:../../os/rt/include/chlists.h ****  *
 220:../../os/rt/include/chlists.h ****  * @notapi
 221:../../os/rt/include/chlists.h ****  */
 222:../../os/rt/include/chlists.h **** static inline void ch_queue_init(ch_queue_t *qp) {
 223:../../os/rt/include/chlists.h **** 
 224:../../os/rt/include/chlists.h ****   qp->next = qp;
  28               		.loc 2 224 0
  29 0002 9183      		std Z+1,r25
  30 0004 8083      		st Z,r24
 225:../../os/rt/include/chlists.h ****   qp->prev = qp;
  31               		.loc 2 225 0
  32 0006 9383      		std Z+3,r25
  33 0008 8283      		std Z+2,r24
  34               	.LVL2:
  35               	.LBE100:
  36               	.LBE99:
 104:../../os/rt/src/chmtx.c **** 
 105:../../os/rt/src/chmtx.c ****   chDbgCheck(mp != NULL);
 106:../../os/rt/src/chmtx.c **** 
 107:../../os/rt/src/chmtx.c ****   ch_queue_init(&mp->queue);
 108:../../os/rt/src/chmtx.c ****   mp->owner = NULL;
  37               		.loc 1 108 0
  38 000a 1582      		std Z+5,__zero_reg__
  39 000c 1482      		std Z+4,__zero_reg__
  40               	/* epilogue start */
 109:../../os/rt/src/chmtx.c **** #if CH_CFG_USE_MUTEXES_RECURSIVE == TRUE
 110:../../os/rt/src/chmtx.c ****   mp->cnt = (cnt_t)0;
 111:../../os/rt/src/chmtx.c **** #endif
 112:../../os/rt/src/chmtx.c **** }
  41               		.loc 1 112 0
  42 000e 0895      		ret
  43               		.cfi_endproc
  44               	.LFE195:
  46               		.section	.text.chMtxLockS,"ax",@progbits
  47               	.global	chMtxLockS
  49               	chMtxLockS:
  50               	.LFB197:
 113:../../os/rt/src/chmtx.c **** 
 114:../../os/rt/src/chmtx.c **** /**
 115:../../os/rt/src/chmtx.c ****  * @brief   Locks the specified mutex.
 116:../../os/rt/src/chmtx.c ****  * @post    The mutex is locked and inserted in the per-thread stack of owned
 117:../../os/rt/src/chmtx.c ****  *          mutexes.
 118:../../os/rt/src/chmtx.c ****  *
 119:../../os/rt/src/chmtx.c ****  * @param[in] mp        pointer to the @p mutex_t structure
 120:../../os/rt/src/chmtx.c ****  *
 121:../../os/rt/src/chmtx.c ****  * @api
 122:../../os/rt/src/chmtx.c ****  */
 123:../../os/rt/src/chmtx.c **** void chMtxLock(mutex_t *mp) {
 124:../../os/rt/src/chmtx.c **** 
 125:../../os/rt/src/chmtx.c ****   chSysLock();
 126:../../os/rt/src/chmtx.c ****   chMtxLockS(mp);
 127:../../os/rt/src/chmtx.c ****   chSysUnlock();
 128:../../os/rt/src/chmtx.c **** }
 129:../../os/rt/src/chmtx.c **** 
 130:../../os/rt/src/chmtx.c **** /**
 131:../../os/rt/src/chmtx.c ****  * @brief   Locks the specified mutex.
 132:../../os/rt/src/chmtx.c ****  * @post    The mutex is locked and inserted in the per-thread stack of owned
 133:../../os/rt/src/chmtx.c ****  *          mutexes.
 134:../../os/rt/src/chmtx.c ****  *
 135:../../os/rt/src/chmtx.c ****  * @param[in] mp        pointer to the @p mutex_t structure
 136:../../os/rt/src/chmtx.c ****  *
 137:../../os/rt/src/chmtx.c ****  * @sclass
 138:../../os/rt/src/chmtx.c ****  */
 139:../../os/rt/src/chmtx.c **** void chMtxLockS(mutex_t *mp) {
  51               		.loc 1 139 0
  52               		.cfi_startproc
  53               	.LVL3:
  54 0000 0F93      		push r16
  55               	.LCFI0:
  56               		.cfi_def_cfa_offset 3
  57               		.cfi_offset 16, -2
  58 0002 1F93      		push r17
  59               	.LCFI1:
  60               		.cfi_def_cfa_offset 4
  61               		.cfi_offset 17, -3
  62 0004 CF93      		push r28
  63               	.LCFI2:
  64               		.cfi_def_cfa_offset 5
  65               		.cfi_offset 28, -4
  66 0006 DF93      		push r29
  67               	.LCFI3:
  68               		.cfi_def_cfa_offset 6
  69               		.cfi_offset 29, -5
  70               	/* prologue: function */
  71               	/* frame size = 0 */
  72               	/* stack size = 4 */
  73               	.L__stack_usage = 4
  74 0008 EC01      		movw r28,r24
  75               	.LBB101:
  76               	.LBB102:
  77               		.file 3 "../../os/rt/include/chthreads.h"
   1:../../os/rt/include/chthreads.h **** /*
   2:../../os/rt/include/chthreads.h ****     ChibiOS - Copyright (C) 2006,2007,2008,2009,2010,2011,2012,2013,2014,
   3:../../os/rt/include/chthreads.h ****               2015,2016,2017,2018,2019,2020,2021 Giovanni Di Sirio.
   4:../../os/rt/include/chthreads.h **** 
   5:../../os/rt/include/chthreads.h ****     This file is part of ChibiOS.
   6:../../os/rt/include/chthreads.h **** 
   7:../../os/rt/include/chthreads.h ****     ChibiOS is free software; you can redistribute it and/or modify
   8:../../os/rt/include/chthreads.h ****     it under the terms of the GNU General Public License as published by
   9:../../os/rt/include/chthreads.h ****     the Free Software Foundation version 3 of the License.
  10:../../os/rt/include/chthreads.h **** 
  11:../../os/rt/include/chthreads.h ****     ChibiOS is distributed in the hope that it will be useful,
  12:../../os/rt/include/chthreads.h ****     but WITHOUT ANY WARRANTY; without even the implied warranty of
  13:../../os/rt/include/chthreads.h ****     MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
  14:../../os/rt/include/chthreads.h ****     GNU General Public License for more details.
  15:../../os/rt/include/chthreads.h **** 
  16:../../os/rt/include/chthreads.h ****     You should have received a copy of the GNU General Public License
  17:../../os/rt/include/chthreads.h ****     along with this program.  If not, see <http://www.gnu.org/licenses/>.
  18:../../os/rt/include/chthreads.h **** */
  19:../../os/rt/include/chthreads.h **** 
  20:../../os/rt/include/chthreads.h **** /**
  21:../../os/rt/include/chthreads.h ****  * @file    rt/include/chthreads.h
  22:../../os/rt/include/chthreads.h ****  * @brief   Threads module macros and structures.
  23:../../os/rt/include/chthreads.h ****  *
  24:../../os/rt/include/chthreads.h ****  * @addtogroup threads
  25:../../os/rt/include/chthreads.h ****  * @{
  26:../../os/rt/include/chthreads.h ****  */
  27:../../os/rt/include/chthreads.h **** 
  28:../../os/rt/include/chthreads.h **** #ifndef CHTHREADS_H
  29:../../os/rt/include/chthreads.h **** #define CHTHREADS_H
  30:../../os/rt/include/chthreads.h **** 
  31:../../os/rt/include/chthreads.h **** /*lint -sem(chThdExit, r_no) -sem(chThdExitS, r_no)*/
  32:../../os/rt/include/chthreads.h **** 
  33:../../os/rt/include/chthreads.h **** /*===========================================================================*/
  34:../../os/rt/include/chthreads.h **** /* Module constants.                                                         */
  35:../../os/rt/include/chthreads.h **** /*===========================================================================*/
  36:../../os/rt/include/chthreads.h **** 
  37:../../os/rt/include/chthreads.h **** /*===========================================================================*/
  38:../../os/rt/include/chthreads.h **** /* Module pre-compile time settings.                                         */
  39:../../os/rt/include/chthreads.h **** /*===========================================================================*/
  40:../../os/rt/include/chthreads.h **** 
  41:../../os/rt/include/chthreads.h **** /*===========================================================================*/
  42:../../os/rt/include/chthreads.h **** /* Derived constants and error checks.                                       */
  43:../../os/rt/include/chthreads.h **** /*===========================================================================*/
  44:../../os/rt/include/chthreads.h **** 
  45:../../os/rt/include/chthreads.h **** /*===========================================================================*/
  46:../../os/rt/include/chthreads.h **** /* Module data structures and types.                                         */
  47:../../os/rt/include/chthreads.h **** /*===========================================================================*/
  48:../../os/rt/include/chthreads.h **** 
  49:../../os/rt/include/chthreads.h **** /**
  50:../../os/rt/include/chthreads.h ****  * @brief   Thread function.
  51:../../os/rt/include/chthreads.h ****  */
  52:../../os/rt/include/chthreads.h **** typedef void (*tfunc_t)(void *p);
  53:../../os/rt/include/chthreads.h **** 
  54:../../os/rt/include/chthreads.h **** /**
  55:../../os/rt/include/chthreads.h ****  * @brief   Type of a thread descriptor.
  56:../../os/rt/include/chthreads.h ****  */
  57:../../os/rt/include/chthreads.h **** typedef struct {
  58:../../os/rt/include/chthreads.h ****   /**
  59:../../os/rt/include/chthreads.h ****    * @brief   Thread name.
  60:../../os/rt/include/chthreads.h ****    */
  61:../../os/rt/include/chthreads.h ****   const char        *name;
  62:../../os/rt/include/chthreads.h ****   /**
  63:../../os/rt/include/chthreads.h ****    * @brief   Pointer to the working area base.
  64:../../os/rt/include/chthreads.h ****    */
  65:../../os/rt/include/chthreads.h ****   stkalign_t        *wbase;
  66:../../os/rt/include/chthreads.h ****   /**
  67:../../os/rt/include/chthreads.h ****    * @brief   Pointer to the working area end.
  68:../../os/rt/include/chthreads.h ****    */
  69:../../os/rt/include/chthreads.h ****   stkalign_t        *wend;
  70:../../os/rt/include/chthreads.h ****   /**
  71:../../os/rt/include/chthreads.h ****    * @brief   Thread priority.
  72:../../os/rt/include/chthreads.h ****    */
  73:../../os/rt/include/chthreads.h ****   tprio_t           prio;
  74:../../os/rt/include/chthreads.h ****   /**
  75:../../os/rt/include/chthreads.h ****    * @brief   Thread function pointer.
  76:../../os/rt/include/chthreads.h ****    */
  77:../../os/rt/include/chthreads.h ****   tfunc_t           funcp;
  78:../../os/rt/include/chthreads.h ****   /**
  79:../../os/rt/include/chthreads.h ****    * @brief   Thread argument.
  80:../../os/rt/include/chthreads.h ****    */
  81:../../os/rt/include/chthreads.h ****   void              *arg;
  82:../../os/rt/include/chthreads.h **** #if (CH_CFG_SMP_MODE != FALSE) || defined(__DOXYGEN__)
  83:../../os/rt/include/chthreads.h ****   /**
  84:../../os/rt/include/chthreads.h ****    * @brief         OS instance affinity or @p NULL for current one.
  85:../../os/rt/include/chthreads.h ****    */
  86:../../os/rt/include/chthreads.h ****   os_instance_t     *instance;
  87:../../os/rt/include/chthreads.h **** #endif
  88:../../os/rt/include/chthreads.h **** } thread_descriptor_t;
  89:../../os/rt/include/chthreads.h **** 
  90:../../os/rt/include/chthreads.h **** /*===========================================================================*/
  91:../../os/rt/include/chthreads.h **** /* Module macros.                                                            */
  92:../../os/rt/include/chthreads.h **** /*===========================================================================*/
  93:../../os/rt/include/chthreads.h **** 
  94:../../os/rt/include/chthreads.h **** /**
  95:../../os/rt/include/chthreads.h ****  * @name    Threads queues
  96:../../os/rt/include/chthreads.h ****  * @{
  97:../../os/rt/include/chthreads.h ****  */
  98:../../os/rt/include/chthreads.h **** /**
  99:../../os/rt/include/chthreads.h ****  * @brief   Data part of a static threads queue object initializer.
 100:../../os/rt/include/chthreads.h ****  * @details This macro should be used when statically initializing a threads
 101:../../os/rt/include/chthreads.h ****  *          queue that is part of a bigger structure.
 102:../../os/rt/include/chthreads.h ****  *
 103:../../os/rt/include/chthreads.h ****  * @param[in] name      the name of the threads queue variable
 104:../../os/rt/include/chthreads.h ****  */
 105:../../os/rt/include/chthreads.h **** #define __THREADS_QUEUE_DATA(name) {__CH_QUEUE_DATA(name)}
 106:../../os/rt/include/chthreads.h **** 
 107:../../os/rt/include/chthreads.h **** /**
 108:../../os/rt/include/chthreads.h ****  * @brief   Static threads queue object initializer.
 109:../../os/rt/include/chthreads.h ****  * @details Statically initialized threads queues require no explicit
 110:../../os/rt/include/chthreads.h ****  *          initialization using @p queue_init().
 111:../../os/rt/include/chthreads.h ****  *
 112:../../os/rt/include/chthreads.h ****  * @param[in] name      the name of the threads queue variable
 113:../../os/rt/include/chthreads.h ****  */
 114:../../os/rt/include/chthreads.h **** #define THREADS_QUEUE_DECL(name)                                            \
 115:../../os/rt/include/chthreads.h ****   threads_queue_t name = __THREADS_QUEUE_DATA(name)
 116:../../os/rt/include/chthreads.h **** /** @} */
 117:../../os/rt/include/chthreads.h **** 
 118:../../os/rt/include/chthreads.h **** /**
 119:../../os/rt/include/chthreads.h ****  * @name    Working Areas
 120:../../os/rt/include/chthreads.h ****  * @{
 121:../../os/rt/include/chthreads.h ****  */
 122:../../os/rt/include/chthreads.h **** /**
 123:../../os/rt/include/chthreads.h ****  * @brief   Calculates the total Working Area size.
 124:../../os/rt/include/chthreads.h ****  *
 125:../../os/rt/include/chthreads.h ****  * @param[in] n         the stack size to be assigned to the thread
 126:../../os/rt/include/chthreads.h ****  * @return              The total used memory in bytes.
 127:../../os/rt/include/chthreads.h ****  *
 128:../../os/rt/include/chthreads.h ****  * @api
 129:../../os/rt/include/chthreads.h ****  */
 130:../../os/rt/include/chthreads.h **** #define THD_WORKING_AREA_SIZE(n)                                            \
 131:../../os/rt/include/chthreads.h ****   MEM_ALIGN_NEXT(sizeof(thread_t) + PORT_WA_SIZE(n), PORT_STACK_ALIGN)
 132:../../os/rt/include/chthreads.h **** 
 133:../../os/rt/include/chthreads.h **** /**
 134:../../os/rt/include/chthreads.h ****  * @brief   Static working area allocation.
 135:../../os/rt/include/chthreads.h ****  * @details This macro is used to allocate a static thread working area
 136:../../os/rt/include/chthreads.h ****  *          aligned as both position and size.
 137:../../os/rt/include/chthreads.h ****  *
 138:../../os/rt/include/chthreads.h ****  * @param[in] s         the name to be assigned to the stack array
 139:../../os/rt/include/chthreads.h ****  * @param[in] n         the stack size to be assigned to the thread
 140:../../os/rt/include/chthreads.h ****  *
 141:../../os/rt/include/chthreads.h ****  * @api
 142:../../os/rt/include/chthreads.h ****  */
 143:../../os/rt/include/chthreads.h **** #define THD_WORKING_AREA(s, n) PORT_WORKING_AREA(s, n)
 144:../../os/rt/include/chthreads.h **** 
 145:../../os/rt/include/chthreads.h **** /**
 146:../../os/rt/include/chthreads.h ****  * @brief   Base of a working area casted to the correct type.
 147:../../os/rt/include/chthreads.h ****  *
 148:../../os/rt/include/chthreads.h ****  * @param[in] s         name of the working area
 149:../../os/rt/include/chthreads.h ****  */
 150:../../os/rt/include/chthreads.h **** #define THD_WORKING_AREA_BASE(s) ((stkalign_t *)(s))
 151:../../os/rt/include/chthreads.h **** 
 152:../../os/rt/include/chthreads.h **** /**
 153:../../os/rt/include/chthreads.h ****  * @brief   End of a working area casted to the correct type.
 154:../../os/rt/include/chthreads.h ****  *
 155:../../os/rt/include/chthreads.h ****  * @param[in] s         name of the working area
 156:../../os/rt/include/chthreads.h ****  */
 157:../../os/rt/include/chthreads.h **** #define THD_WORKING_AREA_END(s) (THD_WORKING_AREA_BASE(s) +                 \
 158:../../os/rt/include/chthreads.h ****                                  (sizeof (s) / sizeof (stkalign_t)))
 159:../../os/rt/include/chthreads.h **** /** @} */
 160:../../os/rt/include/chthreads.h **** 
 161:../../os/rt/include/chthreads.h **** /**
 162:../../os/rt/include/chthreads.h ****  * @name    Threads abstraction macros
 163:../../os/rt/include/chthreads.h ****  * @{
 164:../../os/rt/include/chthreads.h ****  */
 165:../../os/rt/include/chthreads.h **** /**
 166:../../os/rt/include/chthreads.h ****  * @brief   Thread declaration macro.
 167:../../os/rt/include/chthreads.h ****  * @note    Thread declarations should be performed using this macro because
 168:../../os/rt/include/chthreads.h ****  *          the port layer could define optimizations for thread functions.
 169:../../os/rt/include/chthreads.h ****  */
 170:../../os/rt/include/chthreads.h **** #define THD_FUNCTION(tname, arg) PORT_THD_FUNCTION(tname, arg)
 171:../../os/rt/include/chthreads.h **** /** @} */
 172:../../os/rt/include/chthreads.h **** 
 173:../../os/rt/include/chthreads.h **** /**
 174:../../os/rt/include/chthreads.h ****  * @name    Threads initializers
 175:../../os/rt/include/chthreads.h ****  * @{
 176:../../os/rt/include/chthreads.h ****  */
 177:../../os/rt/include/chthreads.h **** #if (CH_CFG_SMP_MODE != FALSE) || defined(__DOXYGEN__)
 178:../../os/rt/include/chthreads.h **** /**
 179:../../os/rt/include/chthreads.h ****  * @brief   Thread descriptor initializer with no affinity.
 180:../../os/rt/include/chthreads.h ****  *
 181:../../os/rt/include/chthreads.h ****  * @param[in] name      thread name
 182:../../os/rt/include/chthreads.h ****  * @param[in] wbase     pointer to the working area base
 183:../../os/rt/include/chthreads.h ****  * @param[in] wend      pointer to the working area end
 184:../../os/rt/include/chthreads.h ****  * @param[in] prio      thread priority
 185:../../os/rt/include/chthreads.h ****  * @param[in] funcp     thread function pointer
 186:../../os/rt/include/chthreads.h ****  * @param[in] arg       thread argument
 187:../../os/rt/include/chthreads.h ****  */
 188:../../os/rt/include/chthreads.h **** #define THD_DESCRIPTOR(name, wbase, wend, prio, funcp, arg) {               \
 189:../../os/rt/include/chthreads.h ****   (name),                                                                   \
 190:../../os/rt/include/chthreads.h ****   (wbase),                                                                  \
 191:../../os/rt/include/chthreads.h ****   (wend),                                                                   \
 192:../../os/rt/include/chthreads.h ****   (prio),                                                                   \
 193:../../os/rt/include/chthreads.h ****   (funcp),                                                                  \
 194:../../os/rt/include/chthreads.h ****   (arg),                                                                    \
 195:../../os/rt/include/chthreads.h ****   NULL                                                                      \
 196:../../os/rt/include/chthreads.h **** }
 197:../../os/rt/include/chthreads.h **** #else
 198:../../os/rt/include/chthreads.h **** #define THD_DESCRIPTOR(name, wbase, wend, prio, funcp, arg) {               \
 199:../../os/rt/include/chthreads.h ****   (name),                                                                   \
 200:../../os/rt/include/chthreads.h ****   (wbase),                                                                  \
 201:../../os/rt/include/chthreads.h ****   (wend),                                                                   \
 202:../../os/rt/include/chthreads.h ****   (prio),                                                                   \
 203:../../os/rt/include/chthreads.h ****   (funcp),                                                                  \
 204:../../os/rt/include/chthreads.h ****   (arg)                                                                     \
 205:../../os/rt/include/chthreads.h **** }
 206:../../os/rt/include/chthreads.h **** #endif
 207:../../os/rt/include/chthreads.h **** 
 208:../../os/rt/include/chthreads.h **** /**
 209:../../os/rt/include/chthreads.h ****  * @brief   Thread descriptor initializer with no affinity.
 210:../../os/rt/include/chthreads.h ****  *
 211:../../os/rt/include/chthreads.h ****  * @param[in] name      thread name
 212:../../os/rt/include/chthreads.h ****  * @param[in] wbase     pointer to the working area base
 213:../../os/rt/include/chthreads.h ****  * @param[in] wend      pointer to the working area end
 214:../../os/rt/include/chthreads.h ****  * @param[in] prio      thread priority
 215:../../os/rt/include/chthreads.h ****  * @param[in] funcp     thread function pointer
 216:../../os/rt/include/chthreads.h ****  * @param[in] arg       thread argument
 217:../../os/rt/include/chthreads.h ****  * @param[in] oip       instance affinity
 218:../../os/rt/include/chthreads.h ****  */
 219:../../os/rt/include/chthreads.h **** #define THD_DESCRIPTOR_AFFINITY(name, wbase, wend, prio, funcp, arg, oip) { \
 220:../../os/rt/include/chthreads.h ****   (name),                                                                   \
 221:../../os/rt/include/chthreads.h ****   (wbase),                                                                  \
 222:../../os/rt/include/chthreads.h ****   (wend),                                                                   \
 223:../../os/rt/include/chthreads.h ****   (prio),                                                                   \
 224:../../os/rt/include/chthreads.h ****   (funcp),                                                                  \
 225:../../os/rt/include/chthreads.h ****   (arg),                                                                    \
 226:../../os/rt/include/chthreads.h ****   (oip)                                                                     \
 227:../../os/rt/include/chthreads.h **** }
 228:../../os/rt/include/chthreads.h **** /** @} */
 229:../../os/rt/include/chthreads.h **** 
 230:../../os/rt/include/chthreads.h **** /**
 231:../../os/rt/include/chthreads.h ****  * @name    Macro Functions
 232:../../os/rt/include/chthreads.h ****  * @{
 233:../../os/rt/include/chthreads.h ****  */
 234:../../os/rt/include/chthreads.h **** /**
 235:../../os/rt/include/chthreads.h ****  * @brief   Delays the invoking thread for the specified number of seconds.
 236:../../os/rt/include/chthreads.h ****  * @note    The specified time is rounded up to a value allowed by the real
 237:../../os/rt/include/chthreads.h ****  *          system tick clock.
 238:../../os/rt/include/chthreads.h ****  * @note    The maximum specifiable value is implementation dependent.
 239:../../os/rt/include/chthreads.h ****  * @note    Use of this macro for large values is not secure because
 240:../../os/rt/include/chthreads.h ****  *          integer overflows, make sure your value can be correctly
 241:../../os/rt/include/chthreads.h ****  *          converted.
 242:../../os/rt/include/chthreads.h ****  *
 243:../../os/rt/include/chthreads.h ****  * @param[in] sec       time in seconds, must be different from zero
 244:../../os/rt/include/chthreads.h ****  *
 245:../../os/rt/include/chthreads.h ****  * @api
 246:../../os/rt/include/chthreads.h ****  */
 247:../../os/rt/include/chthreads.h **** #define chThdSleepSeconds(sec) chThdSleep(TIME_S2I(sec))
 248:../../os/rt/include/chthreads.h **** 
 249:../../os/rt/include/chthreads.h **** /**
 250:../../os/rt/include/chthreads.h ****  * @brief   Delays the invoking thread for the specified number of
 251:../../os/rt/include/chthreads.h ****  *          milliseconds.
 252:../../os/rt/include/chthreads.h ****  * @note    The specified time is rounded up to a value allowed by the real
 253:../../os/rt/include/chthreads.h ****  *          system tick clock.
 254:../../os/rt/include/chthreads.h ****  * @note    The maximum specifiable value is implementation dependent.
 255:../../os/rt/include/chthreads.h ****  * @note    Use of this macro for large values is not secure because
 256:../../os/rt/include/chthreads.h ****  *          integer overflows, make sure your value can be correctly
 257:../../os/rt/include/chthreads.h ****  *          converted.
 258:../../os/rt/include/chthreads.h ****  *
 259:../../os/rt/include/chthreads.h ****  * @param[in] msec      time in milliseconds, must be different from zero
 260:../../os/rt/include/chthreads.h ****  *
 261:../../os/rt/include/chthreads.h ****  * @api
 262:../../os/rt/include/chthreads.h ****  */
 263:../../os/rt/include/chthreads.h **** #define chThdSleepMilliseconds(msec) chThdSleep(TIME_MS2I(msec))
 264:../../os/rt/include/chthreads.h **** 
 265:../../os/rt/include/chthreads.h **** /**
 266:../../os/rt/include/chthreads.h ****  * @brief   Delays the invoking thread for the specified number of
 267:../../os/rt/include/chthreads.h ****  *          microseconds.
 268:../../os/rt/include/chthreads.h ****  * @note    The specified time is rounded up to a value allowed by the real
 269:../../os/rt/include/chthreads.h ****  *          system tick clock.
 270:../../os/rt/include/chthreads.h ****  * @note    The maximum specifiable value is implementation dependent.
 271:../../os/rt/include/chthreads.h ****  * @note    Use of this macro for large values is not secure because
 272:../../os/rt/include/chthreads.h ****  *          integer overflows, make sure your value can be correctly
 273:../../os/rt/include/chthreads.h ****  *          converted.
 274:../../os/rt/include/chthreads.h ****  *
 275:../../os/rt/include/chthreads.h ****  * @param[in] usec      time in microseconds, must be different from zero
 276:../../os/rt/include/chthreads.h ****  *
 277:../../os/rt/include/chthreads.h ****  * @api
 278:../../os/rt/include/chthreads.h ****  */
 279:../../os/rt/include/chthreads.h **** #define chThdSleepMicroseconds(usec) chThdSleep(TIME_US2I(usec))
 280:../../os/rt/include/chthreads.h **** /** @} */
 281:../../os/rt/include/chthreads.h **** 
 282:../../os/rt/include/chthreads.h **** /*===========================================================================*/
 283:../../os/rt/include/chthreads.h **** /* External declarations.                                                    */
 284:../../os/rt/include/chthreads.h **** /*===========================================================================*/
 285:../../os/rt/include/chthreads.h **** 
 286:../../os/rt/include/chthreads.h **** #ifdef __cplusplus
 287:../../os/rt/include/chthreads.h **** extern "C" {
 288:../../os/rt/include/chthreads.h **** #endif
 289:../../os/rt/include/chthreads.h ****    thread_t *__thd_object_init(os_instance_t *oip,
 290:../../os/rt/include/chthreads.h ****                                thread_t *tp,
 291:../../os/rt/include/chthreads.h ****                                const char *name,
 292:../../os/rt/include/chthreads.h ****                                tprio_t prio);
 293:../../os/rt/include/chthreads.h **** #if CH_DBG_FILL_THREADS == TRUE
 294:../../os/rt/include/chthreads.h ****   void __thd_stackfill(uint8_t *startp, uint8_t *endp);
 295:../../os/rt/include/chthreads.h **** #endif
 296:../../os/rt/include/chthreads.h ****   thread_t *chThdCreateSuspendedI(const thread_descriptor_t *tdp);
 297:../../os/rt/include/chthreads.h ****   thread_t *chThdCreateSuspended(const thread_descriptor_t *tdp);
 298:../../os/rt/include/chthreads.h ****   thread_t *chThdCreateI(const thread_descriptor_t *tdp);
 299:../../os/rt/include/chthreads.h ****   thread_t *chThdCreate(const thread_descriptor_t *tdp);
 300:../../os/rt/include/chthreads.h ****   thread_t *chThdCreateStatic(void *wsp, size_t size,
 301:../../os/rt/include/chthreads.h ****                               tprio_t prio, tfunc_t pf, void *arg);
 302:../../os/rt/include/chthreads.h ****   thread_t *chThdStart(thread_t *tp);
 303:../../os/rt/include/chthreads.h **** #if CH_CFG_USE_REGISTRY == TRUE
 304:../../os/rt/include/chthreads.h ****   thread_t *chThdAddRef(thread_t *tp);
 305:../../os/rt/include/chthreads.h ****   void chThdRelease(thread_t *tp);
 306:../../os/rt/include/chthreads.h **** #endif
 307:../../os/rt/include/chthreads.h ****   void chThdExit(msg_t msg);
 308:../../os/rt/include/chthreads.h ****   void chThdExitS(msg_t msg);
 309:../../os/rt/include/chthreads.h **** #if CH_CFG_USE_WAITEXIT == TRUE
 310:../../os/rt/include/chthreads.h ****   msg_t chThdWait(thread_t *tp);
 311:../../os/rt/include/chthreads.h **** #endif
 312:../../os/rt/include/chthreads.h ****   tprio_t chThdSetPriority(tprio_t newprio);
 313:../../os/rt/include/chthreads.h ****   void chThdTerminate(thread_t *tp);
 314:../../os/rt/include/chthreads.h ****   msg_t chThdSuspendS(thread_reference_t *trp);
 315:../../os/rt/include/chthreads.h ****   msg_t chThdSuspendTimeoutS(thread_reference_t *trp, sysinterval_t timeout);
 316:../../os/rt/include/chthreads.h ****   void chThdResumeI(thread_reference_t *trp, msg_t msg);
 317:../../os/rt/include/chthreads.h ****   void chThdResumeS(thread_reference_t *trp, msg_t msg);
 318:../../os/rt/include/chthreads.h ****   void chThdResume(thread_reference_t *trp, msg_t msg);
 319:../../os/rt/include/chthreads.h ****   msg_t chThdEnqueueTimeoutS(threads_queue_t *tqp, sysinterval_t timeout);
 320:../../os/rt/include/chthreads.h ****   void chThdDequeueNextI(threads_queue_t *tqp, msg_t msg);
 321:../../os/rt/include/chthreads.h ****   void chThdDequeueAllI(threads_queue_t *tqp, msg_t msg);
 322:../../os/rt/include/chthreads.h ****   void chThdSleep(sysinterval_t time);
 323:../../os/rt/include/chthreads.h ****   void chThdSleepUntil(systime_t time);
 324:../../os/rt/include/chthreads.h ****   systime_t chThdSleepUntilWindowed(systime_t prev, systime_t next);
 325:../../os/rt/include/chthreads.h ****   void chThdYield(void);
 326:../../os/rt/include/chthreads.h **** #ifdef __cplusplus
 327:../../os/rt/include/chthreads.h **** }
 328:../../os/rt/include/chthreads.h **** #endif
 329:../../os/rt/include/chthreads.h **** 
 330:../../os/rt/include/chthreads.h **** /*===========================================================================*/
 331:../../os/rt/include/chthreads.h **** /* Module inline functions.                                                  */
 332:../../os/rt/include/chthreads.h **** /*===========================================================================*/
 333:../../os/rt/include/chthreads.h **** 
 334:../../os/rt/include/chthreads.h **** /**
 335:../../os/rt/include/chthreads.h ****  * @brief   Returns a pointer to the current @p thread_t.
 336:../../os/rt/include/chthreads.h ****  *
 337:../../os/rt/include/chthreads.h ****  * @return             A pointer to the current thread.
 338:../../os/rt/include/chthreads.h ****  *
 339:../../os/rt/include/chthreads.h ****  * @xclass
 340:../../os/rt/include/chthreads.h ****  */
 341:../../os/rt/include/chthreads.h **** static inline thread_t *chThdGetSelfX(void) {
 342:../../os/rt/include/chthreads.h **** 
 343:../../os/rt/include/chthreads.h ****   return __sch_get_currthread();
  78               		.loc 3 343 0
  79 000a 0091 0000 		lds r16,ch0+5
  80 000e 1091 0000 		lds r17,ch0+5+1
  81               	.LBE102:
  82               	.LBE101:
 140:../../os/rt/src/chmtx.c ****   thread_t *currtp = chThdGetSelfX();
 141:../../os/rt/src/chmtx.c **** 
 142:../../os/rt/src/chmtx.c ****   chDbgCheckClassS();
 143:../../os/rt/src/chmtx.c ****   chDbgCheck(mp != NULL);
 144:../../os/rt/src/chmtx.c **** 
 145:../../os/rt/src/chmtx.c ****   /* Is the mutex already locked? */
 146:../../os/rt/src/chmtx.c ****   if (mp->owner != NULL) {
  83               		.loc 1 146 0
  84 0012 EC81      		ldd r30,Y+4
  85 0014 FD81      		ldd r31,Y+5
  86 0016 3097      		sbiw r30,0
  87 0018 01F4      		brne .+2
  88 001a 00C0      		rjmp .L24
  89               	.LVL4:
  90               	.LBB103:
 147:../../os/rt/src/chmtx.c **** #if CH_CFG_USE_MUTEXES_RECURSIVE == TRUE
 148:../../os/rt/src/chmtx.c **** 
 149:../../os/rt/src/chmtx.c ****     chDbgAssert(mp->cnt >= (cnt_t)1, "counter is not positive");
 150:../../os/rt/src/chmtx.c **** 
 151:../../os/rt/src/chmtx.c ****     /* If the mutex is already owned by this thread, the counter is increased
 152:../../os/rt/src/chmtx.c ****        and there is no need of more actions.*/
 153:../../os/rt/src/chmtx.c ****     if (mp->owner == currtp) {
 154:../../os/rt/src/chmtx.c ****       mp->cnt++;
 155:../../os/rt/src/chmtx.c ****     }
 156:../../os/rt/src/chmtx.c ****     else {
 157:../../os/rt/src/chmtx.c **** #endif
 158:../../os/rt/src/chmtx.c ****       /* Priority inheritance protocol; explores the thread-mutex dependencies
 159:../../os/rt/src/chmtx.c ****          boosting the priority of all the affected threads to equal the
 160:../../os/rt/src/chmtx.c ****          priority of the running thread requesting the mutex.*/
 161:../../os/rt/src/chmtx.c ****       thread_t *tp = mp->owner;
 162:../../os/rt/src/chmtx.c **** 
 163:../../os/rt/src/chmtx.c ****       /* Does the running thread have higher priority than the mutex
 164:../../os/rt/src/chmtx.c ****          owning thread? */
 165:../../os/rt/src/chmtx.c ****       while (tp->hdr.pqueue.prio < currtp->hdr.pqueue.prio) {
  91               		.loc 1 165 0
  92 001c D801      		movw r26,r16
  93 001e 1496      		adiw r26,4
  94 0020 8C91      		ld r24,X
  95               	.LVL5:
  96 0022 9481      		ldd r25,Z+4
  97 0024 9817      		cp r25,r24
  98 0026 00F4      		brsh .L6
  99               	.L12:
 166:../../os/rt/src/chmtx.c ****         /* Make priority of thread tp match the running thread's priority.*/
 167:../../os/rt/src/chmtx.c ****         tp->hdr.pqueue.prio = currtp->hdr.pqueue.prio;
 100               		.loc 1 167 0
 101 0028 8483      		std Z+4,r24
 168:../../os/rt/src/chmtx.c **** 
 169:../../os/rt/src/chmtx.c ****         /* The following states need priority queues reordering.*/
 170:../../os/rt/src/chmtx.c ****         switch (tp->state) {
 102               		.loc 1 170 0
 103 002a 8785      		ldd r24,Z+15
 104 002c 8630      		cpi r24,lo8(6)
 105 002e 01F4      		brne .+2
 106 0030 00C0      		rjmp .L7
 107 0032 8730      		cpi r24,lo8(7)
 108 0034 01F0      		breq .L8
 109 0036 8823      		tst r24
 110 0038 01F4      		brne .+2
 111 003a 00C0      		rjmp .L25
 112               	.LVL6:
 113               	.L6:
 171:../../os/rt/src/chmtx.c ****         case CH_STATE_WTMTX:
 172:../../os/rt/src/chmtx.c ****           /* Re-enqueues the mutex owner with its new priority.*/
 173:../../os/rt/src/chmtx.c ****           ch_sch_prio_insert(&tp->u.wtmtxp->queue,
 174:../../os/rt/src/chmtx.c ****                              ch_queue_dequeue(&tp->hdr.queue));
 175:../../os/rt/src/chmtx.c ****           tp = tp->u.wtmtxp->owner;
 176:../../os/rt/src/chmtx.c ****           /*lint -e{9042} [16.1] Continues the while.*/
 177:../../os/rt/src/chmtx.c ****           continue;
 178:../../os/rt/src/chmtx.c **** #if (CH_CFG_USE_CONDVARS == TRUE) ||                                        \
 179:../../os/rt/src/chmtx.c ****     ((CH_CFG_USE_SEMAPHORES == TRUE) &&                                     \
 180:../../os/rt/src/chmtx.c ****      (CH_CFG_USE_SEMAPHORES_PRIORITY == TRUE)) ||                           \
 181:../../os/rt/src/chmtx.c ****     ((CH_CFG_USE_MESSAGES == TRUE) &&                                       \
 182:../../os/rt/src/chmtx.c ****      (CH_CFG_USE_MESSAGES_PRIORITY == TRUE))
 183:../../os/rt/src/chmtx.c **** #if CH_CFG_USE_CONDVARS == TRUE
 184:../../os/rt/src/chmtx.c ****         case CH_STATE_WTCOND:
 185:../../os/rt/src/chmtx.c **** #endif
 186:../../os/rt/src/chmtx.c **** #if (CH_CFG_USE_SEMAPHORES == TRUE) &&                                      \
 187:../../os/rt/src/chmtx.c ****     (CH_CFG_USE_SEMAPHORES_PRIORITY == TRUE)
 188:../../os/rt/src/chmtx.c ****         case CH_STATE_WTSEM:
 189:../../os/rt/src/chmtx.c **** #endif
 190:../../os/rt/src/chmtx.c **** #if (CH_CFG_USE_MESSAGES == TRUE) && (CH_CFG_USE_MESSAGES_PRIORITY == TRUE)
 191:../../os/rt/src/chmtx.c ****         case CH_STATE_SNDMSGQ:
 192:../../os/rt/src/chmtx.c **** #endif
 193:../../os/rt/src/chmtx.c ****           /* Re-enqueues tp with its new priority on the queue.*/
 194:../../os/rt/src/chmtx.c ****           ch_sch_prio_insert(&tp->u.wtmtxp->queue,
 195:../../os/rt/src/chmtx.c ****                              ch_queue_dequeue(&tp->hdr.queue));
 196:../../os/rt/src/chmtx.c ****           break;
 197:../../os/rt/src/chmtx.c **** #endif
 198:../../os/rt/src/chmtx.c ****         case CH_STATE_READY:
 199:../../os/rt/src/chmtx.c **** #if CH_DBG_ENABLE_ASSERTS == TRUE
 200:../../os/rt/src/chmtx.c ****           /* Prevents an assertion in chSchReadyI().*/
 201:../../os/rt/src/chmtx.c ****           tp->state = CH_STATE_CURRENT;
 202:../../os/rt/src/chmtx.c **** #endif
 203:../../os/rt/src/chmtx.c ****           /* Re-enqueues tp with its new priority on the ready list.*/
 204:../../os/rt/src/chmtx.c ****           (void) chSchReadyI(threadref(ch_queue_dequeue(&tp->hdr.queue)));
 205:../../os/rt/src/chmtx.c ****           break;
 206:../../os/rt/src/chmtx.c ****         default:
 207:../../os/rt/src/chmtx.c ****           /* Nothing to do for other states.*/
 208:../../os/rt/src/chmtx.c ****           break;
 209:../../os/rt/src/chmtx.c ****         }
 210:../../os/rt/src/chmtx.c ****         break;
 211:../../os/rt/src/chmtx.c ****       }
 212:../../os/rt/src/chmtx.c **** 
 213:../../os/rt/src/chmtx.c ****       /* Sleep on the mutex.*/
 214:../../os/rt/src/chmtx.c ****       ch_sch_prio_insert(&mp->queue, &currtp->hdr.queue);
 114               		.loc 1 214 0
 115 003c 9E01      		movw r18,r28
 116               	.LVL7:
 117 003e FE01      		movw r30,r28
 118 0040 00C0      		rjmp .L17
 119               	.LVL8:
 120               	.L27:
 121               	.LBB104:
 122               	.LBB105:
 123               		.file 4 "../../os/rt/include/chschd.h"
   1:../../os/rt/include/chschd.h **** /*
   2:../../os/rt/include/chschd.h ****     ChibiOS - Copyright (C) 2006,2007,2008,2009,2010,2011,2012,2013,2014,
   3:../../os/rt/include/chschd.h ****               2015,2016,2017,2018,2019,2020,2021 Giovanni Di Sirio.
   4:../../os/rt/include/chschd.h **** 
   5:../../os/rt/include/chschd.h ****     This file is part of ChibiOS.
   6:../../os/rt/include/chschd.h **** 
   7:../../os/rt/include/chschd.h ****     ChibiOS is free software; you can redistribute it and/or modify
   8:../../os/rt/include/chschd.h ****     it under the terms of the GNU General Public License as published by
   9:../../os/rt/include/chschd.h ****     the Free Software Foundation version 3 of the License.
  10:../../os/rt/include/chschd.h **** 
  11:../../os/rt/include/chschd.h ****     ChibiOS is distributed in the hope that it will be useful,
  12:../../os/rt/include/chschd.h ****     but WITHOUT ANY WARRANTY; without even the implied warranty of
  13:../../os/rt/include/chschd.h ****     MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
  14:../../os/rt/include/chschd.h ****     GNU General Public License for more details.
  15:../../os/rt/include/chschd.h **** 
  16:../../os/rt/include/chschd.h ****     You should have received a copy of the GNU General Public License
  17:../../os/rt/include/chschd.h ****     along with this program.  If not, see <http://www.gnu.org/licenses/>.
  18:../../os/rt/include/chschd.h **** */
  19:../../os/rt/include/chschd.h **** 
  20:../../os/rt/include/chschd.h **** /**
  21:../../os/rt/include/chschd.h ****  * @file    rt/include/chschd.h
  22:../../os/rt/include/chschd.h ****  * @brief   Scheduler macros and structures.
  23:../../os/rt/include/chschd.h ****  *
  24:../../os/rt/include/chschd.h ****  * @addtogroup scheduler
  25:../../os/rt/include/chschd.h ****  * @{
  26:../../os/rt/include/chschd.h ****  */
  27:../../os/rt/include/chschd.h **** 
  28:../../os/rt/include/chschd.h **** #ifndef CHSCHD_H
  29:../../os/rt/include/chschd.h **** #define CHSCHD_H
  30:../../os/rt/include/chschd.h **** 
  31:../../os/rt/include/chschd.h **** /*===========================================================================*/
  32:../../os/rt/include/chschd.h **** /* Module constants.                                                         */
  33:../../os/rt/include/chschd.h **** /*===========================================================================*/
  34:../../os/rt/include/chschd.h **** 
  35:../../os/rt/include/chschd.h **** /**
  36:../../os/rt/include/chschd.h ****  * @name    Wakeup status codes
  37:../../os/rt/include/chschd.h ****  * @{
  38:../../os/rt/include/chschd.h ****  */
  39:../../os/rt/include/chschd.h **** #define MSG_OK              (msg_t)0    /**< @brief Normal wakeup message.  */
  40:../../os/rt/include/chschd.h **** #define MSG_TIMEOUT         (msg_t)-1   /**< @brief Wakeup caused by a timeout
  41:../../os/rt/include/chschd.h ****                                              condition.                     */
  42:../../os/rt/include/chschd.h **** #define MSG_RESET           (msg_t)-2   /**< @brief Wakeup caused by a reset
  43:../../os/rt/include/chschd.h ****                                              condition.                     */
  44:../../os/rt/include/chschd.h **** /** @} */
  45:../../os/rt/include/chschd.h **** 
  46:../../os/rt/include/chschd.h **** /**
  47:../../os/rt/include/chschd.h ****  * @name    Priority constants
  48:../../os/rt/include/chschd.h ****  * @{
  49:../../os/rt/include/chschd.h ****  */
  50:../../os/rt/include/chschd.h **** #define NOPRIO              (tprio_t)0      /**< @brief Ready list header
  51:../../os/rt/include/chschd.h ****                                                  priority.                  */
  52:../../os/rt/include/chschd.h **** #define IDLEPRIO            (tprio_t)1      /**< @brief Idle priority.      */
  53:../../os/rt/include/chschd.h **** #define LOWPRIO             (tprio_t)2      /**< @brief Lowest priority.    */
  54:../../os/rt/include/chschd.h **** #define NORMALPRIO          (tprio_t)128    /**< @brief Normal priority.    */
  55:../../os/rt/include/chschd.h **** #define HIGHPRIO            (tprio_t)255    /**< @brief Highest priority.   */
  56:../../os/rt/include/chschd.h **** /** @} */
  57:../../os/rt/include/chschd.h **** 
  58:../../os/rt/include/chschd.h **** /**
  59:../../os/rt/include/chschd.h ****  * @name    Thread states
  60:../../os/rt/include/chschd.h ****  * @{
  61:../../os/rt/include/chschd.h ****  */
  62:../../os/rt/include/chschd.h **** #define CH_STATE_READY      (tstate_t)0      /**< @brief Waiting on the
  63:../../os/rt/include/chschd.h ****                                                   ready list.               */
  64:../../os/rt/include/chschd.h **** #define CH_STATE_CURRENT    (tstate_t)1      /**< @brief Currently running. */
  65:../../os/rt/include/chschd.h **** #define CH_STATE_WTSTART    (tstate_t)2      /**< @brief Just created.      */
  66:../../os/rt/include/chschd.h **** #define CH_STATE_SUSPENDED  (tstate_t)3      /**< @brief Suspended state.   */
  67:../../os/rt/include/chschd.h **** #define CH_STATE_QUEUED     (tstate_t)4      /**< @brief On a queue.        */
  68:../../os/rt/include/chschd.h **** #define CH_STATE_WTSEM      (tstate_t)5      /**< @brief On a semaphore.    */
  69:../../os/rt/include/chschd.h **** #define CH_STATE_WTMTX      (tstate_t)6      /**< @brief On a mutex.        */
  70:../../os/rt/include/chschd.h **** #define CH_STATE_WTCOND     (tstate_t)7      /**< @brief On a cond.variable.*/
  71:../../os/rt/include/chschd.h **** #define CH_STATE_SLEEPING   (tstate_t)8      /**< @brief Sleeping.          */
  72:../../os/rt/include/chschd.h **** #define CH_STATE_WTEXIT     (tstate_t)9      /**< @brief Waiting a thread.  */
  73:../../os/rt/include/chschd.h **** #define CH_STATE_WTOREVT    (tstate_t)10     /**< @brief One event.         */
  74:../../os/rt/include/chschd.h **** #define CH_STATE_WTANDEVT   (tstate_t)11     /**< @brief Several events.    */
  75:../../os/rt/include/chschd.h **** #define CH_STATE_SNDMSGQ    (tstate_t)12     /**< @brief Sending a message,
  76:../../os/rt/include/chschd.h ****                                                   in queue.                 */
  77:../../os/rt/include/chschd.h **** #define CH_STATE_SNDMSG     (tstate_t)13     /**< @brief Sent a message,
  78:../../os/rt/include/chschd.h ****                                                   waiting answer.           */
  79:../../os/rt/include/chschd.h **** #define CH_STATE_WTMSG      (tstate_t)14     /**< @brief Waiting for a
  80:../../os/rt/include/chschd.h ****                                                   message.                  */
  81:../../os/rt/include/chschd.h **** #define CH_STATE_FINAL      (tstate_t)15     /**< @brief Thread terminated. */
  82:../../os/rt/include/chschd.h **** 
  83:../../os/rt/include/chschd.h **** /**
  84:../../os/rt/include/chschd.h ****  * @brief   Thread states as array of strings.
  85:../../os/rt/include/chschd.h ****  * @details Each element in an array initialized with this macro can be
  86:../../os/rt/include/chschd.h ****  *          indexed using the numeric thread state values.
  87:../../os/rt/include/chschd.h ****  */
  88:../../os/rt/include/chschd.h **** #define CH_STATE_NAMES                                                     \
  89:../../os/rt/include/chschd.h ****   "READY", "CURRENT", "WTSTART", "SUSPENDED", "QUEUED", "WTSEM", "WTMTX",  \
  90:../../os/rt/include/chschd.h ****   "WTCOND", "SLEEPING", "WTEXIT", "WTOREVT", "WTANDEVT", "SNDMSGQ",        \
  91:../../os/rt/include/chschd.h ****   "SNDMSG", "WTMSG", "FINAL"
  92:../../os/rt/include/chschd.h **** /** @} */
  93:../../os/rt/include/chschd.h **** 
  94:../../os/rt/include/chschd.h **** /**
  95:../../os/rt/include/chschd.h ****  * @name    Thread flags and attributes
  96:../../os/rt/include/chschd.h ****  * @{
  97:../../os/rt/include/chschd.h ****  */
  98:../../os/rt/include/chschd.h **** #define CH_FLAG_MODE_MASK   (tmode_t)3U     /**< @brief Thread memory mode
  99:../../os/rt/include/chschd.h ****                                                  mask.                      */
 100:../../os/rt/include/chschd.h **** #define CH_FLAG_MODE_STATIC (tmode_t)0U     /**< @brief Static thread.      */
 101:../../os/rt/include/chschd.h **** #define CH_FLAG_MODE_HEAP   (tmode_t)1U     /**< @brief Thread allocated
 102:../../os/rt/include/chschd.h ****                                                  from a Memory Heap.        */
 103:../../os/rt/include/chschd.h **** #define CH_FLAG_MODE_MPOOL  (tmode_t)2U     /**< @brief Thread allocated
 104:../../os/rt/include/chschd.h ****                                                  from a Memory Pool.        */
 105:../../os/rt/include/chschd.h **** #define CH_FLAG_TERMINATE   (tmode_t)4U     /**< @brief Termination requested
 106:../../os/rt/include/chschd.h ****                                                  flag.                      */
 107:../../os/rt/include/chschd.h **** /** @} */
 108:../../os/rt/include/chschd.h **** 
 109:../../os/rt/include/chschd.h **** /*===========================================================================*/
 110:../../os/rt/include/chschd.h **** /* Module pre-compile time settings.                                         */
 111:../../os/rt/include/chschd.h **** /*===========================================================================*/
 112:../../os/rt/include/chschd.h **** 
 113:../../os/rt/include/chschd.h **** /*===========================================================================*/
 114:../../os/rt/include/chschd.h **** /* Derived constants and error checks.                                       */
 115:../../os/rt/include/chschd.h **** /*===========================================================================*/
 116:../../os/rt/include/chschd.h **** 
 117:../../os/rt/include/chschd.h **** /*===========================================================================*/
 118:../../os/rt/include/chschd.h **** /* Module data structures and types.                                         */
 119:../../os/rt/include/chschd.h **** /*===========================================================================*/
 120:../../os/rt/include/chschd.h **** 
 121:../../os/rt/include/chschd.h **** /*===========================================================================*/
 122:../../os/rt/include/chschd.h **** /* Module macros.                                                            */
 123:../../os/rt/include/chschd.h **** /*===========================================================================*/
 124:../../os/rt/include/chschd.h **** 
 125:../../os/rt/include/chschd.h **** /**
 126:../../os/rt/include/chschd.h ****  * @brief   Returns the priority of the first thread on the given ready list.
 127:../../os/rt/include/chschd.h ****  *
 128:../../os/rt/include/chschd.h ****  * @notapi
 129:../../os/rt/include/chschd.h ****  */
 130:../../os/rt/include/chschd.h **** #define firstprio(rlp)              ((rlp)->next->prio)
 131:../../os/rt/include/chschd.h **** 
 132:../../os/rt/include/chschd.h **** /**
 133:../../os/rt/include/chschd.h ****  * @brief   Current thread pointer get macro.
 134:../../os/rt/include/chschd.h ****  * @note    This macro is not meant to be used in the application code but
 135:../../os/rt/include/chschd.h ****  *          only from within the kernel, use @p chThdGetSelfX() instead.
 136:../../os/rt/include/chschd.h ****  */
 137:../../os/rt/include/chschd.h **** #define __sch_get_currthread()      __instance_get_currthread(currcore)
 138:../../os/rt/include/chschd.h **** 
 139:../../os/rt/include/chschd.h **** /*===========================================================================*/
 140:../../os/rt/include/chschd.h **** /* External declarations.                                                    */
 141:../../os/rt/include/chschd.h **** /*===========================================================================*/
 142:../../os/rt/include/chschd.h **** 
 143:../../os/rt/include/chschd.h **** /*
 144:../../os/rt/include/chschd.h ****  * Scheduler APIs.
 145:../../os/rt/include/chschd.h ****  */
 146:../../os/rt/include/chschd.h **** #ifdef __cplusplus
 147:../../os/rt/include/chschd.h **** extern "C" {
 148:../../os/rt/include/chschd.h **** #endif
 149:../../os/rt/include/chschd.h ****   void chSchObjectInit(os_instance_t *oip,
 150:../../os/rt/include/chschd.h ****                        const os_instance_config_t *oicp);
 151:../../os/rt/include/chschd.h ****   thread_t *chSchReadyI(thread_t *tp);
 152:../../os/rt/include/chschd.h ****   void chSchGoSleepS(tstate_t newstate);
 153:../../os/rt/include/chschd.h ****   msg_t chSchGoSleepTimeoutS(tstate_t newstate, sysinterval_t timeout);
 154:../../os/rt/include/chschd.h ****   void chSchWakeupS(thread_t *ntp, msg_t msg);
 155:../../os/rt/include/chschd.h ****   void chSchRescheduleS(void);
 156:../../os/rt/include/chschd.h ****   bool chSchIsPreemptionRequired(void);
 157:../../os/rt/include/chschd.h ****   void chSchDoPreemption(void);
 158:../../os/rt/include/chschd.h ****   void chSchPreemption(void);
 159:../../os/rt/include/chschd.h ****   void chSchDoYieldS(void);
 160:../../os/rt/include/chschd.h ****   thread_t *chSchSelectFirst(void);
 161:../../os/rt/include/chschd.h **** #if CH_CFG_OPTIMIZE_SPEED == FALSE
 162:../../os/rt/include/chschd.h ****   void ch_sch_prio_insert(ch_queue_t *qp, ch_queue_t *tp);
 163:../../os/rt/include/chschd.h **** #endif /* CH_CFG_OPTIMIZE_SPEED == FALSE */
 164:../../os/rt/include/chschd.h **** #ifdef __cplusplus
 165:../../os/rt/include/chschd.h **** }
 166:../../os/rt/include/chschd.h **** #endif
 167:../../os/rt/include/chschd.h **** 
 168:../../os/rt/include/chschd.h **** /*===========================================================================*/
 169:../../os/rt/include/chschd.h **** /* Module inline functions.                                                  */
 170:../../os/rt/include/chschd.h **** /*===========================================================================*/
 171:../../os/rt/include/chschd.h **** 
 172:../../os/rt/include/chschd.h **** /* If the performance code path has been chosen then all the following
 173:../../os/rt/include/chschd.h ****    functions are inlined into the various kernel modules.*/
 174:../../os/rt/include/chschd.h **** #if CH_CFG_OPTIMIZE_SPEED == TRUE
 175:../../os/rt/include/chschd.h **** static inline void ch_sch_prio_insert(ch_queue_t *qp, ch_queue_t *tp) {
 176:../../os/rt/include/chschd.h **** 
 177:../../os/rt/include/chschd.h ****   ch_queue_t *cp = qp;
 178:../../os/rt/include/chschd.h ****   do {
 179:../../os/rt/include/chschd.h ****     cp = cp->next;
 180:../../os/rt/include/chschd.h ****   } while ((cp != qp) &&
 124               		.loc 4 180 0
 125 0042 9481      		ldd r25,Z+4
 126 0044 D801      		movw r26,r16
 127 0046 1496      		adiw r26,4
 128 0048 8C91      		ld r24,X
 129 004a 9817      		cp r25,r24
 130 004c 00F4      		brsh .+2
 131 004e 00C0      		rjmp .L26
 132               	.L17:
 179:../../os/rt/include/chschd.h ****   } while ((cp != qp) &&
 133               		.loc 4 179 0
 134 0050 0190      		ld __tmp_reg__,Z+
 135 0052 F081      		ld r31,Z
 136 0054 E02D      		mov r30,__tmp_reg__
 137               	.LVL9:
 181:../../os/rt/include/chschd.h ****            (threadref(cp)->hdr.pqueue.prio >= threadref(tp)->hdr.pqueue.prio));
 138               		.loc 4 181 0
 139 0056 CE17      		cp r28,r30
 140 0058 DF07      		cpc r29,r31
 141 005a 01F4      		brne .L27
 142               	.LVL10:
 143               	.L16:
 182:../../os/rt/include/chschd.h ****   tp->next       = cp;
 144               		.loc 4 182 0
 145 005c F801      		movw r30,r16
 146               	.LVL11:
 147 005e 3183      		std Z+1,r19
 148 0060 2083      		st Z,r18
 183:../../os/rt/include/chschd.h ****   tp->prev       = cp->prev;
 149               		.loc 4 183 0
 150 0062 D901      		movw r26,r18
 151 0064 1296      		adiw r26,2
 152 0066 ED91      		ld r30,X+
 153 0068 FC91      		ld r31,X
 154 006a D801      		movw r26,r16
 155 006c 1396      		adiw r26,2+1
 156 006e FC93      		st X,r31
 157 0070 EE93      		st -X,r30
 158 0072 1297      		sbiw r26,2
 184:../../os/rt/include/chschd.h ****   tp->prev->next = tp;
 159               		.loc 4 184 0
 160 0074 1183      		std Z+1,r17
 161 0076 0083      		st Z,r16
 185:../../os/rt/include/chschd.h ****   cp->prev       = tp;
 162               		.loc 4 185 0
 163 0078 F901      		movw r30,r18
 164 007a 1383      		std Z+3,r17
 165 007c 0283      		std Z+2,r16
 166               	.LVL12:
 167               	.LBE105:
 168               	.LBE104:
 215:../../os/rt/src/chmtx.c ****       currtp->u.wtmtxp = mp;
 169               		.loc 1 215 0
 170 007e 5396      		adiw r26,18+1
 171 0080 DC93      		st X,r29
 172 0082 CE93      		st -X,r28
 173 0084 5297      		sbiw r26,18
 216:../../os/rt/src/chmtx.c ****       chSchGoSleepS(CH_STATE_WTMTX);
 174               		.loc 1 216 0
 175 0086 86E0      		ldi r24,lo8(6)
 176               	/* epilogue start */
 177               	.LBE103:
 217:../../os/rt/src/chmtx.c **** 
 218:../../os/rt/src/chmtx.c ****       /* It is assumed that the thread performing the unlock operation assigns
 219:../../os/rt/src/chmtx.c ****          the mutex to this thread.*/
 220:../../os/rt/src/chmtx.c ****       chDbgAssert(mp->owner == currtp, "not owner");
 221:../../os/rt/src/chmtx.c ****       chDbgAssert(currtp->mtxlist == mp, "not owned");
 222:../../os/rt/src/chmtx.c **** #if CH_CFG_USE_MUTEXES_RECURSIVE == TRUE
 223:../../os/rt/src/chmtx.c ****       chDbgAssert(mp->cnt == (cnt_t)1, "counter is not one");
 224:../../os/rt/src/chmtx.c ****     }
 225:../../os/rt/src/chmtx.c **** #endif
 226:../../os/rt/src/chmtx.c ****   }
 227:../../os/rt/src/chmtx.c ****   else {
 228:../../os/rt/src/chmtx.c **** #if CH_CFG_USE_MUTEXES_RECURSIVE == TRUE
 229:../../os/rt/src/chmtx.c ****     chDbgAssert(mp->cnt == (cnt_t)0, "counter is not zero");
 230:../../os/rt/src/chmtx.c **** 
 231:../../os/rt/src/chmtx.c ****     mp->cnt++;
 232:../../os/rt/src/chmtx.c **** #endif
 233:../../os/rt/src/chmtx.c ****     /* It was not owned, inserted in the owned mutexes list.*/
 234:../../os/rt/src/chmtx.c ****     mp->owner = currtp;
 235:../../os/rt/src/chmtx.c ****     mp->next = currtp->mtxlist;
 236:../../os/rt/src/chmtx.c ****     currtp->mtxlist = mp;
 237:../../os/rt/src/chmtx.c ****   }
 238:../../os/rt/src/chmtx.c **** }
 178               		.loc 1 238 0
 179 0088 DF91      		pop r29
 180 008a CF91      		pop r28
 181               	.LVL13:
 182 008c 1F91      		pop r17
 183 008e 0F91      		pop r16
 184               	.LBB122:
 216:../../os/rt/src/chmtx.c ****       chSchGoSleepS(CH_STATE_WTMTX);
 185               		.loc 1 216 0
 186 0090 0C94 0000 		jmp chSchGoSleepS
 187               	.LVL14:
 188               	.L8:
 189               	.LBB107:
 190               	.LBB108:
 226:../../os/rt/include/chlists.h **** }
 227:../../os/rt/include/chlists.h **** 
 228:../../os/rt/include/chlists.h **** /**
 229:../../os/rt/include/chlists.h ****  * @brief   Evaluates to @p true if the specified queue is empty.
 230:../../os/rt/include/chlists.h ****  *
 231:../../os/rt/include/chlists.h ****  * @param[in] qp        pointer to the queue header
 232:../../os/rt/include/chlists.h ****  * @return              The status of the queue.
 233:../../os/rt/include/chlists.h ****  *
 234:../../os/rt/include/chlists.h ****  * @notapi
 235:../../os/rt/include/chlists.h ****  */
 236:../../os/rt/include/chlists.h **** static inline bool ch_queue_isempty(const ch_queue_t *qp) {
 237:../../os/rt/include/chlists.h **** 
 238:../../os/rt/include/chlists.h ****   return (bool)(qp->next == qp);
 239:../../os/rt/include/chlists.h **** }
 240:../../os/rt/include/chlists.h **** 
 241:../../os/rt/include/chlists.h **** /**
 242:../../os/rt/include/chlists.h ****  * @brief   Evaluates to @p true if the specified queue is not empty.
 243:../../os/rt/include/chlists.h ****  *
 244:../../os/rt/include/chlists.h ****  * @param[in] qp        pointer to the queue header
 245:../../os/rt/include/chlists.h ****  * @return              The status of the queue.
 246:../../os/rt/include/chlists.h ****  *
 247:../../os/rt/include/chlists.h ****  * @notapi
 248:../../os/rt/include/chlists.h ****  */
 249:../../os/rt/include/chlists.h **** static inline bool ch_queue_notempty(const ch_queue_t *qp) {
 250:../../os/rt/include/chlists.h **** 
 251:../../os/rt/include/chlists.h ****   return (bool)(qp->next != qp);
 252:../../os/rt/include/chlists.h **** }
 253:../../os/rt/include/chlists.h **** 
 254:../../os/rt/include/chlists.h **** /**
 255:../../os/rt/include/chlists.h ****  * @brief   Inserts an element into a queue.
 256:../../os/rt/include/chlists.h ****  *
 257:../../os/rt/include/chlists.h ****  * @param[in] qp        the pointer to the queue header
 258:../../os/rt/include/chlists.h ****  * @param[in] p         the pointer to the element to be inserted in the queue
 259:../../os/rt/include/chlists.h ****  *
 260:../../os/rt/include/chlists.h ****  * @notapi
 261:../../os/rt/include/chlists.h ****  */
 262:../../os/rt/include/chlists.h **** static inline void ch_queue_insert(ch_queue_t *qp, ch_queue_t *p) {
 263:../../os/rt/include/chlists.h **** 
 264:../../os/rt/include/chlists.h ****   p->next       = qp;
 265:../../os/rt/include/chlists.h ****   p->prev       = qp->prev;
 266:../../os/rt/include/chlists.h ****   p->prev->next = p;
 267:../../os/rt/include/chlists.h ****   qp->prev      = p;
 268:../../os/rt/include/chlists.h **** }
 269:../../os/rt/include/chlists.h **** 
 270:../../os/rt/include/chlists.h **** /**
 271:../../os/rt/include/chlists.h ****  * @brief   Removes the first-out element from a queue and returns it.
 272:../../os/rt/include/chlists.h ****  * @note    If the queue is priority ordered then this function returns the
 273:../../os/rt/include/chlists.h ****  *          element with the highest priority.
 274:../../os/rt/include/chlists.h ****  *
 275:../../os/rt/include/chlists.h ****  * @param[in] qp        the pointer to the queue list header
 276:../../os/rt/include/chlists.h ****  * @return              The removed element pointer.
 277:../../os/rt/include/chlists.h ****  *
 278:../../os/rt/include/chlists.h ****  * @notapi
 279:../../os/rt/include/chlists.h ****  */
 280:../../os/rt/include/chlists.h **** static inline ch_queue_t *ch_queue_fifo_remove(ch_queue_t *qp) {
 281:../../os/rt/include/chlists.h ****   ch_queue_t *p = qp->next;
 282:../../os/rt/include/chlists.h **** 
 283:../../os/rt/include/chlists.h ****   qp->next       = p->next;
 284:../../os/rt/include/chlists.h ****   qp->next->prev = qp;
 285:../../os/rt/include/chlists.h **** 
 286:../../os/rt/include/chlists.h ****   return p;
 287:../../os/rt/include/chlists.h **** }
 288:../../os/rt/include/chlists.h **** 
 289:../../os/rt/include/chlists.h **** /**
 290:../../os/rt/include/chlists.h ****  * @brief   Removes the last-out element from a queue and returns it.
 291:../../os/rt/include/chlists.h ****  * @note    If the queue is priority ordered then this function returns the
 292:../../os/rt/include/chlists.h ****  *          element with the lowest priority.
 293:../../os/rt/include/chlists.h ****  *
 294:../../os/rt/include/chlists.h ****  * @param[in] qp    the pointer to the queue list header
 295:../../os/rt/include/chlists.h ****  * @return          The removed element pointer.
 296:../../os/rt/include/chlists.h ****  *
 297:../../os/rt/include/chlists.h ****  * @notapi
 298:../../os/rt/include/chlists.h ****  */
 299:../../os/rt/include/chlists.h **** static inline ch_queue_t *ch_queue_lifo_remove(ch_queue_t *qp) {
 300:../../os/rt/include/chlists.h ****   ch_queue_t *p = qp->prev;
 301:../../os/rt/include/chlists.h **** 
 302:../../os/rt/include/chlists.h ****   qp->prev       = p->prev;
 303:../../os/rt/include/chlists.h ****   qp->prev->next = qp;
 304:../../os/rt/include/chlists.h **** 
 305:../../os/rt/include/chlists.h ****   return p;
 306:../../os/rt/include/chlists.h **** }
 307:../../os/rt/include/chlists.h **** 
 308:../../os/rt/include/chlists.h **** /**
 309:../../os/rt/include/chlists.h ****  * @brief   Removes an element from a queue and returns it.
 310:../../os/rt/include/chlists.h ****  * @details The element is removed from the queue regardless of its relative
 311:../../os/rt/include/chlists.h ****  *          position and regardless the used insertion method.
 312:../../os/rt/include/chlists.h ****  *
 313:../../os/rt/include/chlists.h ****  * @param[in] p         the pointer to the element to be removed from the queue
 314:../../os/rt/include/chlists.h ****  * @return              The removed element pointer.
 315:../../os/rt/include/chlists.h ****  *
 316:../../os/rt/include/chlists.h ****  * @notapi
 317:../../os/rt/include/chlists.h ****  */
 318:../../os/rt/include/chlists.h **** static inline ch_queue_t *ch_queue_dequeue(ch_queue_t *p) {
 319:../../os/rt/include/chlists.h **** 
 320:../../os/rt/include/chlists.h ****   p->prev->next = p->next;
 191               		.loc 2 320 0
 192 0094 2281      		ldd r18,Z+2
 193 0096 3381      		ldd r19,Z+3
 194 0098 8081      		ld r24,Z
 195 009a 9181      		ldd r25,Z+1
 196 009c D901      		movw r26,r18
 197 009e 8D93      		st X+,r24
 198 00a0 9C93      		st X,r25
 321:../../os/rt/include/chlists.h ****   p->next->prev = p->prev;
 199               		.loc 2 321 0
 200 00a2 8081      		ld r24,Z
 201 00a4 9181      		ldd r25,Z+1
 202 00a6 DC01      		movw r26,r24
 203 00a8 1396      		adiw r26,2+1
 204 00aa 3C93      		st X,r19
 205 00ac 2E93      		st -X,r18
 206 00ae 1297      		sbiw r26,2
 207               	.LVL15:
 208               	.LBE108:
 209               	.LBE107:
 194:../../os/rt/src/chmtx.c ****                              ch_queue_dequeue(&tp->hdr.queue));
 210               		.loc 1 194 0
 211 00b0 2289      		ldd r18,Z+18
 212 00b2 3389      		ldd r19,Z+19
 213               	.LVL16:
 214 00b4 D901      		movw r26,r18
 215 00b6 00C0      		rjmp .L14
 216               	.LVL17:
 217               	.L29:
 218               	.LBB109:
 219               	.LBB110:
 180:../../os/rt/include/chschd.h ****            (threadref(cp)->hdr.pqueue.prio >= threadref(tp)->hdr.pqueue.prio));
 220               		.loc 4 180 0
 221 00b8 1496      		adiw r26,4
 222 00ba 9C91      		ld r25,X
 223 00bc 1497      		sbiw r26,4
 224 00be 8481      		ldd r24,Z+4
 225 00c0 9817      		cp r25,r24
 226 00c2 00F4      		brsh .+2
 227 00c4 00C0      		rjmp .L28
 228               	.LVL18:
 229               	.L14:
 179:../../os/rt/include/chschd.h ****   } while ((cp != qp) &&
 230               		.loc 4 179 0
 231 00c6 0D90      		ld __tmp_reg__,X+
 232 00c8 BC91      		ld r27,X
 233 00ca A02D      		mov r26,__tmp_reg__
 234               	.LVL19:
 181:../../os/rt/include/chschd.h ****   tp->next       = cp;
 235               		.loc 4 181 0
 236 00cc 2A17      		cp r18,r26
 237 00ce 3B07      		cpc r19,r27
 238 00d0 01F4      		brne .L29
 239               	.LVL20:
 240               	.L13:
 182:../../os/rt/include/chschd.h ****   tp->prev       = cp->prev;
 241               		.loc 4 182 0
 242 00d2 3183      		std Z+1,r19
 243 00d4 2083      		st Z,r18
 183:../../os/rt/include/chschd.h ****   tp->prev->next = tp;
 244               		.loc 4 183 0
 245 00d6 D901      		movw r26,r18
 246               	.LVL21:
 247 00d8 1296      		adiw r26,2
 248 00da 8D91      		ld r24,X+
 249 00dc 9C91      		ld r25,X
 250 00de 9383      		std Z+3,r25
 251 00e0 8283      		std Z+2,r24
 184:../../os/rt/include/chschd.h ****   cp->prev       = tp;
 252               		.loc 4 184 0
 253 00e2 DC01      		movw r26,r24
 254 00e4 ED93      		st X+,r30
 255 00e6 FC93      		st X,r31
 256               	.LVL22:
 257               		.loc 4 185 0
 258 00e8 D901      		movw r26,r18
 259 00ea 1396      		adiw r26,2+1
 260 00ec FC93      		st X,r31
 261 00ee EE93      		st -X,r30
 262 00f0 1297      		sbiw r26,2
 263 00f2 00C0      		rjmp .L6
 264               	.L25:
 265               	.LVL23:
 266               	.LBE110:
 267               	.LBE109:
 268               	.LBB112:
 269               	.LBB113:
 320:../../os/rt/include/chlists.h ****   p->next->prev = p->prev;
 270               		.loc 2 320 0
 271 00f4 2281      		ldd r18,Z+2
 272 00f6 3381      		ldd r19,Z+3
 273 00f8 8081      		ld r24,Z
 274 00fa 9181      		ldd r25,Z+1
 275 00fc D901      		movw r26,r18
 276 00fe 8D93      		st X+,r24
 277 0100 9C93      		st X,r25
 278               		.loc 2 321 0
 279 0102 8081      		ld r24,Z
 280 0104 9181      		ldd r25,Z+1
 281 0106 DC01      		movw r26,r24
 282 0108 1396      		adiw r26,2+1
 283 010a 3C93      		st X,r19
 284 010c 2E93      		st -X,r18
 285 010e 1297      		sbiw r26,2
 286               	.LVL24:
 287               	.LBE113:
 288               	.LBE112:
 204:../../os/rt/src/chmtx.c ****           break;
 289               		.loc 1 204 0
 290 0110 CF01      		movw r24,r30
 291 0112 0E94 0000 		call chSchReadyI
 292               	.LVL25:
 205:../../os/rt/src/chmtx.c ****         default:
 293               		.loc 1 205 0
 294 0116 00C0      		rjmp .L6
 295               	.LVL26:
 296               	.L26:
 297               	.LBB114:
 298               	.LBB106:
 179:../../os/rt/include/chschd.h ****   } while ((cp != qp) &&
 299               		.loc 4 179 0
 300 0118 9F01      		movw r18,r30
 301               	.LVL27:
 302 011a 00C0      		rjmp .L16
 303               	.LVL28:
 304               	.L24:
 305               	.LBE106:
 306               	.LBE114:
 307               	.LBE122:
 234:../../os/rt/src/chmtx.c ****     mp->next = currtp->mtxlist;
 308               		.loc 1 234 0
 309 011c 1D83      		std Y+5,r17
 310 011e 0C83      		std Y+4,r16
 235:../../os/rt/src/chmtx.c ****     currtp->mtxlist = mp;
 311               		.loc 1 235 0
 312 0120 D801      		movw r26,r16
 313 0122 5B96      		adiw r26,27
 314 0124 8D91      		ld r24,X+
 315 0126 9C91      		ld r25,X
 316 0128 5C97      		sbiw r26,27+1
 317               	.LVL29:
 318 012a 9F83      		std Y+7,r25
 319 012c 8E83      		std Y+6,r24
 236:../../os/rt/src/chmtx.c ****   }
 320               		.loc 1 236 0
 321 012e 5C96      		adiw r26,27+1
 322 0130 DC93      		st X,r29
 323 0132 CE93      		st -X,r28
 324 0134 5B97      		sbiw r26,27
 325               	/* epilogue start */
 326               		.loc 1 238 0
 327 0136 DF91      		pop r29
 328 0138 CF91      		pop r28
 329               	.LVL30:
 330 013a 1F91      		pop r17
 331 013c 0F91      		pop r16
 332 013e 0895      		ret
 333               	.LVL31:
 334               	.L7:
 335               	.LBB123:
 336               	.LBB115:
 337               	.LBB116:
 320:../../os/rt/include/chlists.h ****   p->next->prev = p->prev;
 338               		.loc 2 320 0
 339 0140 2281      		ldd r18,Z+2
 340 0142 3381      		ldd r19,Z+3
 341 0144 8081      		ld r24,Z
 342 0146 9181      		ldd r25,Z+1
 343 0148 D901      		movw r26,r18
 344 014a 8D93      		st X+,r24
 345 014c 9C93      		st X,r25
 346               		.loc 2 321 0
 347 014e 8081      		ld r24,Z
 348 0150 9181      		ldd r25,Z+1
 349 0152 DC01      		movw r26,r24
 350 0154 1396      		adiw r26,2+1
 351 0156 3C93      		st X,r19
 352 0158 2E93      		st -X,r18
 353 015a 1297      		sbiw r26,2
 354               	.LVL32:
 355               	.LBE116:
 356               	.LBE115:
 173:../../os/rt/src/chmtx.c ****                              ch_queue_dequeue(&tp->hdr.queue));
 357               		.loc 1 173 0
 358 015c 2289      		ldd r18,Z+18
 359 015e 3389      		ldd r19,Z+19
 360               	.LVL33:
 361 0160 D901      		movw r26,r18
 362 0162 00C0      		rjmp .L11
 363               	.LVL34:
 364               	.L31:
 365               	.LBB117:
 366               	.LBB118:
 180:../../os/rt/include/chschd.h ****            (threadref(cp)->hdr.pqueue.prio >= threadref(tp)->hdr.pqueue.prio));
 367               		.loc 4 180 0
 368 0164 1496      		adiw r26,4
 369 0166 9C91      		ld r25,X
 370 0168 1497      		sbiw r26,4
 371 016a 8481      		ldd r24,Z+4
 372 016c 9817      		cp r25,r24
 373 016e 00F0      		brlo .L30
 374               	.LVL35:
 375               	.L11:
 179:../../os/rt/include/chschd.h ****   } while ((cp != qp) &&
 376               		.loc 4 179 0
 377 0170 0D90      		ld __tmp_reg__,X+
 378 0172 BC91      		ld r27,X
 379 0174 A02D      		mov r26,__tmp_reg__
 380               	.LVL36:
 181:../../os/rt/include/chschd.h ****   tp->next       = cp;
 381               		.loc 4 181 0
 382 0176 2A17      		cp r18,r26
 383 0178 3B07      		cpc r19,r27
 384 017a 01F4      		brne .L31
 385               	.LVL37:
 386               	.L10:
 182:../../os/rt/include/chschd.h ****   tp->prev       = cp->prev;
 387               		.loc 4 182 0
 388 017c 3183      		std Z+1,r19
 389 017e 2083      		st Z,r18
 183:../../os/rt/include/chschd.h ****   tp->prev->next = tp;
 390               		.loc 4 183 0
 391 0180 D901      		movw r26,r18
 392               	.LVL38:
 393 0182 1296      		adiw r26,2
 394 0184 8D91      		ld r24,X+
 395 0186 9C91      		ld r25,X
 396 0188 9383      		std Z+3,r25
 397 018a 8283      		std Z+2,r24
 184:../../os/rt/include/chschd.h ****   cp->prev       = tp;
 398               		.loc 4 184 0
 399 018c DC01      		movw r26,r24
 400 018e ED93      		st X+,r30
 401 0190 FC93      		st X,r31
 402               	.LVL39:
 403               		.loc 4 185 0
 404 0192 D901      		movw r26,r18
 405 0194 1396      		adiw r26,2+1
 406 0196 FC93      		st X,r31
 407 0198 EE93      		st -X,r30
 408 019a 1297      		sbiw r26,2
 409               	.LBE118:
 410               	.LBE117:
 175:../../os/rt/src/chmtx.c ****           /*lint -e{9042} [16.1] Continues the while.*/
 411               		.loc 1 175 0
 412 019c 0288      		ldd __tmp_reg__,Z+18
 413 019e F389      		ldd r31,Z+19
 414 01a0 E02D      		mov r30,__tmp_reg__
 415               	.LVL40:
 416 01a2 0480      		ldd __tmp_reg__,Z+4
 417 01a4 F581      		ldd r31,Z+5
 418 01a6 E02D      		mov r30,__tmp_reg__
 419               	.LVL41:
 165:../../os/rt/src/chmtx.c ****         /* Make priority of thread tp match the running thread's priority.*/
 420               		.loc 1 165 0
 421 01a8 D801      		movw r26,r16
 422 01aa 1496      		adiw r26,4
 423 01ac 8C91      		ld r24,X
 424 01ae 9481      		ldd r25,Z+4
 425 01b0 9817      		cp r25,r24
 426 01b2 00F4      		brsh .+2
 427 01b4 00C0      		rjmp .L12
 428 01b6 00C0      		rjmp .L6
 429               	.LVL42:
 430               	.L28:
 431               	.LBB120:
 432               	.LBB111:
 179:../../os/rt/include/chschd.h ****   } while ((cp != qp) &&
 433               		.loc 4 179 0
 434 01b8 9D01      		movw r18,r26
 435               	.LVL43:
 436 01ba 00C0      		rjmp .L13
 437               	.LVL44:
 438               	.L30:
 439               	.LBE111:
 440               	.LBE120:
 441               	.LBB121:
 442               	.LBB119:
 443 01bc 9D01      		movw r18,r26
 444               	.LVL45:
 445 01be 00C0      		rjmp .L10
 446               	.LBE119:
 447               	.LBE121:
 448               	.LBE123:
 449               		.cfi_endproc
 450               	.LFE197:
 452               		.section	.text.chMtxLock,"ax",@progbits
 453               	.global	chMtxLock
 455               	chMtxLock:
 456               	.LFB196:
 123:../../os/rt/src/chmtx.c **** 
 457               		.loc 1 123 0
 458               		.cfi_startproc
 459               	.LVL46:
 460               	/* prologue: function */
 461               	/* frame size = 0 */
 462               	/* stack size = 0 */
 463               	.L__stack_usage = 0
 464               	.LBB124:
 465               	.LBB125:
 466               	.LBB126:
 467               		.file 5 "../../os/common/ports/AVR/chcore.h"
   1:../../os/common/ports/AVR/chcore.h **** /*
   2:../../os/common/ports/AVR/chcore.h ****     ChibiOS - Copyright (C) 2006,2007,2008,2009,2010,2011,2012,2013,2014,
   3:../../os/common/ports/AVR/chcore.h ****               2015,2016,2017,2018,2019,2020,2021 Giovanni Di Sirio.
   4:../../os/common/ports/AVR/chcore.h **** 
   5:../../os/common/ports/AVR/chcore.h ****     This file is part of ChibiOS.
   6:../../os/common/ports/AVR/chcore.h **** 
   7:../../os/common/ports/AVR/chcore.h ****     ChibiOS is free software; you can redistribute it and/or modify
   8:../../os/common/ports/AVR/chcore.h ****     it under the terms of the GNU General Public License as published by
   9:../../os/common/ports/AVR/chcore.h ****     the Free Software Foundation version 3 of the License.
  10:../../os/common/ports/AVR/chcore.h **** 
  11:../../os/common/ports/AVR/chcore.h ****     ChibiOS is distributed in the hope that it will be useful,
  12:../../os/common/ports/AVR/chcore.h ****     but WITHOUT ANY WARRANTY; without even the implied warranty of
  13:../../os/common/ports/AVR/chcore.h ****     MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
  14:../../os/common/ports/AVR/chcore.h ****     GNU General Public License for more details.
  15:../../os/common/ports/AVR/chcore.h **** 
  16:../../os/common/ports/AVR/chcore.h ****     You should have received a copy of the GNU General Public License
  17:../../os/common/ports/AVR/chcore.h ****     along with this program.  If not, see <http://www.gnu.org/licenses/>.
  18:../../os/common/ports/AVR/chcore.h **** */
  19:../../os/common/ports/AVR/chcore.h **** 
  20:../../os/common/ports/AVR/chcore.h **** /**
  21:../../os/common/ports/AVR/chcore.h ****  * @file    chcore.h
  22:../../os/common/ports/AVR/chcore.h ****  * @brief   AVR port macros and structures.
  23:../../os/common/ports/AVR/chcore.h ****  *
  24:../../os/common/ports/AVR/chcore.h ****  * @addtogroup AVR_CORE
  25:../../os/common/ports/AVR/chcore.h ****  * @{
  26:../../os/common/ports/AVR/chcore.h ****  */
  27:../../os/common/ports/AVR/chcore.h **** 
  28:../../os/common/ports/AVR/chcore.h **** #ifndef CHCORE_H
  29:../../os/common/ports/AVR/chcore.h **** #define CHCORE_H
  30:../../os/common/ports/AVR/chcore.h **** 
  31:../../os/common/ports/AVR/chcore.h **** #include <avr/io.h>
  32:../../os/common/ports/AVR/chcore.h **** #include <avr/interrupt.h>
  33:../../os/common/ports/AVR/chcore.h **** 
  34:../../os/common/ports/AVR/chcore.h **** extern bool __avr_in_isr;
  35:../../os/common/ports/AVR/chcore.h **** 
  36:../../os/common/ports/AVR/chcore.h **** /*===========================================================================*/
  37:../../os/common/ports/AVR/chcore.h **** /* Module constants.                                                         */
  38:../../os/common/ports/AVR/chcore.h **** /*===========================================================================*/
  39:../../os/common/ports/AVR/chcore.h **** 
  40:../../os/common/ports/AVR/chcore.h **** /**
  41:../../os/common/ports/AVR/chcore.h ****  * @name    Port Capabilities and Constants
  42:../../os/common/ports/AVR/chcore.h ****  * @{
  43:../../os/common/ports/AVR/chcore.h ****  */
  44:../../os/common/ports/AVR/chcore.h **** /**
  45:../../os/common/ports/AVR/chcore.h ****  * @brief   This port supports a realtime counter.
  46:../../os/common/ports/AVR/chcore.h ****  */
  47:../../os/common/ports/AVR/chcore.h **** #define PORT_SUPPORTS_RT                FALSE
  48:../../os/common/ports/AVR/chcore.h **** 
  49:../../os/common/ports/AVR/chcore.h **** /**
  50:../../os/common/ports/AVR/chcore.h ****  * @brief   Natural alignment constant.
  51:../../os/common/ports/AVR/chcore.h ****  * @note    It is the minimum alignment for pointer-size variables.
  52:../../os/common/ports/AVR/chcore.h ****  */
  53:../../os/common/ports/AVR/chcore.h **** #define PORT_NATURAL_ALIGN              1U
  54:../../os/common/ports/AVR/chcore.h **** 
  55:../../os/common/ports/AVR/chcore.h **** /**
  56:../../os/common/ports/AVR/chcore.h ****  * @brief   Stack alignment constant.
  57:../../os/common/ports/AVR/chcore.h ****  * @note    It is the alignment required for the stack pointer.
  58:../../os/common/ports/AVR/chcore.h ****  */
  59:../../os/common/ports/AVR/chcore.h **** #define PORT_STACK_ALIGN                1U
  60:../../os/common/ports/AVR/chcore.h **** 
  61:../../os/common/ports/AVR/chcore.h **** /**
  62:../../os/common/ports/AVR/chcore.h ****  * @brief   Working Areas alignment constant.
  63:../../os/common/ports/AVR/chcore.h ****  * @note    It is the alignment to be enforced for thread working areas.
  64:../../os/common/ports/AVR/chcore.h ****  */
  65:../../os/common/ports/AVR/chcore.h **** #define PORT_WORKING_AREA_ALIGN         1U
  66:../../os/common/ports/AVR/chcore.h **** /** @} */
  67:../../os/common/ports/AVR/chcore.h **** 
  68:../../os/common/ports/AVR/chcore.h **** /**
  69:../../os/common/ports/AVR/chcore.h ****  * @name    Architecture and Compiler
  70:../../os/common/ports/AVR/chcore.h ****  * @{
  71:../../os/common/ports/AVR/chcore.h ****  */
  72:../../os/common/ports/AVR/chcore.h **** /**
  73:../../os/common/ports/AVR/chcore.h ****  * @brief   Macro defining an AVR architecture.
  74:../../os/common/ports/AVR/chcore.h ****  */
  75:../../os/common/ports/AVR/chcore.h **** #define PORT_ARCHITECTURE_AVR
  76:../../os/common/ports/AVR/chcore.h **** 
  77:../../os/common/ports/AVR/chcore.h **** /**
  78:../../os/common/ports/AVR/chcore.h ****  * @brief   Macro defining the specific AVR architecture.
  79:../../os/common/ports/AVR/chcore.h ****  */
  80:../../os/common/ports/AVR/chcore.h **** #define PORT_ARCHITECTURE_AVR_MEGAAVR
  81:../../os/common/ports/AVR/chcore.h **** 
  82:../../os/common/ports/AVR/chcore.h **** /**
  83:../../os/common/ports/AVR/chcore.h ****  * @brief   Name of the implemented architecture.
  84:../../os/common/ports/AVR/chcore.h ****  */
  85:../../os/common/ports/AVR/chcore.h **** #define PORT_ARCHITECTURE_NAME          "AVR"
  86:../../os/common/ports/AVR/chcore.h **** 
  87:../../os/common/ports/AVR/chcore.h **** /**
  88:../../os/common/ports/AVR/chcore.h ****  * @brief   Name of the architecture variant.
  89:../../os/common/ports/AVR/chcore.h ****  */
  90:../../os/common/ports/AVR/chcore.h **** #define PORT_CORE_VARIANT_NAME          "MegaAVR"
  91:../../os/common/ports/AVR/chcore.h **** 
  92:../../os/common/ports/AVR/chcore.h **** /**
  93:../../os/common/ports/AVR/chcore.h ****  * @brief   Compiler name and version.
  94:../../os/common/ports/AVR/chcore.h ****  */
  95:../../os/common/ports/AVR/chcore.h **** #if defined(__GNUC__) || defined(__DOXYGEN__)
  96:../../os/common/ports/AVR/chcore.h **** #define PORT_COMPILER_NAME              "GCC " __VERSION__
  97:../../os/common/ports/AVR/chcore.h **** 
  98:../../os/common/ports/AVR/chcore.h **** #else
  99:../../os/common/ports/AVR/chcore.h **** #error "unsupported compiler"
 100:../../os/common/ports/AVR/chcore.h **** #endif
 101:../../os/common/ports/AVR/chcore.h **** 
 102:../../os/common/ports/AVR/chcore.h **** /**
 103:../../os/common/ports/AVR/chcore.h ****  * @brief   Port-specific information string.
 104:../../os/common/ports/AVR/chcore.h ****  */
 105:../../os/common/ports/AVR/chcore.h **** #define PORT_INFO                       "None"
 106:../../os/common/ports/AVR/chcore.h **** /** @} */
 107:../../os/common/ports/AVR/chcore.h **** 
 108:../../os/common/ports/AVR/chcore.h **** /*===========================================================================*/
 109:../../os/common/ports/AVR/chcore.h **** /* Module pre-compile time settings.                                         */
 110:../../os/common/ports/AVR/chcore.h **** /*===========================================================================*/
 111:../../os/common/ports/AVR/chcore.h **** 
 112:../../os/common/ports/AVR/chcore.h **** /**
 113:../../os/common/ports/AVR/chcore.h ****  * @brief   Stack size for the system idle thread.
 114:../../os/common/ports/AVR/chcore.h ****  * @details This size depends on the idle thread implementation, usually
 115:../../os/common/ports/AVR/chcore.h ****  *          the idle thread should take no more space than those reserved
 116:../../os/common/ports/AVR/chcore.h ****  *          by @p PORT_INT_REQUIRED_STACK.
 117:../../os/common/ports/AVR/chcore.h ****  */
 118:../../os/common/ports/AVR/chcore.h **** #if !defined(PORT_IDLE_THREAD_STACK_SIZE) || defined(__DOXYGEN__)
 119:../../os/common/ports/AVR/chcore.h **** #define PORT_IDLE_THREAD_STACK_SIZE     8
 120:../../os/common/ports/AVR/chcore.h **** #endif
 121:../../os/common/ports/AVR/chcore.h **** 
 122:../../os/common/ports/AVR/chcore.h **** /**
 123:../../os/common/ports/AVR/chcore.h ****  * @brief   Per-thread stack overhead for interrupts servicing.
 124:../../os/common/ports/AVR/chcore.h ****  * @details This constant is used in the calculation of the correct working
 125:../../os/common/ports/AVR/chcore.h ****  *          area size.
 126:../../os/common/ports/AVR/chcore.h ****  */
 127:../../os/common/ports/AVR/chcore.h **** #if !defined(PORT_INT_REQUIRED_STACK) || defined(__DOXYGEN__)
 128:../../os/common/ports/AVR/chcore.h **** #define PORT_INT_REQUIRED_STACK         32
 129:../../os/common/ports/AVR/chcore.h **** #endif
 130:../../os/common/ports/AVR/chcore.h **** 
 131:../../os/common/ports/AVR/chcore.h **** /**
 132:../../os/common/ports/AVR/chcore.h ****  * @brief   Enables a "wait for interrupt" instruction in the idle loop.
 133:../../os/common/ports/AVR/chcore.h ****  */
 134:../../os/common/ports/AVR/chcore.h **** #if !defined(PORT_AVR_WFI_SLEEP_IDLE) || defined(__DOXYGEN__)
 135:../../os/common/ports/AVR/chcore.h **** #define PORT_AVR_WFI_SLEEP_IDLE      FALSE
 136:../../os/common/ports/AVR/chcore.h **** #endif
 137:../../os/common/ports/AVR/chcore.h **** 
 138:../../os/common/ports/AVR/chcore.h **** /*===========================================================================*/
 139:../../os/common/ports/AVR/chcore.h **** /* Derived constants and error checks.                                       */
 140:../../os/common/ports/AVR/chcore.h **** /*===========================================================================*/
 141:../../os/common/ports/AVR/chcore.h **** 
 142:../../os/common/ports/AVR/chcore.h **** /*===========================================================================*/
 143:../../os/common/ports/AVR/chcore.h **** /* Module data structures and types.                                         */
 144:../../os/common/ports/AVR/chcore.h **** /*===========================================================================*/
 145:../../os/common/ports/AVR/chcore.h **** 
 146:../../os/common/ports/AVR/chcore.h **** /* The following code is not processed when the file is included from an
 147:../../os/common/ports/AVR/chcore.h ****    asm module.*/
 148:../../os/common/ports/AVR/chcore.h **** #if !defined(_FROM_ASM_)
 149:../../os/common/ports/AVR/chcore.h **** 
 150:../../os/common/ports/AVR/chcore.h **** /**
 151:../../os/common/ports/AVR/chcore.h ****  * @brief   Type of stack and memory alignment enforcement.
 152:../../os/common/ports/AVR/chcore.h ****  * @note    In this architecture the stack alignment is enforced to 8 bits.
 153:../../os/common/ports/AVR/chcore.h ****  */
 154:../../os/common/ports/AVR/chcore.h **** typedef uint8_t stkalign_t;
 155:../../os/common/ports/AVR/chcore.h **** 
 156:../../os/common/ports/AVR/chcore.h **** /**
 157:../../os/common/ports/AVR/chcore.h ****  * @brief   Interrupt saved context.
 158:../../os/common/ports/AVR/chcore.h ****  * @details This structure represents the stack frame saved during a
 159:../../os/common/ports/AVR/chcore.h ****  *          preemption-capable interrupt handler.
 160:../../os/common/ports/AVR/chcore.h ****  * @note    R2 and R13 are not saved because those are assumed to be immutable
 161:../../os/common/ports/AVR/chcore.h ****  *          during the system life cycle.
 162:../../os/common/ports/AVR/chcore.h ****  */
 163:../../os/common/ports/AVR/chcore.h **** struct port_extctx {
 164:../../os/common/ports/AVR/chcore.h ****   uint8_t       _next;
 165:../../os/common/ports/AVR/chcore.h ****   uint8_t       r31;
 166:../../os/common/ports/AVR/chcore.h ****   uint8_t       r30;
 167:../../os/common/ports/AVR/chcore.h ****   uint8_t       r27;
 168:../../os/common/ports/AVR/chcore.h ****   uint8_t       r26;
 169:../../os/common/ports/AVR/chcore.h ****   uint8_t       r25;
 170:../../os/common/ports/AVR/chcore.h ****   uint8_t       r24;
 171:../../os/common/ports/AVR/chcore.h ****   uint8_t       r23;
 172:../../os/common/ports/AVR/chcore.h ****   uint8_t       r22;
 173:../../os/common/ports/AVR/chcore.h ****   uint8_t       r21;
 174:../../os/common/ports/AVR/chcore.h ****   uint8_t       r20;
 175:../../os/common/ports/AVR/chcore.h ****   uint8_t       r19;
 176:../../os/common/ports/AVR/chcore.h ****   uint8_t       r18;
 177:../../os/common/ports/AVR/chcore.h ****   uint8_t       sr;
 178:../../os/common/ports/AVR/chcore.h ****   uint8_t       r1;
 179:../../os/common/ports/AVR/chcore.h ****   uint8_t       r0;
 180:../../os/common/ports/AVR/chcore.h **** #if defined(__AVR_3_BYTE_PC__)
 181:../../os/common/ports/AVR/chcore.h ****   uint8_t       pcx;
 182:../../os/common/ports/AVR/chcore.h **** #endif
 183:../../os/common/ports/AVR/chcore.h ****   uint16_t      pc;
 184:../../os/common/ports/AVR/chcore.h **** };
 185:../../os/common/ports/AVR/chcore.h **** 
 186:../../os/common/ports/AVR/chcore.h **** /**
 187:../../os/common/ports/AVR/chcore.h ****  * @brief   System saved context.
 188:../../os/common/ports/AVR/chcore.h ****  * @details This structure represents the inner stack frame during a context
 189:../../os/common/ports/AVR/chcore.h ****  *          switching.
 190:../../os/common/ports/AVR/chcore.h ****  * @note    R2 and R13 are not saved because those are assumed to be immutable
 191:../../os/common/ports/AVR/chcore.h ****  *          during the system life cycle.
 192:../../os/common/ports/AVR/chcore.h ****  * @note    LR is stored in the caller context so it is not present in this
 193:../../os/common/ports/AVR/chcore.h ****  *          structure.
 194:../../os/common/ports/AVR/chcore.h ****  */
 195:../../os/common/ports/AVR/chcore.h **** struct port_intctx {
 196:../../os/common/ports/AVR/chcore.h ****   uint8_t       _next;
 197:../../os/common/ports/AVR/chcore.h ****   uint8_t       r29;
 198:../../os/common/ports/AVR/chcore.h ****   uint8_t       r28;
 199:../../os/common/ports/AVR/chcore.h ****   uint8_t       r17;
 200:../../os/common/ports/AVR/chcore.h ****   uint8_t       r16;
 201:../../os/common/ports/AVR/chcore.h ****   uint8_t       r15;
 202:../../os/common/ports/AVR/chcore.h ****   uint8_t       r14;
 203:../../os/common/ports/AVR/chcore.h ****   uint8_t       r13;
 204:../../os/common/ports/AVR/chcore.h ****   uint8_t       r12;
 205:../../os/common/ports/AVR/chcore.h ****   uint8_t       r11;
 206:../../os/common/ports/AVR/chcore.h ****   uint8_t       r10;
 207:../../os/common/ports/AVR/chcore.h ****   uint8_t       r9;
 208:../../os/common/ports/AVR/chcore.h ****   uint8_t       r8;
 209:../../os/common/ports/AVR/chcore.h ****   uint8_t       r7;
 210:../../os/common/ports/AVR/chcore.h ****   uint8_t       r6;
 211:../../os/common/ports/AVR/chcore.h ****   uint8_t       r5;
 212:../../os/common/ports/AVR/chcore.h ****   uint8_t       r4;
 213:../../os/common/ports/AVR/chcore.h ****   uint8_t       r3;
 214:../../os/common/ports/AVR/chcore.h ****   uint8_t       r2;
 215:../../os/common/ports/AVR/chcore.h **** #if defined(__AVR_3_BYTE_PC__)
 216:../../os/common/ports/AVR/chcore.h ****   uint8_t       pcx;
 217:../../os/common/ports/AVR/chcore.h **** #endif
 218:../../os/common/ports/AVR/chcore.h ****   uint8_t       pcl;
 219:../../os/common/ports/AVR/chcore.h ****   uint8_t       pch;
 220:../../os/common/ports/AVR/chcore.h **** };
 221:../../os/common/ports/AVR/chcore.h **** 
 222:../../os/common/ports/AVR/chcore.h **** /**
 223:../../os/common/ports/AVR/chcore.h ****  * @brief   Platform dependent part of the @p thread_t structure.
 224:../../os/common/ports/AVR/chcore.h ****  * @details This structure usually contains just the saved stack pointer
 225:../../os/common/ports/AVR/chcore.h ****  *          defined as a pointer to a @p port_intctx structure.
 226:../../os/common/ports/AVR/chcore.h ****  */
 227:../../os/common/ports/AVR/chcore.h **** struct port_context {
 228:../../os/common/ports/AVR/chcore.h ****   struct port_intctx *sp;
 229:../../os/common/ports/AVR/chcore.h **** };
 230:../../os/common/ports/AVR/chcore.h **** 
 231:../../os/common/ports/AVR/chcore.h **** #endif /* !defined(_FROM_ASM_) */
 232:../../os/common/ports/AVR/chcore.h **** 
 233:../../os/common/ports/AVR/chcore.h **** /*===========================================================================*/
 234:../../os/common/ports/AVR/chcore.h **** /* Module macros.                                                            */
 235:../../os/common/ports/AVR/chcore.h **** /*===========================================================================*/
 236:../../os/common/ports/AVR/chcore.h **** 
 237:../../os/common/ports/AVR/chcore.h **** /**
 238:../../os/common/ports/AVR/chcore.h ****  * @brief   Platform dependent part of the @p chThdCreateI() API.
 239:../../os/common/ports/AVR/chcore.h ****  * @details This code usually setup the context switching frame represented
 240:../../os/common/ports/AVR/chcore.h ****  *          by an @p port_intctx structure.
 241:../../os/common/ports/AVR/chcore.h ****  */
 242:../../os/common/ports/AVR/chcore.h **** #if defined(__AVR_3_BYTE_PC__) || defined(__DOXYGEN__)
 243:../../os/common/ports/AVR/chcore.h **** #define PORT_SETUP_CONTEXT(tp, wbase, wtop, pf, arg) {                      \
 244:../../os/common/ports/AVR/chcore.h ****   tp->ctx.sp = (struct port_intctx *)((uint8_t *)(wtop) -                   \
 245:../../os/common/ports/AVR/chcore.h ****                                       sizeof(struct port_intctx));          \
 246:../../os/common/ports/AVR/chcore.h ****   tp->ctx.sp->r2  = (uint8_t)(0xff & (uint16_t)pf);                         \
 247:../../os/common/ports/AVR/chcore.h ****   tp->ctx.sp->r3  = (uint8_t)((uint16_t)(pf) >> 8);                         \
 248:../../os/common/ports/AVR/chcore.h ****   tp->ctx.sp->r4  = (uint8_t)(0xff & (uint16_t)arg);                        \
 249:../../os/common/ports/AVR/chcore.h ****   tp->ctx.sp->r5  = (uint8_t)((uint16_t)(arg) >> 8);                        \
 250:../../os/common/ports/AVR/chcore.h ****   tp->ctx.sp->pcx = (uint8_t)0;                                             \
 251:../../os/common/ports/AVR/chcore.h ****   tp->ctx.sp->pcl = (uint16_t)_port_thread_start >> 8;                      \
 252:../../os/common/ports/AVR/chcore.h ****   tp->ctx.sp->pch = (uint8_t)(0xff & (uint16_t)_port_thread_start);         \
 253:../../os/common/ports/AVR/chcore.h **** }
 254:../../os/common/ports/AVR/chcore.h **** #else /* !__AVR_3_BYTE_PC__ */
 255:../../os/common/ports/AVR/chcore.h **** #define PORT_SETUP_CONTEXT(tp, wbase, wtop, pf, arg) {                      \
 256:../../os/common/ports/AVR/chcore.h ****   tp->ctx.sp = (struct port_intctx *)((uint8_t *)(wtop) -                   \
 257:../../os/common/ports/AVR/chcore.h ****                                       sizeof(struct port_intctx));          \
 258:../../os/common/ports/AVR/chcore.h ****   tp->ctx.sp->r2  = (uint8_t)(0xff & (uint16_t)pf);                         \
 259:../../os/common/ports/AVR/chcore.h ****   tp->ctx.sp->r3  = (uint8_t)((uint16_t)(pf) >> 8);                         \
 260:../../os/common/ports/AVR/chcore.h ****   tp->ctx.sp->r4  = (uint8_t)(0xff & (uint16_t)arg);                        \
 261:../../os/common/ports/AVR/chcore.h ****   tp->ctx.sp->r5  = (uint8_t)((uint16_t)(arg) >> 8);                        \
 262:../../os/common/ports/AVR/chcore.h ****   tp->ctx.sp->pcl = (uint16_t)_port_thread_start >> 8;                      \
 263:../../os/common/ports/AVR/chcore.h ****   tp->ctx.sp->pch = (uint8_t)(0xff & (uint16_t)_port_thread_start);         \
 264:../../os/common/ports/AVR/chcore.h **** }
 265:../../os/common/ports/AVR/chcore.h **** #endif /* !__AVR_3_BYTE_PC__ */
 266:../../os/common/ports/AVR/chcore.h **** 
 267:../../os/common/ports/AVR/chcore.h **** /**
 268:../../os/common/ports/AVR/chcore.h ****  * @brief   Computes the thread working area global size.
 269:../../os/common/ports/AVR/chcore.h ****  * @note    There is no need to perform alignments in this macro.
 270:../../os/common/ports/AVR/chcore.h ****  */
 271:../../os/common/ports/AVR/chcore.h **** #define PORT_WA_SIZE(n) ((sizeof(struct port_intctx) - 1) +                \
 272:../../os/common/ports/AVR/chcore.h ****                          (sizeof(struct port_extctx) - 1) +                \
 273:../../os/common/ports/AVR/chcore.h ****                          ((size_t)(n)) + ((size_t)(PORT_INT_REQUIRED_STACK)))
 274:../../os/common/ports/AVR/chcore.h **** 
 275:../../os/common/ports/AVR/chcore.h **** /**
 276:../../os/common/ports/AVR/chcore.h ****  * @brief   Static working area allocation.
 277:../../os/common/ports/AVR/chcore.h ****  * @details This macro is used to allocate a static thread working area
 278:../../os/common/ports/AVR/chcore.h ****  *          aligned as both position and size.
 279:../../os/common/ports/AVR/chcore.h ****  *
 280:../../os/common/ports/AVR/chcore.h ****  * @param[in] s         the name to be assigned to the stack array
 281:../../os/common/ports/AVR/chcore.h ****  * @param[in] n         the stack size to be assigned to the thread
 282:../../os/common/ports/AVR/chcore.h ****  */
 283:../../os/common/ports/AVR/chcore.h **** #define PORT_WORKING_AREA(s, n)                                             \
 284:../../os/common/ports/AVR/chcore.h ****   stkalign_t s[THD_WORKING_AREA_SIZE(n) / sizeof (stkalign_t)]
 285:../../os/common/ports/AVR/chcore.h **** 
 286:../../os/common/ports/AVR/chcore.h **** /**
 287:../../os/common/ports/AVR/chcore.h ****  * @brief   Priority level verification macro.
 288:../../os/common/ports/AVR/chcore.h ****  */
 289:../../os/common/ports/AVR/chcore.h **** #define PORT_IRQ_IS_VALID_PRIORITY(n) false
 290:../../os/common/ports/AVR/chcore.h **** 
 291:../../os/common/ports/AVR/chcore.h **** /**
 292:../../os/common/ports/AVR/chcore.h ****  * @brief   Priority level verification macro.
 293:../../os/common/ports/AVR/chcore.h ****  */
 294:../../os/common/ports/AVR/chcore.h **** #define PORT_IRQ_IS_VALID_KERNEL_PRIORITY(n) false
 295:../../os/common/ports/AVR/chcore.h **** 
 296:../../os/common/ports/AVR/chcore.h **** /**
 297:../../os/common/ports/AVR/chcore.h ****  * @brief   IRQ prologue code.
 298:../../os/common/ports/AVR/chcore.h ****  * @details This macro must be inserted at the start of all IRQ handlers
 299:../../os/common/ports/AVR/chcore.h ****  *          enabled to invoke system APIs.
 300:../../os/common/ports/AVR/chcore.h ****  * @note    This code tricks the compiler to save all the specified registers
 301:../../os/common/ports/AVR/chcore.h ****  *          by "touching" them.
 302:../../os/common/ports/AVR/chcore.h ****  */
 303:../../os/common/ports/AVR/chcore.h **** #define PORT_IRQ_PROLOGUE() {                                               \
 304:../../os/common/ports/AVR/chcore.h ****   asm ("" : : : "r18", "r19", "r20", "r21", "r22", "r23", "r24",            \
 305:../../os/common/ports/AVR/chcore.h ****                 "r25", "r26", "r27", "r30", "r31");                         \
 306:../../os/common/ports/AVR/chcore.h ****   __avr_in_isr = true;                                                      \
 307:../../os/common/ports/AVR/chcore.h **** }
 308:../../os/common/ports/AVR/chcore.h **** 
 309:../../os/common/ports/AVR/chcore.h **** /**
 310:../../os/common/ports/AVR/chcore.h ****  * @brief   IRQ epilogue code.
 311:../../os/common/ports/AVR/chcore.h ****  * @details This macro must be inserted at the end of all IRQ handlers
 312:../../os/common/ports/AVR/chcore.h ****  *          enabled to invoke system APIs.
 313:../../os/common/ports/AVR/chcore.h ****  */
 314:../../os/common/ports/AVR/chcore.h **** #define PORT_IRQ_EPILOGUE() {                                               \
 315:../../os/common/ports/AVR/chcore.h ****   __avr_in_isr = false;                                                     \
 316:../../os/common/ports/AVR/chcore.h ****   __dbg_check_lock();                                                       \
 317:../../os/common/ports/AVR/chcore.h ****   if (chSchIsPreemptionRequired())                                          \
 318:../../os/common/ports/AVR/chcore.h ****     chSchDoPreemption();                                                    \
 319:../../os/common/ports/AVR/chcore.h ****   __dbg_check_unlock();                                                     \
 320:../../os/common/ports/AVR/chcore.h **** }
 321:../../os/common/ports/AVR/chcore.h **** 
 322:../../os/common/ports/AVR/chcore.h **** /**
 323:../../os/common/ports/AVR/chcore.h ****  * @brief   IRQ handler function declaration.
 324:../../os/common/ports/AVR/chcore.h ****  * @note    @p id can be a function name or a vector number depending on the
 325:../../os/common/ports/AVR/chcore.h ****  *          port implementation.
 326:../../os/common/ports/AVR/chcore.h ****  */
 327:../../os/common/ports/AVR/chcore.h **** #define PORT_IRQ_HANDLER(id) ISR(id)
 328:../../os/common/ports/AVR/chcore.h **** 
 329:../../os/common/ports/AVR/chcore.h **** /**
 330:../../os/common/ports/AVR/chcore.h ****  * @brief   Fast IRQ handler function declaration.
 331:../../os/common/ports/AVR/chcore.h ****  * @note    @p id can be a function name or a vector number depending on the
 332:../../os/common/ports/AVR/chcore.h ****  *          port implementation.
 333:../../os/common/ports/AVR/chcore.h ****  */
 334:../../os/common/ports/AVR/chcore.h **** #define PORT_FAST_IRQ_HANDLER(id) ISR(id)
 335:../../os/common/ports/AVR/chcore.h **** 
 336:../../os/common/ports/AVR/chcore.h **** /**
 337:../../os/common/ports/AVR/chcore.h ****  * @brief   Performs a context switch between two threads.
 338:../../os/common/ports/AVR/chcore.h ****  * @details This is the most critical code in any port, this function
 339:../../os/common/ports/AVR/chcore.h ****  *          is responsible for the context switch between 2 threads.
 340:../../os/common/ports/AVR/chcore.h ****  * @note    The implementation of this code affects <b>directly</b> the context
 341:../../os/common/ports/AVR/chcore.h ****  *          switch performance so optimize here as much as you can.
 342:../../os/common/ports/AVR/chcore.h ****  *
 343:../../os/common/ports/AVR/chcore.h ****  * @param[in] ntp       the thread to be switched in
 344:../../os/common/ports/AVR/chcore.h ****  * @param[in] otp       the thread to be switched out
 345:../../os/common/ports/AVR/chcore.h ****  */
 346:../../os/common/ports/AVR/chcore.h **** #define port_switch(ntp, otp) {                                             \
 347:../../os/common/ports/AVR/chcore.h ****   _port_switch(ntp, otp);                                                   \
 348:../../os/common/ports/AVR/chcore.h ****   asm volatile ("" : : : "memory");                                         \
 349:../../os/common/ports/AVR/chcore.h **** }
 350:../../os/common/ports/AVR/chcore.h **** 
 351:../../os/common/ports/AVR/chcore.h **** 
 352:../../os/common/ports/AVR/chcore.h **** /**
 353:../../os/common/ports/AVR/chcore.h ****  * @brief   Port-related initialization code.
 354:../../os/common/ports/AVR/chcore.h ****  * @note    This function is empty in this port.
 355:../../os/common/ports/AVR/chcore.h ****  */
 356:../../os/common/ports/AVR/chcore.h **** #define port_init(oip) {                                                    \
 357:../../os/common/ports/AVR/chcore.h ****   __avr_in_isr = true;                                                      \
 358:../../os/common/ports/AVR/chcore.h **** }
 359:../../os/common/ports/AVR/chcore.h **** 
 360:../../os/common/ports/AVR/chcore.h **** /*===========================================================================*/
 361:../../os/common/ports/AVR/chcore.h **** /* External declarations.                                                    */
 362:../../os/common/ports/AVR/chcore.h **** /*===========================================================================*/
 363:../../os/common/ports/AVR/chcore.h **** 
 364:../../os/common/ports/AVR/chcore.h **** /* The following code is not processed when the file is included from an
 365:../../os/common/ports/AVR/chcore.h ****    asm module.*/
 366:../../os/common/ports/AVR/chcore.h **** #if !defined(_FROM_ASM_)
 367:../../os/common/ports/AVR/chcore.h **** 
 368:../../os/common/ports/AVR/chcore.h **** #ifdef __cplusplus
 369:../../os/common/ports/AVR/chcore.h **** extern "C" {
 370:../../os/common/ports/AVR/chcore.h **** #endif
 371:../../os/common/ports/AVR/chcore.h ****   void _port_switch(thread_t *ntp, thread_t *otp);
 372:../../os/common/ports/AVR/chcore.h ****   void _port_thread_start(void);
 373:../../os/common/ports/AVR/chcore.h **** #ifdef __cplusplus
 374:../../os/common/ports/AVR/chcore.h **** }
 375:../../os/common/ports/AVR/chcore.h **** #endif
 376:../../os/common/ports/AVR/chcore.h **** 
 377:../../os/common/ports/AVR/chcore.h **** #endif /* !defined(_FROM_ASM_) */
 378:../../os/common/ports/AVR/chcore.h **** 
 379:../../os/common/ports/AVR/chcore.h **** /*===========================================================================*/
 380:../../os/common/ports/AVR/chcore.h **** /* Module inline functions.                                                  */
 381:../../os/common/ports/AVR/chcore.h **** /*===========================================================================*/
 382:../../os/common/ports/AVR/chcore.h **** 
 383:../../os/common/ports/AVR/chcore.h **** /* The following code is not processed when the file is included from an
 384:../../os/common/ports/AVR/chcore.h ****    asm module.*/
 385:../../os/common/ports/AVR/chcore.h **** #if !defined(_FROM_ASM_)
 386:../../os/common/ports/AVR/chcore.h **** 
 387:../../os/common/ports/AVR/chcore.h **** /**
 388:../../os/common/ports/AVR/chcore.h ****  * @brief   Returns a word encoding the current interrupts status.
 389:../../os/common/ports/AVR/chcore.h ****  *
 390:../../os/common/ports/AVR/chcore.h ****  * @return              The interrupts status.
 391:../../os/common/ports/AVR/chcore.h ****  */
 392:../../os/common/ports/AVR/chcore.h **** static inline syssts_t port_get_irq_status(void) {
 393:../../os/common/ports/AVR/chcore.h **** 
 394:../../os/common/ports/AVR/chcore.h ****   return SREG;
 395:../../os/common/ports/AVR/chcore.h **** }
 396:../../os/common/ports/AVR/chcore.h **** 
 397:../../os/common/ports/AVR/chcore.h **** /**
 398:../../os/common/ports/AVR/chcore.h ****  * @brief   Checks the interrupt status.
 399:../../os/common/ports/AVR/chcore.h ****  *
 400:../../os/common/ports/AVR/chcore.h ****  * @param[in] sts       the interrupt status word
 401:../../os/common/ports/AVR/chcore.h ****  *
 402:../../os/common/ports/AVR/chcore.h ****  * @return              The interrupt status.
 403:../../os/common/ports/AVR/chcore.h ****  * @retval false        the word specified a disabled interrupts status.
 404:../../os/common/ports/AVR/chcore.h ****  * @retval true         the word specified an enabled interrupts status.
 405:../../os/common/ports/AVR/chcore.h ****  */
 406:../../os/common/ports/AVR/chcore.h **** static inline bool port_irq_enabled(syssts_t sts) {
 407:../../os/common/ports/AVR/chcore.h **** 
 408:../../os/common/ports/AVR/chcore.h ****   return (bool)((sts & 0x80) != 0);
 409:../../os/common/ports/AVR/chcore.h **** }
 410:../../os/common/ports/AVR/chcore.h **** 
 411:../../os/common/ports/AVR/chcore.h **** /**
 412:../../os/common/ports/AVR/chcore.h ****  * @brief   Determines the current execution context.
 413:../../os/common/ports/AVR/chcore.h ****  *
 414:../../os/common/ports/AVR/chcore.h ****  * @return              The execution context.
 415:../../os/common/ports/AVR/chcore.h ****  * @retval false        not running in ISR mode.
 416:../../os/common/ports/AVR/chcore.h ****  * @retval true         running in ISR mode.
 417:../../os/common/ports/AVR/chcore.h ****  */
 418:../../os/common/ports/AVR/chcore.h **** static inline bool port_is_isr_context(void) {
 419:../../os/common/ports/AVR/chcore.h **** 
 420:../../os/common/ports/AVR/chcore.h ****   return __avr_in_isr;
 421:../../os/common/ports/AVR/chcore.h **** }
 422:../../os/common/ports/AVR/chcore.h **** 
 423:../../os/common/ports/AVR/chcore.h **** /**
 424:../../os/common/ports/AVR/chcore.h ****  * @brief   Kernel-lock action.
 425:../../os/common/ports/AVR/chcore.h ****  * @details Usually this function just disables interrupts but may perform more
 426:../../os/common/ports/AVR/chcore.h ****  *          actions.
 427:../../os/common/ports/AVR/chcore.h ****  */
 428:../../os/common/ports/AVR/chcore.h **** static inline void port_lock(void) {
 429:../../os/common/ports/AVR/chcore.h **** 
 430:../../os/common/ports/AVR/chcore.h ****   asm volatile ("cli" : : : "memory");
 468               		.loc 5 430 0
 469               	/* #APP */
 470               	 ;  430 "../../os/common/ports/AVR/chcore.h" 1
 471 0000 F894      		cli
 472               	 ;  0 "" 2
 473               	/* #NOAPP */
 474               	.LBE126:
 475               	.LBE125:
 476               	.LBE124:
 126:../../os/rt/src/chmtx.c ****   chSysUnlock();
 477               		.loc 1 126 0
 478 0002 0E94 0000 		call chMtxLockS
 479               	.LVL47:
 480               	.LBB127:
 481               	.LBB128:
 482               	.LBB129:
 483               	.LBB130:
 431:../../os/common/ports/AVR/chcore.h **** }
 432:../../os/common/ports/AVR/chcore.h **** 
 433:../../os/common/ports/AVR/chcore.h **** /**
 434:../../os/common/ports/AVR/chcore.h ****  * @brief   Kernel-unlock action.
 435:../../os/common/ports/AVR/chcore.h ****  * @details Usually this function just enables interrupts but may perform more
 436:../../os/common/ports/AVR/chcore.h ****  *          actions.
 437:../../os/common/ports/AVR/chcore.h ****  */
 438:../../os/common/ports/AVR/chcore.h **** static inline void port_unlock(void) {
 439:../../os/common/ports/AVR/chcore.h **** 
 440:../../os/common/ports/AVR/chcore.h ****   asm volatile ("sei" : : : "memory");
 484               		.loc 5 440 0
 485               	/* #APP */
 486               	 ;  440 "../../os/common/ports/AVR/chcore.h" 1
 487 0006 7894      		sei
 488               	 ;  0 "" 2
 489               	/* epilogue start */
 490               	/* #NOAPP */
 491               	.LBE130:
 492               	.LBE129:
 493               	.LBE128:
 494               	.LBE127:
 128:../../os/rt/src/chmtx.c **** 
 495               		.loc 1 128 0
 496 0008 0895      		ret
 497               		.cfi_endproc
 498               	.LFE196:
 500               		.section	.text.chMtxTryLock,"ax",@progbits
 501               	.global	chMtxTryLock
 503               	chMtxTryLock:
 504               	.LFB198:
 239:../../os/rt/src/chmtx.c **** 
 240:../../os/rt/src/chmtx.c **** /**
 241:../../os/rt/src/chmtx.c ****  * @brief   Tries to lock a mutex.
 242:../../os/rt/src/chmtx.c ****  * @details This function attempts to lock a mutex, if the mutex is already
 243:../../os/rt/src/chmtx.c ****  *          locked by another thread then the function exits without waiting.
 244:../../os/rt/src/chmtx.c ****  * @post    The mutex is locked and inserted in the per-thread stack of owned
 245:../../os/rt/src/chmtx.c ****  *          mutexes.
 246:../../os/rt/src/chmtx.c ****  * @note    This function does not have any overhead related to the
 247:../../os/rt/src/chmtx.c ****  *          priority inheritance mechanism because it does not try to
 248:../../os/rt/src/chmtx.c ****  *          enter a sleep state.
 249:../../os/rt/src/chmtx.c ****  *
 250:../../os/rt/src/chmtx.c ****  * @param[in] mp        pointer to the @p mutex_t structure
 251:../../os/rt/src/chmtx.c ****  * @return              The operation status.
 252:../../os/rt/src/chmtx.c ****  * @retval true         if the mutex has been successfully acquired
 253:../../os/rt/src/chmtx.c ****  * @retval false        if the lock attempt failed.
 254:../../os/rt/src/chmtx.c ****  *
 255:../../os/rt/src/chmtx.c ****  * @api
 256:../../os/rt/src/chmtx.c ****  */
 257:../../os/rt/src/chmtx.c **** bool chMtxTryLock(mutex_t *mp) {
 505               		.loc 1 257 0
 506               		.cfi_startproc
 507               	.LVL48:
 508               	/* prologue: function */
 509               	/* frame size = 0 */
 510               	/* stack size = 0 */
 511               	.L__stack_usage = 0
 512               	.LBB131:
 513               	.LBB132:
 514               	.LBB133:
 430:../../os/common/ports/AVR/chcore.h **** }
 515               		.loc 5 430 0
 516               	/* #APP */
 517               	 ;  430 "../../os/common/ports/AVR/chcore.h" 1
 518 0000 F894      		cli
 519               	 ;  0 "" 2
 520               	.LVL49:
 521               	/* #NOAPP */
 522               	.LBE133:
 523               	.LBE132:
 524               	.LBE131:
 525               	.LBB134:
 526               	.LBB135:
 258:../../os/rt/src/chmtx.c ****   bool b;
 259:../../os/rt/src/chmtx.c **** 
 260:../../os/rt/src/chmtx.c ****   chSysLock();
 261:../../os/rt/src/chmtx.c ****   b = chMtxTryLockS(mp);
 262:../../os/rt/src/chmtx.c ****   chSysUnlock();
 263:../../os/rt/src/chmtx.c **** 
 264:../../os/rt/src/chmtx.c ****   return b;
 265:../../os/rt/src/chmtx.c **** }
 266:../../os/rt/src/chmtx.c **** 
 267:../../os/rt/src/chmtx.c **** /**
 268:../../os/rt/src/chmtx.c ****  * @brief   Tries to lock a mutex.
 269:../../os/rt/src/chmtx.c ****  * @details This function attempts to lock a mutex, if the mutex is already
 270:../../os/rt/src/chmtx.c ****  *          taken by another thread then the function exits without waiting.
 271:../../os/rt/src/chmtx.c ****  * @post    The mutex is locked and inserted in the per-thread stack of owned
 272:../../os/rt/src/chmtx.c ****  *          mutexes.
 273:../../os/rt/src/chmtx.c ****  * @note    This function does not have any overhead related to the
 274:../../os/rt/src/chmtx.c ****  *          priority inheritance mechanism because it does not try to
 275:../../os/rt/src/chmtx.c ****  *          enter a sleep state.
 276:../../os/rt/src/chmtx.c ****  *
 277:../../os/rt/src/chmtx.c ****  * @param[in] mp        pointer to the @p mutex_t structure
 278:../../os/rt/src/chmtx.c ****  * @return              The operation status.
 279:../../os/rt/src/chmtx.c ****  * @retval true         if the mutex has been successfully acquired
 280:../../os/rt/src/chmtx.c ****  * @retval false        if the lock attempt failed.
 281:../../os/rt/src/chmtx.c ****  *
 282:../../os/rt/src/chmtx.c ****  * @sclass
 283:../../os/rt/src/chmtx.c ****  */
 284:../../os/rt/src/chmtx.c **** bool chMtxTryLockS(mutex_t *mp) {
 285:../../os/rt/src/chmtx.c ****   thread_t *currtp = chThdGetSelfX();
 286:../../os/rt/src/chmtx.c **** 
 287:../../os/rt/src/chmtx.c ****   chDbgCheckClassS();
 288:../../os/rt/src/chmtx.c ****   chDbgCheck(mp != NULL);
 289:../../os/rt/src/chmtx.c **** 
 290:../../os/rt/src/chmtx.c ****   if (mp->owner != NULL) {
 527               		.loc 1 290 0
 528 0002 DC01      		movw r26,r24
 529 0004 1496      		adiw r26,4
 530 0006 2D91      		ld r18,X+
 531 0008 3C91      		ld r19,X
 532 000a 1597      		sbiw r26,4+1
 533 000c 232B      		or r18,r19
 534 000e 01F0      		breq .L36
 291:../../os/rt/src/chmtx.c **** #if CH_CFG_USE_MUTEXES_RECURSIVE == TRUE
 292:../../os/rt/src/chmtx.c **** 
 293:../../os/rt/src/chmtx.c ****     chDbgAssert(mp->cnt >= (cnt_t)1, "counter is not positive");
 294:../../os/rt/src/chmtx.c **** 
 295:../../os/rt/src/chmtx.c ****     if (mp->owner == currtp) {
 296:../../os/rt/src/chmtx.c ****       mp->cnt++;
 297:../../os/rt/src/chmtx.c ****       return true;
 298:../../os/rt/src/chmtx.c ****     }
 299:../../os/rt/src/chmtx.c **** #endif
 300:../../os/rt/src/chmtx.c ****     return false;
 535               		.loc 1 300 0
 536 0010 80E0      		ldi r24,0
 537               	.LVL50:
 538               	.LBE135:
 539               	.LBE134:
 540               	.LBB139:
 541               	.LBB140:
 542               	.LBB141:
 543               	.LBB142:
 544               		.loc 5 440 0
 545               	/* #APP */
 546               	 ;  440 "../../os/common/ports/AVR/chcore.h" 1
 547 0012 7894      		sei
 548               	 ;  0 "" 2
 549               	/* epilogue start */
 550               	/* #NOAPP */
 551               	.LBE142:
 552               	.LBE141:
 553               	.LBE140:
 554               	.LBE139:
 265:../../os/rt/src/chmtx.c **** 
 555               		.loc 1 265 0
 556 0014 0895      		ret
 557               	.LVL51:
 558               	.L36:
 559               	.LBB146:
 560               	.LBB138:
 561               	.LBB136:
 562               	.LBB137:
 563               		.loc 3 343 0
 564 0016 E091 0000 		lds r30,ch0+5
 565 001a F091 0000 		lds r31,ch0+5+1
 566               	.LBE137:
 567               	.LBE136:
 301:../../os/rt/src/chmtx.c ****   }
 302:../../os/rt/src/chmtx.c **** #if CH_CFG_USE_MUTEXES_RECURSIVE == TRUE
 303:../../os/rt/src/chmtx.c **** 
 304:../../os/rt/src/chmtx.c ****   chDbgAssert(mp->cnt == (cnt_t)0, "counter is not zero");
 305:../../os/rt/src/chmtx.c **** 
 306:../../os/rt/src/chmtx.c ****   mp->cnt++;
 307:../../os/rt/src/chmtx.c **** #endif
 308:../../os/rt/src/chmtx.c ****   mp->owner = currtp;
 568               		.loc 1 308 0
 569 001e 1596      		adiw r26,4+1
 570 0020 FC93      		st X,r31
 571 0022 EE93      		st -X,r30
 572 0024 1497      		sbiw r26,4
 309:../../os/rt/src/chmtx.c ****   mp->next = currtp->mtxlist;
 573               		.loc 1 309 0
 574 0026 238D      		ldd r18,Z+27
 575 0028 348D      		ldd r19,Z+28
 576 002a 1796      		adiw r26,6+1
 577 002c 3C93      		st X,r19
 578 002e 2E93      		st -X,r18
 579 0030 1697      		sbiw r26,6
 310:../../os/rt/src/chmtx.c ****   currtp->mtxlist = mp;
 580               		.loc 1 310 0
 581 0032 948F      		std Z+28,r25
 582 0034 838F      		std Z+27,r24
 311:../../os/rt/src/chmtx.c ****   return true;
 583               		.loc 1 311 0
 584 0036 81E0      		ldi r24,lo8(1)
 585               	.LVL52:
 586               	.LBE138:
 587               	.LBE146:
 588               	.LBB147:
 589               	.LBB145:
 590               	.LBB144:
 591               	.LBB143:
 592               		.loc 5 440 0
 593               	/* #APP */
 594               	 ;  440 "../../os/common/ports/AVR/chcore.h" 1
 595 0038 7894      		sei
 596               	 ;  0 "" 2
 597               	/* epilogue start */
 598               	/* #NOAPP */
 599               	.LBE143:
 600               	.LBE144:
 601               	.LBE145:
 602               	.LBE147:
 265:../../os/rt/src/chmtx.c **** 
 603               		.loc 1 265 0
 604 003a 0895      		ret
 605               		.cfi_endproc
 606               	.LFE198:
 608               		.section	.text.chMtxTryLockS,"ax",@progbits
 609               	.global	chMtxTryLockS
 611               	chMtxTryLockS:
 612               	.LFB199:
 284:../../os/rt/src/chmtx.c ****   thread_t *currtp = chThdGetSelfX();
 613               		.loc 1 284 0
 614               		.cfi_startproc
 615               	.LVL53:
 616               	/* prologue: function */
 617               	/* frame size = 0 */
 618               	/* stack size = 0 */
 619               	.L__stack_usage = 0
 290:../../os/rt/src/chmtx.c **** #if CH_CFG_USE_MUTEXES_RECURSIVE == TRUE
 620               		.loc 1 290 0
 621 0000 DC01      		movw r26,r24
 622 0002 1496      		adiw r26,4
 623 0004 2D91      		ld r18,X+
 624 0006 3C91      		ld r19,X
 625 0008 1597      		sbiw r26,4+1
 626 000a 232B      		or r18,r19
 627 000c 01F0      		breq .L40
 300:../../os/rt/src/chmtx.c ****   }
 628               		.loc 1 300 0
 629 000e 80E0      		ldi r24,0
 630               	.LVL54:
 631               	/* epilogue start */
 312:../../os/rt/src/chmtx.c **** }
 632               		.loc 1 312 0
 633 0010 0895      		ret
 634               	.LVL55:
 635               	.L40:
 636               	.LBB148:
 637               	.LBB149:
 638               		.loc 3 343 0
 639 0012 E091 0000 		lds r30,ch0+5
 640 0016 F091 0000 		lds r31,ch0+5+1
 641               	.LBE149:
 642               	.LBE148:
 308:../../os/rt/src/chmtx.c ****   mp->next = currtp->mtxlist;
 643               		.loc 1 308 0
 644 001a 1596      		adiw r26,4+1
 645 001c FC93      		st X,r31
 646 001e EE93      		st -X,r30
 647 0020 1497      		sbiw r26,4
 309:../../os/rt/src/chmtx.c ****   currtp->mtxlist = mp;
 648               		.loc 1 309 0
 649 0022 238D      		ldd r18,Z+27
 650 0024 348D      		ldd r19,Z+28
 651 0026 1796      		adiw r26,6+1
 652 0028 3C93      		st X,r19
 653 002a 2E93      		st -X,r18
 654 002c 1697      		sbiw r26,6
 310:../../os/rt/src/chmtx.c ****   return true;
 655               		.loc 1 310 0
 656 002e 948F      		std Z+28,r25
 657 0030 838F      		std Z+27,r24
 311:../../os/rt/src/chmtx.c **** }
 658               		.loc 1 311 0
 659 0032 81E0      		ldi r24,lo8(1)
 660               	.LVL56:
 661 0034 0895      		ret
 662               		.cfi_endproc
 663               	.LFE199:
 665               		.section	.text.chMtxUnlock,"ax",@progbits
 666               	.global	chMtxUnlock
 668               	chMtxUnlock:
 669               	.LFB200:
 313:../../os/rt/src/chmtx.c **** 
 314:../../os/rt/src/chmtx.c **** /**
 315:../../os/rt/src/chmtx.c ****  * @brief   Unlocks the specified mutex.
 316:../../os/rt/src/chmtx.c ****  * @note    Mutexes must be unlocked in reverse lock order. Violating this
 317:../../os/rt/src/chmtx.c ****  *          rules will result in a panic if assertions are enabled.
 318:../../os/rt/src/chmtx.c ****  * @pre     The invoking thread <b>must</b> have at least one owned mutex.
 319:../../os/rt/src/chmtx.c ****  * @post    The mutex is unlocked and removed from the per-thread stack of
 320:../../os/rt/src/chmtx.c ****  *          owned mutexes.
 321:../../os/rt/src/chmtx.c ****  *
 322:../../os/rt/src/chmtx.c ****  * @param[in] mp        pointer to the @p mutex_t structure
 323:../../os/rt/src/chmtx.c ****  *
 324:../../os/rt/src/chmtx.c ****  * @api
 325:../../os/rt/src/chmtx.c ****  */
 326:../../os/rt/src/chmtx.c **** void chMtxUnlock(mutex_t *mp) {
 670               		.loc 1 326 0
 671               		.cfi_startproc
 672               	.LVL57:
 673 0000 CF93      		push r28
 674               	.LCFI4:
 675               		.cfi_def_cfa_offset 3
 676               		.cfi_offset 28, -2
 677 0002 DF93      		push r29
 678               	.LCFI5:
 679               		.cfi_def_cfa_offset 4
 680               		.cfi_offset 29, -3
 681               	/* prologue: function */
 682               	/* frame size = 0 */
 683               	/* stack size = 2 */
 684               	.L__stack_usage = 2
 685               	.LBB150:
 686               	.LBB151:
 687               		.loc 3 343 0
 688 0004 C091 0000 		lds r28,ch0+5
 689 0008 D091 0000 		lds r29,ch0+5+1
 690               	.LBE151:
 691               	.LBE150:
 692               	.LBB152:
 693               	.LBB153:
 694               	.LBB154:
 430:../../os/common/ports/AVR/chcore.h **** }
 695               		.loc 5 430 0
 696               	/* #APP */
 697               	 ;  430 "../../os/common/ports/AVR/chcore.h" 1
 698 000c F894      		cli
 699               	 ;  0 "" 2
 700               	/* #NOAPP */
 701               	.LBE154:
 702               	.LBE153:
 703               	.LBE152:
 327:../../os/rt/src/chmtx.c ****   thread_t *currtp = chThdGetSelfX();
 328:../../os/rt/src/chmtx.c ****   mutex_t *lmp;
 329:../../os/rt/src/chmtx.c **** 
 330:../../os/rt/src/chmtx.c ****   chDbgCheck(mp != NULL);
 331:../../os/rt/src/chmtx.c **** 
 332:../../os/rt/src/chmtx.c ****   chSysLock();
 333:../../os/rt/src/chmtx.c **** 
 334:../../os/rt/src/chmtx.c ****   chDbgAssert(currtp->mtxlist != NULL, "owned mutexes list empty");
 335:../../os/rt/src/chmtx.c ****   chDbgAssert(currtp->mtxlist->owner == currtp, "ownership failure");
 336:../../os/rt/src/chmtx.c **** #if CH_CFG_USE_MUTEXES_RECURSIVE == TRUE
 337:../../os/rt/src/chmtx.c ****   chDbgAssert(mp->cnt >= (cnt_t)1, "counter is not positive");
 338:../../os/rt/src/chmtx.c **** 
 339:../../os/rt/src/chmtx.c ****   if (--mp->cnt == (cnt_t)0) {
 340:../../os/rt/src/chmtx.c **** #endif
 341:../../os/rt/src/chmtx.c **** 
 342:../../os/rt/src/chmtx.c ****     chDbgAssert(currtp->mtxlist == mp, "not next in list");
 343:../../os/rt/src/chmtx.c **** 
 344:../../os/rt/src/chmtx.c ****     /* Removes the top mutex from the thread's owned mutexes list and marks
 345:../../os/rt/src/chmtx.c ****        it as not owned. Note, it is assumed to be the same mutex passed as
 346:../../os/rt/src/chmtx.c ****        parameter of this function.*/
 347:../../os/rt/src/chmtx.c ****     currtp->mtxlist = mp->next;
 704               		.loc 1 347 0
 705 000e DC01      		movw r26,r24
 706 0010 1696      		adiw r26,6
 707 0012 ED91      		ld r30,X+
 708 0014 FC91      		ld r31,X
 709 0016 1797      		sbiw r26,6+1
 710 0018 FC8F      		std Y+28,r31
 711 001a EB8F      		std Y+27,r30
 348:../../os/rt/src/chmtx.c **** 
 349:../../os/rt/src/chmtx.c ****     /* If a thread is waiting on the mutex then the fun part begins.*/
 350:../../os/rt/src/chmtx.c ****     if (chMtxQueueNotEmptyS(mp)) {
 712               		.loc 1 350 0
 713 001c 2D91      		ld r18,X+
 714 001e 3C91      		ld r19,X
 715 0020 2817      		cp r18,r24
 716 0022 3907      		cpc r19,r25
 717 0024 01F0      		breq .L42
 718               	.LBB155:
 351:../../os/rt/src/chmtx.c ****       thread_t *tp;
 352:../../os/rt/src/chmtx.c **** 
 353:../../os/rt/src/chmtx.c ****       /* Recalculates the optimal thread priority by scanning the owned
 354:../../os/rt/src/chmtx.c ****          mutexes list.*/
 355:../../os/rt/src/chmtx.c ****       tprio_t newprio = currtp->realprio;
 719               		.loc 1 355 0
 720 0026 3D8D      		ldd r19,Y+29
 721               	.LVL58:
 356:../../os/rt/src/chmtx.c ****       lmp = currtp->mtxlist;
 357:../../os/rt/src/chmtx.c ****       while (lmp != NULL) {
 722               		.loc 1 357 0
 723 0028 3097      		sbiw r30,0
 724 002a 01F0      		breq .L43
 725               	.L46:
 726               	.LVL59:
 727               	.LBB156:
 728               	.LBB157:
 729               	.LBB158:
 730               	.LBB159:
 251:../../os/rt/include/chlists.h **** }
 731               		.loc 2 251 0
 732 002c A081      		ld r26,Z
 733 002e B181      		ldd r27,Z+1
 734               	.LVL60:
 735               	.LBE159:
 736               	.LBE158:
 737               	.LBE157:
 738               	.LBE156:
 358:../../os/rt/src/chmtx.c ****         /* If the highest priority thread waiting in the mutexes list has a
 359:../../os/rt/src/chmtx.c ****            greater priority than the current thread base priority then the
 360:../../os/rt/src/chmtx.c ****            final priority will have at least that priority.*/
 361:../../os/rt/src/chmtx.c ****         if (chMtxQueueNotEmptyS(lmp) &&
 739               		.loc 1 361 0
 740 0030 EA17      		cp r30,r26
 741 0032 FB07      		cpc r31,r27
 742 0034 01F0      		breq .L44
 743 0036 1496      		adiw r26,4
 744 0038 2C91      		ld r18,X
 745 003a 3217      		cp r19,r18
 746 003c 00F4      		brsh .L44
 747 003e 322F      		mov r19,r18
 748               	.LVL61:
 749               	.L44:
 362:../../os/rt/src/chmtx.c ****             ((threadref(lmp->queue.next))->hdr.pqueue.prio > newprio)) {
 363:../../os/rt/src/chmtx.c ****           newprio = (threadref(lmp->queue.next))->hdr.pqueue.prio;
 364:../../os/rt/src/chmtx.c ****         }
 365:../../os/rt/src/chmtx.c ****         lmp = lmp->next;
 750               		.loc 1 365 0
 751 0040 0680      		ldd __tmp_reg__,Z+6
 752 0042 F781      		ldd r31,Z+7
 753 0044 E02D      		mov r30,__tmp_reg__
 754               	.LVL62:
 357:../../os/rt/src/chmtx.c ****         /* If the highest priority thread waiting in the mutexes list has a
 755               		.loc 1 357 0
 756 0046 3097      		sbiw r30,0
 757 0048 01F4      		brne .L46
 758               	.L43:
 759 004a FC01      		movw r30,r24
 760               	.LVL63:
 366:../../os/rt/src/chmtx.c ****       }
 367:../../os/rt/src/chmtx.c **** 
 368:../../os/rt/src/chmtx.c ****       /* Assigns to the current thread the highest priority among all the
 369:../../os/rt/src/chmtx.c ****          waiting threads.*/
 370:../../os/rt/src/chmtx.c ****       currtp->hdr.pqueue.prio = newprio;
 761               		.loc 1 370 0
 762 004c 3C83      		std Y+4,r19
 763               	.LVL64:
 764               	.LBB160:
 765               	.LBB161:
 281:../../os/rt/include/chlists.h **** 
 766               		.loc 2 281 0
 767 004e A081      		ld r26,Z
 768 0050 B181      		ldd r27,Z+1
 769               	.LVL65:
 283:../../os/rt/include/chlists.h ****   qp->next->prev = qp;
 770               		.loc 2 283 0
 771 0052 CD91      		ld r28,X+
 772 0054 DC91      		ld r29,X
 773 0056 1197      		sbiw r26,1
 774 0058 D183      		std Z+1,r29
 775 005a C083      		st Z,r28
 284:../../os/rt/include/chlists.h **** 
 776               		.loc 2 284 0
 777 005c 9B83      		std Y+3,r25
 778 005e 8A83      		std Y+2,r24
 779               	.LVL66:
 780               	.LBE161:
 781               	.LBE160:
 371:../../os/rt/src/chmtx.c **** 
 372:../../os/rt/src/chmtx.c ****       /* Awakens the highest priority thread waiting for the unlocked mutex and
 373:../../os/rt/src/chmtx.c ****          assigns the mutex to it.*/
 374:../../os/rt/src/chmtx.c **** #if CH_CFG_USE_MUTEXES_RECURSIVE == TRUE
 375:../../os/rt/src/chmtx.c ****       mp->cnt = (cnt_t)1;
 376:../../os/rt/src/chmtx.c **** #endif
 377:../../os/rt/src/chmtx.c ****       tp = threadref(ch_queue_fifo_remove(&mp->queue));
 378:../../os/rt/src/chmtx.c ****       mp->owner = tp;
 782               		.loc 1 378 0
 783 0060 B583      		std Z+5,r27
 784 0062 A483      		std Z+4,r26
 379:../../os/rt/src/chmtx.c ****       mp->next = tp->mtxlist;
 785               		.loc 1 379 0
 786 0064 5B96      		adiw r26,27
 787 0066 8D91      		ld r24,X+
 788 0068 9C91      		ld r25,X
 789 006a 5C97      		sbiw r26,27+1
 790               	.LVL67:
 791 006c 9783      		std Z+7,r25
 792 006e 8683      		std Z+6,r24
 380:../../os/rt/src/chmtx.c ****       tp->mtxlist = mp;
 793               		.loc 1 380 0
 794 0070 5C96      		adiw r26,27+1
 795 0072 FC93      		st X,r31
 796 0074 EE93      		st -X,r30
 797 0076 5B97      		sbiw r26,27
 381:../../os/rt/src/chmtx.c **** 
 382:../../os/rt/src/chmtx.c ****       /* Note, not using chSchWakeupS() because that function expects the
 383:../../os/rt/src/chmtx.c ****          current thread to have the higher or equal priority than the ones
 384:../../os/rt/src/chmtx.c ****          in the ready list. This is not necessarily true here because we
 385:../../os/rt/src/chmtx.c ****          just changed priority.*/
 386:../../os/rt/src/chmtx.c ****       (void) chSchReadyI(tp);
 798               		.loc 1 386 0
 799 0078 CD01      		movw r24,r26
 800 007a 0E94 0000 		call chSchReadyI
 801               	.LVL68:
 387:../../os/rt/src/chmtx.c ****       chSchRescheduleS();
 802               		.loc 1 387 0
 803 007e 0E94 0000 		call chSchRescheduleS
 804               	.LVL69:
 805               	.LBE155:
 806               	.LBB162:
 807               	.LBB163:
 808               	.LBB164:
 809               	.LBB165:
 810               		.loc 5 440 0
 811               	/* #APP */
 812               	 ;  440 "../../os/common/ports/AVR/chcore.h" 1
 813 0082 7894      		sei
 814               	 ;  0 "" 2
 815               	/* epilogue start */
 816               	/* #NOAPP */
 817               	.LBE165:
 818               	.LBE164:
 819               	.LBE163:
 820               	.LBE162:
 388:../../os/rt/src/chmtx.c ****     }
 389:../../os/rt/src/chmtx.c ****     else {
 390:../../os/rt/src/chmtx.c ****       mp->owner = NULL;
 391:../../os/rt/src/chmtx.c ****     }
 392:../../os/rt/src/chmtx.c **** #if CH_CFG_USE_MUTEXES_RECURSIVE == TRUE
 393:../../os/rt/src/chmtx.c ****   }
 394:../../os/rt/src/chmtx.c **** #endif
 395:../../os/rt/src/chmtx.c **** 
 396:../../os/rt/src/chmtx.c ****   chSysUnlock();
 397:../../os/rt/src/chmtx.c **** }
 821               		.loc 1 397 0
 822 0084 DF91      		pop r29
 823 0086 CF91      		pop r28
 824 0088 0895      		ret
 825               	.LVL70:
 826               	.L42:
 390:../../os/rt/src/chmtx.c ****     }
 827               		.loc 1 390 0
 828 008a F901      		movw r30,r18
 829 008c 1582      		std Z+5,__zero_reg__
 830 008e 1482      		std Z+4,__zero_reg__
 831               	.LBB169:
 832               	.LBB168:
 833               	.LBB167:
 834               	.LBB166:
 835               		.loc 5 440 0
 836               	/* #APP */
 837               	 ;  440 "../../os/common/ports/AVR/chcore.h" 1
 838 0090 7894      		sei
 839               	 ;  0 "" 2
 840               	/* epilogue start */
 841               	/* #NOAPP */
 842               	.LBE166:
 843               	.LBE167:
 844               	.LBE168:
 845               	.LBE169:
 846               		.loc 1 397 0
 847 0092 DF91      		pop r29
 848 0094 CF91      		pop r28
 849 0096 0895      		ret
 850               		.cfi_endproc
 851               	.LFE200:
 853               		.section	.text.chMtxUnlockS,"ax",@progbits
 854               	.global	chMtxUnlockS
 856               	chMtxUnlockS:
 857               	.LFB201:
 398:../../os/rt/src/chmtx.c **** 
 399:../../os/rt/src/chmtx.c **** /**
 400:../../os/rt/src/chmtx.c ****  * @brief   Unlocks the specified mutex.
 401:../../os/rt/src/chmtx.c ****  * @note    Mutexes must be unlocked in reverse lock order. Violating this
 402:../../os/rt/src/chmtx.c ****  *          rules will result in a panic if assertions are enabled.
 403:../../os/rt/src/chmtx.c ****  * @pre     The invoking thread <b>must</b> have at least one owned mutex.
 404:../../os/rt/src/chmtx.c ****  * @post    The mutex is unlocked and removed from the per-thread stack of
 405:../../os/rt/src/chmtx.c ****  *          owned mutexes.
 406:../../os/rt/src/chmtx.c ****  * @post    This function does not reschedule so a call to a rescheduling
 407:../../os/rt/src/chmtx.c ****  *          function must be performed before unlocking the kernel.
 408:../../os/rt/src/chmtx.c ****  *
 409:../../os/rt/src/chmtx.c ****  * @param[in] mp        pointer to the @p mutex_t structure
 410:../../os/rt/src/chmtx.c ****  *
 411:../../os/rt/src/chmtx.c ****  * @sclass
 412:../../os/rt/src/chmtx.c ****  */
 413:../../os/rt/src/chmtx.c **** void chMtxUnlockS(mutex_t *mp) {
 858               		.loc 1 413 0
 859               		.cfi_startproc
 860               	.LVL71:
 861 0000 CF93      		push r28
 862               	.LCFI6:
 863               		.cfi_def_cfa_offset 3
 864               		.cfi_offset 28, -2
 865 0002 DF93      		push r29
 866               	.LCFI7:
 867               		.cfi_def_cfa_offset 4
 868               		.cfi_offset 29, -3
 869               	/* prologue: function */
 870               	/* frame size = 0 */
 871               	/* stack size = 2 */
 872               	.L__stack_usage = 2
 873 0004 EC01      		movw r28,r24
 874               	.LBB170:
 875               	.LBB171:
 876               		.loc 3 343 0
 877 0006 2091 0000 		lds r18,ch0+5
 878 000a 3091 0000 		lds r19,ch0+5+1
 879               	.LBE171:
 880               	.LBE170:
 414:../../os/rt/src/chmtx.c ****   thread_t *currtp = chThdGetSelfX();
 415:../../os/rt/src/chmtx.c ****   mutex_t *lmp;
 416:../../os/rt/src/chmtx.c **** 
 417:../../os/rt/src/chmtx.c ****   chDbgCheckClassS();
 418:../../os/rt/src/chmtx.c ****   chDbgCheck(mp != NULL);
 419:../../os/rt/src/chmtx.c **** 
 420:../../os/rt/src/chmtx.c ****   chDbgAssert(currtp->mtxlist != NULL, "owned mutexes list empty");
 421:../../os/rt/src/chmtx.c ****   chDbgAssert(currtp->mtxlist->owner == currtp, "ownership failure");
 422:../../os/rt/src/chmtx.c **** #if CH_CFG_USE_MUTEXES_RECURSIVE == TRUE
 423:../../os/rt/src/chmtx.c ****   chDbgAssert(mp->cnt >= (cnt_t)1, "counter is not positive");
 424:../../os/rt/src/chmtx.c **** 
 425:../../os/rt/src/chmtx.c ****   if (--mp->cnt == (cnt_t)0) {
 426:../../os/rt/src/chmtx.c **** #endif
 427:../../os/rt/src/chmtx.c **** 
 428:../../os/rt/src/chmtx.c ****     chDbgAssert(currtp->mtxlist == mp, "not next in list");
 429:../../os/rt/src/chmtx.c **** 
 430:../../os/rt/src/chmtx.c ****     /* Removes the top mutex from the thread's owned mutexes list and marks
 431:../../os/rt/src/chmtx.c ****        it as not owned. Note, it is assumed to be the same mutex passed as
 432:../../os/rt/src/chmtx.c ****        parameter of this function.*/
 433:../../os/rt/src/chmtx.c ****     currtp->mtxlist = mp->next;
 881               		.loc 1 433 0
 882 000e EE81      		ldd r30,Y+6
 883 0010 FF81      		ldd r31,Y+7
 884 0012 D901      		movw r26,r18
 885 0014 5C96      		adiw r26,27+1
 886 0016 FC93      		st X,r31
 887 0018 EE93      		st -X,r30
 888 001a 5B97      		sbiw r26,27
 434:../../os/rt/src/chmtx.c **** 
 435:../../os/rt/src/chmtx.c ****     /* If a thread is waiting on the mutex then the fun part begins.*/
 436:../../os/rt/src/chmtx.c ****     if (chMtxQueueNotEmptyS(mp)) {
 889               		.loc 1 436 0
 890 001c A881      		ld r26,Y
 891 001e B981      		ldd r27,Y+1
 892 0020 A817      		cp r26,r24
 893 0022 B907      		cpc r27,r25
 894 0024 01F0      		breq .L53
 895               	.LBB172:
 437:../../os/rt/src/chmtx.c ****       thread_t *tp;
 438:../../os/rt/src/chmtx.c **** 
 439:../../os/rt/src/chmtx.c ****       /* Recalculates the optimal thread priority by scanning the owned
 440:../../os/rt/src/chmtx.c ****          mutexes list.*/
 441:../../os/rt/src/chmtx.c ****       tprio_t newprio = currtp->realprio;
 896               		.loc 1 441 0
 897 0026 D901      		movw r26,r18
 898 0028 5D96      		adiw r26,29
 899 002a 9C91      		ld r25,X
 900               	.LVL72:
 442:../../os/rt/src/chmtx.c ****       lmp = currtp->mtxlist;
 443:../../os/rt/src/chmtx.c ****       while (lmp != NULL) {
 901               		.loc 1 443 0
 902 002c 3097      		sbiw r30,0
 903 002e 01F0      		breq .L54
 904               	.LVL73:
 905               	.L57:
 906               	.LBB173:
 907               	.LBB174:
 908               	.LBB175:
 909               	.LBB176:
 251:../../os/rt/include/chlists.h **** }
 910               		.loc 2 251 0
 911 0030 A081      		ld r26,Z
 912 0032 B181      		ldd r27,Z+1
 913               	.LVL74:
 914               	.LBE176:
 915               	.LBE175:
 916               	.LBE174:
 917               	.LBE173:
 444:../../os/rt/src/chmtx.c ****         /* If the highest priority thread waiting in the mutexes list has a
 445:../../os/rt/src/chmtx.c ****            greater priority than the current thread base priority then the
 446:../../os/rt/src/chmtx.c ****            final priority will have at least that priority.*/
 447:../../os/rt/src/chmtx.c ****         if (chMtxQueueNotEmptyS(lmp) &&
 918               		.loc 1 447 0
 919 0034 EA17      		cp r30,r26
 920 0036 FB07      		cpc r31,r27
 921 0038 01F0      		breq .L55
 922 003a 1496      		adiw r26,4
 923 003c 8C91      		ld r24,X
 924 003e 9817      		cp r25,r24
 925 0040 00F4      		brsh .L55
 926 0042 982F      		mov r25,r24
 927               	.LVL75:
 928               	.L55:
 448:../../os/rt/src/chmtx.c ****             ((threadref(lmp->queue.next))->hdr.pqueue.prio > newprio)) {
 449:../../os/rt/src/chmtx.c ****           newprio = threadref(lmp->queue.next)->hdr.pqueue.prio;
 450:../../os/rt/src/chmtx.c ****         }
 451:../../os/rt/src/chmtx.c ****         lmp = lmp->next;
 929               		.loc 1 451 0
 930 0044 0680      		ldd __tmp_reg__,Z+6
 931 0046 F781      		ldd r31,Z+7
 932 0048 E02D      		mov r30,__tmp_reg__
 933               	.LVL76:
 443:../../os/rt/src/chmtx.c ****         /* If the highest priority thread waiting in the mutexes list has a
 934               		.loc 1 443 0
 935 004a 3097      		sbiw r30,0
 936 004c 01F4      		brne .L57
 937               	.L54:
 452:../../os/rt/src/chmtx.c ****       }
 453:../../os/rt/src/chmtx.c **** 
 454:../../os/rt/src/chmtx.c ****       /* Assigns to the current thread the highest priority among all the
 455:../../os/rt/src/chmtx.c ****          waiting threads.*/
 456:../../os/rt/src/chmtx.c ****       currtp->hdr.pqueue.prio = newprio;
 938               		.loc 1 456 0
 939 004e F901      		movw r30,r18
 940               	.LVL77:
 941 0050 9483      		std Z+4,r25
 942               	.LVL78:
 943               	.LBB177:
 944               	.LBB178:
 281:../../os/rt/include/chlists.h **** 
 945               		.loc 2 281 0
 946 0052 E881      		ld r30,Y
 947 0054 F981      		ldd r31,Y+1
 948               	.LVL79:
 283:../../os/rt/include/chlists.h ****   qp->next->prev = qp;
 949               		.loc 2 283 0
 950 0056 A081      		ld r26,Z
 951 0058 B181      		ldd r27,Z+1
 952 005a B983      		std Y+1,r27
 953 005c A883      		st Y,r26
 284:../../os/rt/include/chlists.h **** 
 954               		.loc 2 284 0
 955 005e 1396      		adiw r26,2+1
 956 0060 DC93      		st X,r29
 957 0062 CE93      		st -X,r28
 958 0064 1297      		sbiw r26,2
 959               	.LVL80:
 960               	.LBE178:
 961               	.LBE177:
 457:../../os/rt/src/chmtx.c **** 
 458:../../os/rt/src/chmtx.c ****       /* Awakens the highest priority thread waiting for the unlocked mutex and
 459:../../os/rt/src/chmtx.c ****          assigns the mutex to it.*/
 460:../../os/rt/src/chmtx.c **** #if CH_CFG_USE_MUTEXES_RECURSIVE == TRUE
 461:../../os/rt/src/chmtx.c ****       mp->cnt = (cnt_t)1;
 462:../../os/rt/src/chmtx.c **** #endif
 463:../../os/rt/src/chmtx.c ****       tp = threadref(ch_queue_fifo_remove(&mp->queue));
 464:../../os/rt/src/chmtx.c ****       mp->owner = tp;
 962               		.loc 1 464 0
 963 0066 FD83      		std Y+5,r31
 964 0068 EC83      		std Y+4,r30
 465:../../os/rt/src/chmtx.c ****       mp->next = tp->mtxlist;
 965               		.loc 1 465 0
 966 006a 838D      		ldd r24,Z+27
 967 006c 948D      		ldd r25,Z+28
 968 006e 9F83      		std Y+7,r25
 969 0070 8E83      		std Y+6,r24
 466:../../os/rt/src/chmtx.c ****       tp->mtxlist = mp;
 970               		.loc 1 466 0
 971 0072 D48F      		std Z+28,r29
 972 0074 C38F      		std Z+27,r28
 467:../../os/rt/src/chmtx.c ****       (void) chSchReadyI(tp);
 973               		.loc 1 467 0
 974 0076 CF01      		movw r24,r30
 975               	/* epilogue start */
 976               	.LBE172:
 468:../../os/rt/src/chmtx.c ****     }
 469:../../os/rt/src/chmtx.c ****     else {
 470:../../os/rt/src/chmtx.c ****       mp->owner = NULL;
 471:../../os/rt/src/chmtx.c ****     }
 472:../../os/rt/src/chmtx.c **** #if CH_CFG_USE_MUTEXES_RECURSIVE == TRUE
 473:../../os/rt/src/chmtx.c ****   }
 474:../../os/rt/src/chmtx.c **** #endif
 475:../../os/rt/src/chmtx.c **** }
 977               		.loc 1 475 0
 978 0078 DF91      		pop r29
 979 007a CF91      		pop r28
 980               	.LVL81:
 981               	.LBB179:
 467:../../os/rt/src/chmtx.c ****       (void) chSchReadyI(tp);
 982               		.loc 1 467 0
 983 007c 0C94 0000 		jmp chSchReadyI
 984               	.LVL82:
 985               	.L53:
 986               	.LBE179:
 470:../../os/rt/src/chmtx.c ****     }
 987               		.loc 1 470 0
 988 0080 1596      		adiw r26,4+1
 989 0082 1C92      		st X,__zero_reg__
 990 0084 1E92      		st -X,__zero_reg__
 991 0086 1497      		sbiw r26,4
 992               	/* epilogue start */
 993               		.loc 1 475 0
 994 0088 DF91      		pop r29
 995 008a CF91      		pop r28
 996 008c 0895      		ret
 997               		.cfi_endproc
 998               	.LFE201:
 1000               		.section	.text.chMtxUnlockAllS,"ax",@progbits
 1001               	.global	chMtxUnlockAllS
 1003               	chMtxUnlockAllS:
 1004               	.LFB202:
 476:../../os/rt/src/chmtx.c **** 
 477:../../os/rt/src/chmtx.c **** /**
 478:../../os/rt/src/chmtx.c ****  * @brief   Unlocks all mutexes owned by the invoking thread.
 479:../../os/rt/src/chmtx.c ****  * @post    The stack of owned mutexes is emptied and all the found
 480:../../os/rt/src/chmtx.c ****  *          mutexes are unlocked.
 481:../../os/rt/src/chmtx.c ****  * @post    This function does not reschedule so a call to a rescheduling
 482:../../os/rt/src/chmtx.c ****  *          function must be performed before unlocking the kernel.
 483:../../os/rt/src/chmtx.c ****  * @note    This function is <b>MUCH MORE</b> efficient than releasing the
 484:../../os/rt/src/chmtx.c ****  *          mutexes one by one and not just because the call overhead,
 485:../../os/rt/src/chmtx.c ****  *          this function does not have any overhead related to the priority
 486:../../os/rt/src/chmtx.c ****  *          inheritance mechanism.
 487:../../os/rt/src/chmtx.c ****  *
 488:../../os/rt/src/chmtx.c ****  * @sclass
 489:../../os/rt/src/chmtx.c ****  */
 490:../../os/rt/src/chmtx.c **** void chMtxUnlockAllS(void) {
 1005               		.loc 1 490 0
 1006               		.cfi_startproc
 1007 0000 0F93      		push r16
 1008               	.LCFI8:
 1009               		.cfi_def_cfa_offset 3
 1010               		.cfi_offset 16, -2
 1011 0002 1F93      		push r17
 1012               	.LCFI9:
 1013               		.cfi_def_cfa_offset 4
 1014               		.cfi_offset 17, -3
 1015 0004 CF93      		push r28
 1016               	.LCFI10:
 1017               		.cfi_def_cfa_offset 5
 1018               		.cfi_offset 28, -4
 1019 0006 DF93      		push r29
 1020               	.LCFI11:
 1021               		.cfi_def_cfa_offset 6
 1022               		.cfi_offset 29, -5
 1023               	/* prologue: function */
 1024               	/* frame size = 0 */
 1025               	/* stack size = 4 */
 1026               	.L__stack_usage = 4
 1027               	.LBB180:
 1028               	.LBB181:
 1029               		.loc 3 343 0
 1030 0008 0091 0000 		lds r16,ch0+5
 1031 000c 1091 0000 		lds r17,ch0+5+1
 1032               	.LBE181:
 1033               	.LBE180:
 491:../../os/rt/src/chmtx.c ****   thread_t *currtp = chThdGetSelfX();
 492:../../os/rt/src/chmtx.c **** 
 493:../../os/rt/src/chmtx.c ****   if (currtp->mtxlist != NULL) {
 1034               		.loc 1 493 0
 1035 0010 D801      		movw r26,r16
 1036 0012 5B96      		adiw r26,27
 1037 0014 ED91      		ld r30,X+
 1038 0016 FC91      		ld r31,X
 1039 0018 3097      		sbiw r30,0
 1040 001a 01F4      		brne .L66
 1041 001c 00C0      		rjmp .L62
 1042               	.LVL83:
 1043               	.L69:
 1044               	.LBB182:
 1045               	.LBB183:
 1046               	.LBB184:
 1047               	.LBB185:
 283:../../os/rt/include/chlists.h ****   qp->next->prev = qp;
 1048               		.loc 2 283 0
 1049 001e 8D91      		ld r24,X+
 1050 0020 9C91      		ld r25,X
 1051 0022 1197      		sbiw r26,1
 1052 0024 9183      		std Z+1,r25
 1053 0026 8083      		st Z,r24
 284:../../os/rt/include/chlists.h **** 
 1054               		.loc 2 284 0
 1055 0028 EC01      		movw r28,r24
 1056 002a FB83      		std Y+3,r31
 1057 002c EA83      		std Y+2,r30
 1058               	.LVL84:
 1059               	.LBE185:
 1060               	.LBE184:
 494:../../os/rt/src/chmtx.c ****     do {
 495:../../os/rt/src/chmtx.c ****       mutex_t *mp = currtp->mtxlist;
 496:../../os/rt/src/chmtx.c ****       currtp->mtxlist = mp->next;
 497:../../os/rt/src/chmtx.c ****       if (chMtxQueueNotEmptyS(mp)) {
 498:../../os/rt/src/chmtx.c ****         thread_t *tp;
 499:../../os/rt/src/chmtx.c **** #if CH_CFG_USE_MUTEXES_RECURSIVE == TRUE
 500:../../os/rt/src/chmtx.c ****         mp->cnt = (cnt_t)1;
 501:../../os/rt/src/chmtx.c **** #endif
 502:../../os/rt/src/chmtx.c ****         tp = threadref(ch_queue_fifo_remove(&mp->queue));
 503:../../os/rt/src/chmtx.c ****         mp->owner   = tp;
 1061               		.loc 1 503 0
 1062 002e B583      		std Z+5,r27
 1063 0030 A483      		std Z+4,r26
 504:../../os/rt/src/chmtx.c ****         mp->next    = tp->mtxlist;
 1064               		.loc 1 504 0
 1065 0032 5B96      		adiw r26,27
 1066 0034 8D91      		ld r24,X+
 1067 0036 9C91      		ld r25,X
 1068 0038 5C97      		sbiw r26,27+1
 1069 003a 9783      		std Z+7,r25
 1070 003c 8683      		std Z+6,r24
 505:../../os/rt/src/chmtx.c ****         tp->mtxlist = mp;
 1071               		.loc 1 505 0
 1072 003e 5C96      		adiw r26,27+1
 1073 0040 FC93      		st X,r31
 1074 0042 EE93      		st -X,r30
 1075 0044 5B97      		sbiw r26,27
 506:../../os/rt/src/chmtx.c ****         (void) chSchReadyI(tp);
 1076               		.loc 1 506 0
 1077 0046 CD01      		movw r24,r26
 1078 0048 0E94 0000 		call chSchReadyI
 1079               	.LVL85:
 1080 004c D801      		movw r26,r16
 1081 004e 5B96      		adiw r26,27
 1082 0050 ED91      		ld r30,X+
 1083 0052 FC91      		ld r31,X
 1084               	.LBE183:
 1085               	.LBE182:
 507:../../os/rt/src/chmtx.c ****       }
 508:../../os/rt/src/chmtx.c ****       else {
 509:../../os/rt/src/chmtx.c **** #if CH_CFG_USE_MUTEXES_RECURSIVE == TRUE
 510:../../os/rt/src/chmtx.c ****         mp->cnt = (cnt_t)0;
 511:../../os/rt/src/chmtx.c **** #endif
 512:../../os/rt/src/chmtx.c ****         mp->owner = NULL;
 513:../../os/rt/src/chmtx.c ****       }
 514:../../os/rt/src/chmtx.c ****     } while (currtp->mtxlist != NULL);
 1086               		.loc 1 514 0
 1087 0054 3097      		sbiw r30,0
 1088 0056 01F0      		breq .L68
 1089               	.L66:
 1090               	.LVL86:
 1091               	.LBB190:
 496:../../os/rt/src/chmtx.c ****       if (chMtxQueueNotEmptyS(mp)) {
 1092               		.loc 1 496 0
 1093 0058 9681      		ldd r25,Z+6
 1094 005a 8781      		ldd r24,Z+7
 1095 005c E801      		movw r28,r16
 1096 005e 9B8F      		std Y+27,r25
 1097               	.LVL87:
 1098 0060 8C8F      		std Y+28,r24
 1099               	.LVL88:
 1100               	.LBB186:
 1101               	.LBB187:
 1102               	.LBB188:
 1103               	.LBB189:
 251:../../os/rt/include/chlists.h **** }
 1104               		.loc 2 251 0
 1105 0062 A081      		ld r26,Z
 1106 0064 B181      		ldd r27,Z+1
 1107               	.LVL89:
 1108               	.LBE189:
 1109               	.LBE188:
 1110               	.LBE187:
 1111               	.LBE186:
 497:../../os/rt/src/chmtx.c ****         thread_t *tp;
 1112               		.loc 1 497 0
 1113 0066 EA17      		cp r30,r26
 1114 0068 FB07      		cpc r31,r27
 1115 006a 01F4      		brne .L69
 512:../../os/rt/src/chmtx.c ****       }
 1116               		.loc 1 512 0
 1117 006c 1582      		std Z+5,__zero_reg__
 1118 006e 1482      		std Z+4,__zero_reg__
 1119 0070 E92F      		mov r30,r25
 1120 0072 F82F      		mov r31,r24
 1121               	.LBE190:
 1122               		.loc 1 514 0
 1123 0074 3097      		sbiw r30,0
 1124 0076 01F4      		brne .L66
 1125               	.L68:
 515:../../os/rt/src/chmtx.c ****     currtp->hdr.pqueue.prio = currtp->realprio;
 1126               		.loc 1 515 0
 1127 0078 E801      		movw r28,r16
 1128 007a 8D8D      		ldd r24,Y+29
 1129 007c 8C83      		std Y+4,r24
 1130               	/* epilogue start */
 516:../../os/rt/src/chmtx.c ****     chSchRescheduleS();
 517:../../os/rt/src/chmtx.c ****   }
 518:../../os/rt/src/chmtx.c **** }
 1131               		.loc 1 518 0
 1132 007e DF91      		pop r29
 1133 0080 CF91      		pop r28
 1134 0082 1F91      		pop r17
 1135 0084 0F91      		pop r16
 516:../../os/rt/src/chmtx.c ****     chSchRescheduleS();
 1136               		.loc 1 516 0
 1137 0086 0C94 0000 		jmp chSchRescheduleS
 1138               	.LVL90:
 1139               	.L62:
 1140               	/* epilogue start */
 1141               		.loc 1 518 0
 1142 008a DF91      		pop r29
 1143 008c CF91      		pop r28
 1144 008e 1F91      		pop r17
 1145 0090 0F91      		pop r16
 1146 0092 0895      		ret
 1147               		.cfi_endproc
 1148               	.LFE202:
 1150               		.section	.text.chMtxUnlockAll,"ax",@progbits
 1151               	.global	chMtxUnlockAll
 1153               	chMtxUnlockAll:
 1154               	.LFB203:
 519:../../os/rt/src/chmtx.c **** 
 520:../../os/rt/src/chmtx.c **** /**
 521:../../os/rt/src/chmtx.c ****  * @brief   Unlocks all mutexes owned by the invoking thread.
 522:../../os/rt/src/chmtx.c ****  * @post    The stack of owned mutexes is emptied and all the found
 523:../../os/rt/src/chmtx.c ****  *          mutexes are unlocked.
 524:../../os/rt/src/chmtx.c ****  * @note    This function is <b>MUCH MORE</b> efficient than releasing the
 525:../../os/rt/src/chmtx.c ****  *          mutexes one by one and not just because the call overhead,
 526:../../os/rt/src/chmtx.c ****  *          this function does not have any overhead related to the priority
 527:../../os/rt/src/chmtx.c ****  *          inheritance mechanism.
 528:../../os/rt/src/chmtx.c ****  *
 529:../../os/rt/src/chmtx.c ****  * @api
 530:../../os/rt/src/chmtx.c ****  */
 531:../../os/rt/src/chmtx.c **** void chMtxUnlockAll(void) {
 1155               		.loc 1 531 0
 1156               		.cfi_startproc
 1157               	/* prologue: function */
 1158               	/* frame size = 0 */
 1159               	/* stack size = 0 */
 1160               	.L__stack_usage = 0
 1161               	.LBB191:
 1162               	.LBB192:
 1163               	.LBB193:
 430:../../os/common/ports/AVR/chcore.h **** }
 1164               		.loc 5 430 0
 1165               	/* #APP */
 1166               	 ;  430 "../../os/common/ports/AVR/chcore.h" 1
 1167 0000 F894      		cli
 1168               	 ;  0 "" 2
 1169               	/* #NOAPP */
 1170               	.LBE193:
 1171               	.LBE192:
 1172               	.LBE191:
 532:../../os/rt/src/chmtx.c **** 
 533:../../os/rt/src/chmtx.c ****   chSysLock();
 534:../../os/rt/src/chmtx.c ****   chMtxUnlockAllS();
 1173               		.loc 1 534 0
 1174 0002 0E94 0000 		call chMtxUnlockAllS
 1175               	.LVL91:
 1176               	.LBB194:
 1177               	.LBB195:
 1178               	.LBB196:
 1179               	.LBB197:
 1180               		.loc 5 440 0
 1181               	/* #APP */
 1182               	 ;  440 "../../os/common/ports/AVR/chcore.h" 1
 1183 0006 7894      		sei
 1184               	 ;  0 "" 2
 1185               	/* epilogue start */
 1186               	/* #NOAPP */
 1187               	.LBE197:
 1188               	.LBE196:
 1189               	.LBE195:
 1190               	.LBE194:
 535:../../os/rt/src/chmtx.c ****   chSysUnlock();
 536:../../os/rt/src/chmtx.c **** }
 1191               		.loc 1 536 0
 1192 0008 0895      		ret
 1193               		.cfi_endproc
 1194               	.LFE203:
 1196               		.text
 1197               	.Letext0:
 1198               		.file 6 "/usr/lib/avr/include/stdint.h"
 1199               		.file 7 "../../os/common/ports/AVR/compilers/GCC/chtypes.h"
 1200               		.file 8 "../../os/rt/include/chearly.h"
 1201               		.file 9 "../../os/rt/include/chobjects.h"
 1202               		.file 10 "../../os/rt/include/chrfcu.h"
 1203               		.file 11 "../../os/rt/include/chdebug.h"
 1204               		.file 12 "../../os/rt/include/chtime.h"
 1205               		.file 13 "../../os/rt/include/chsem.h"
 1206               		.file 14 "../../os/rt/include/chmtx.h"
 1207               		.file 15 "../../os/rt/include/chsys.h"
 1208               		.file 16 "../../os/rt/include/chregistry.h"
 1209               		.file 17 "../../os/oslib/include/chmemcore.h"
DEFINED SYMBOLS
                            *ABS*:0000000000000000 chmtx.c
     /tmp/ccn3nbrh.s:2      *ABS*:000000000000003e __SP_H__
     /tmp/ccn3nbrh.s:3      *ABS*:000000000000003d __SP_L__
     /tmp/ccn3nbrh.s:4      *ABS*:000000000000003f __SREG__
     /tmp/ccn3nbrh.s:5      *ABS*:0000000000000000 __tmp_reg__
     /tmp/ccn3nbrh.s:6      *ABS*:0000000000000001 __zero_reg__
     /tmp/ccn3nbrh.s:13     .text.chMtxObjectInit:0000000000000000 chMtxObjectInit
     /tmp/ccn3nbrh.s:49     .text.chMtxLockS:0000000000000000 chMtxLockS
     /tmp/ccn3nbrh.s:455    .text.chMtxLock:0000000000000000 chMtxLock
     /tmp/ccn3nbrh.s:503    .text.chMtxTryLock:0000000000000000 chMtxTryLock
     /tmp/ccn3nbrh.s:611    .text.chMtxTryLockS:0000000000000000 chMtxTryLockS
     /tmp/ccn3nbrh.s:668    .text.chMtxUnlock:0000000000000000 chMtxUnlock
     /tmp/ccn3nbrh.s:856    .text.chMtxUnlockS:0000000000000000 chMtxUnlockS
     /tmp/ccn3nbrh.s:1003   .text.chMtxUnlockAllS:0000000000000000 chMtxUnlockAllS
     /tmp/ccn3nbrh.s:1153   .text.chMtxUnlockAll:0000000000000000 chMtxUnlockAll

UNDEFINED SYMBOLS
ch0
chSchGoSleepS
chSchReadyI
chSchRescheduleS
